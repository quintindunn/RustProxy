// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: main.proto

#ifndef PROTOBUF_main_2eproto__INCLUDED
#define PROTOBUF_main_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_main_2eproto();
void protobuf_AssignDesc_main_2eproto();
void protobuf_ShutdownFile_main_2eproto();

class Vector3Serialized;
class RaySerialized;
class BaseNetworkable;
class BaseEntity;
class Item;
class Item_InstanceData;
class Item_ConditionData;
class ItemContainer;
class PlayerInventory;
class PlayerMetabolism;
class ModelState;
class PersistantPlayer;
class PlayerLifeStory;
class PlayerLifeStory_DeathInfo;
class BasePlayer;
class WorldItem;
class BaseResource;
class BuildingBlock;
class Environment;
class Corpse;
class ParentInfo;
class KeyLock;
class CodeLock;
class CodeLock_Private;
class EntitySlots;
class PlayerNameID;
class BuildingPrivilege;
class StorageBox;
class HeldEntity;
class Magazine;
class BaseProjectile;
class BaseNPC;
class Loot;
class GenericSpawner;
class GenericSpawner_SpawnedEnt;
class SleepingBag;
class SleepingBag_Private;
class LootableCorpse;
class LootableCorpse_Private;
class Sign;
class BaseCombat;
class MapEntity;
class ResearchTable;
class DudExplosive;
class ResourceExtractor;
class MiningQuarry;
class PlantEntity;
class Helicopter;
class Landmine;
class AutoTurret;
class SphereEntity;
class StabilityEntity;
class OwnerInfo;
class DecayEntity;
class Spawnable;
class ServerGib;
class VendingMachine;
class VendingMachine_SellOrder;
class VendingMachine_SellOrderContainer;
class SpinnerWheel;
class Entity;
class Approval;
class Attack;
class ClientReady;
class ClientReady_ClientInfo;
class CreateBuilding;
class EntityList;
class ModuleMessage;
class PlayerAttack;
class PlayerProjectileAttack;
class PlayerProjectileRicochet;
class PlayerProjectileUpdate;
class PlayerUpdateLoot;
class ProjectileShoot;
class ProjectileShoot_Projectile;
class RespawnInformation;
class RespawnInformation_SpawnOptions;
class TakeDamage;
class UpdateItem;
class UpdateItemContainer;

enum RespawnInformation_SpawnOptions_RespawnType {
  RespawnInformation_SpawnOptions_RespawnType_SleepingBag = 1,
  RespawnInformation_SpawnOptions_RespawnType_Bed = 2
};
bool RespawnInformation_SpawnOptions_RespawnType_IsValid(int value);
const RespawnInformation_SpawnOptions_RespawnType RespawnInformation_SpawnOptions_RespawnType_RespawnType_MIN = RespawnInformation_SpawnOptions_RespawnType_SleepingBag;
const RespawnInformation_SpawnOptions_RespawnType RespawnInformation_SpawnOptions_RespawnType_RespawnType_MAX = RespawnInformation_SpawnOptions_RespawnType_Bed;
const int RespawnInformation_SpawnOptions_RespawnType_RespawnType_ARRAYSIZE = RespawnInformation_SpawnOptions_RespawnType_RespawnType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RespawnInformation_SpawnOptions_RespawnType_descriptor();
inline const ::std::string& RespawnInformation_SpawnOptions_RespawnType_Name(RespawnInformation_SpawnOptions_RespawnType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RespawnInformation_SpawnOptions_RespawnType_descriptor(), value);
}
inline bool RespawnInformation_SpawnOptions_RespawnType_Parse(
    const ::std::string& name, RespawnInformation_SpawnOptions_RespawnType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RespawnInformation_SpawnOptions_RespawnType>(
    RespawnInformation_SpawnOptions_RespawnType_descriptor(), name, value);
}
// ===================================================================

class Vector3Serialized : public ::google::protobuf::Message {
 public:
  Vector3Serialized();
  virtual ~Vector3Serialized();

  Vector3Serialized(const Vector3Serialized& from);

  inline Vector3Serialized& operator=(const Vector3Serialized& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector3Serialized& default_instance();

  void Swap(Vector3Serialized* other);

  // implements Message ----------------------------------------------

  Vector3Serialized* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vector3Serialized& from);
  void MergeFrom(const Vector3Serialized& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // required float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);

  // @@protoc_insertion_point(class_scope:Vector3Serialized)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float x_;
  float y_;
  float z_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static Vector3Serialized* default_instance_;
};
// -------------------------------------------------------------------

class RaySerialized : public ::google::protobuf::Message {
 public:
  RaySerialized();
  virtual ~RaySerialized();

  RaySerialized(const RaySerialized& from);

  inline RaySerialized& operator=(const RaySerialized& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RaySerialized& default_instance();

  void Swap(RaySerialized* other);

  // implements Message ----------------------------------------------

  RaySerialized* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RaySerialized& from);
  void MergeFrom(const RaySerialized& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Vector3Serialized origin = 1;
  inline bool has_origin() const;
  inline void clear_origin();
  static const int kOriginFieldNumber = 1;
  inline const ::Vector3Serialized& origin() const;
  inline ::Vector3Serialized* mutable_origin();
  inline ::Vector3Serialized* release_origin();
  inline void set_allocated_origin(::Vector3Serialized* origin);

  // required .Vector3Serialized direction = 2;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 2;
  inline const ::Vector3Serialized& direction() const;
  inline ::Vector3Serialized* mutable_direction();
  inline ::Vector3Serialized* release_direction();
  inline void set_allocated_direction(::Vector3Serialized* direction);

  // @@protoc_insertion_point(class_scope:RaySerialized)
 private:
  inline void set_has_origin();
  inline void clear_has_origin();
  inline void set_has_direction();
  inline void clear_has_direction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Vector3Serialized* origin_;
  ::Vector3Serialized* direction_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static RaySerialized* default_instance_;
};
// -------------------------------------------------------------------

class BaseNetworkable : public ::google::protobuf::Message {
 public:
  BaseNetworkable();
  virtual ~BaseNetworkable();

  BaseNetworkable(const BaseNetworkable& from);

  inline BaseNetworkable& operator=(const BaseNetworkable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BaseNetworkable& default_instance();

  void Swap(BaseNetworkable* other);

  // implements Message ----------------------------------------------

  BaseNetworkable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BaseNetworkable& from);
  void MergeFrom(const BaseNetworkable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint32 uid() const;
  inline void set_uid(::google::protobuf::uint32 value);

  // required uint32 group = 2;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 2;
  inline ::google::protobuf::uint32 group() const;
  inline void set_group(::google::protobuf::uint32 value);

  // required uint32 prefabID = 3;
  inline bool has_prefabid() const;
  inline void clear_prefabid();
  static const int kPrefabIDFieldNumber = 3;
  inline ::google::protobuf::uint32 prefabid() const;
  inline void set_prefabid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:BaseNetworkable)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_group();
  inline void clear_has_group();
  inline void set_has_prefabid();
  inline void clear_has_prefabid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 uid_;
  ::google::protobuf::uint32 group_;
  ::google::protobuf::uint32 prefabid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static BaseNetworkable* default_instance_;
};
// -------------------------------------------------------------------

class BaseEntity : public ::google::protobuf::Message {
 public:
  BaseEntity();
  virtual ~BaseEntity();

  BaseEntity(const BaseEntity& from);

  inline BaseEntity& operator=(const BaseEntity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BaseEntity& default_instance();

  void Swap(BaseEntity* other);

  // implements Message ----------------------------------------------

  BaseEntity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BaseEntity& from);
  void MergeFrom(const BaseEntity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Vector3Serialized pos = 1;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 1;
  inline const ::Vector3Serialized& pos() const;
  inline ::Vector3Serialized* mutable_pos();
  inline ::Vector3Serialized* release_pos();
  inline void set_allocated_pos(::Vector3Serialized* pos);

  // required .Vector3Serialized rot = 2;
  inline bool has_rot() const;
  inline void clear_rot();
  static const int kRotFieldNumber = 2;
  inline const ::Vector3Serialized& rot() const;
  inline ::Vector3Serialized* mutable_rot();
  inline ::Vector3Serialized* release_rot();
  inline void set_allocated_rot(::Vector3Serialized* rot);

  // required uint64 flags = 3;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 3;
  inline ::google::protobuf::uint64 flags() const;
  inline void set_flags(::google::protobuf::uint64 value);

  // optional uint64 skinid = 4;
  inline bool has_skinid() const;
  inline void clear_skinid();
  static const int kSkinidFieldNumber = 4;
  inline ::google::protobuf::uint64 skinid() const;
  inline void set_skinid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:BaseEntity)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_rot();
  inline void clear_has_rot();
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_skinid();
  inline void clear_has_skinid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Vector3Serialized* pos_;
  ::Vector3Serialized* rot_;
  ::google::protobuf::uint64 flags_;
  ::google::protobuf::uint64 skinid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static BaseEntity* default_instance_;
};
// -------------------------------------------------------------------

class Item_InstanceData : public ::google::protobuf::Message {
 public:
  Item_InstanceData();
  virtual ~Item_InstanceData();

  Item_InstanceData(const Item_InstanceData& from);

  inline Item_InstanceData& operator=(const Item_InstanceData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Item_InstanceData& default_instance();

  void Swap(Item_InstanceData* other);

  // implements Message ----------------------------------------------

  Item_InstanceData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Item_InstanceData& from);
  void MergeFrom(const Item_InstanceData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 dataInt = 1;
  inline bool has_dataint() const;
  inline void clear_dataint();
  static const int kDataIntFieldNumber = 1;
  inline ::google::protobuf::uint64 dataint() const;
  inline void set_dataint(::google::protobuf::uint64 value);

  // required uint64 blueprintTarget = 2;
  inline bool has_blueprinttarget() const;
  inline void clear_blueprinttarget();
  static const int kBlueprintTargetFieldNumber = 2;
  inline ::google::protobuf::uint64 blueprinttarget() const;
  inline void set_blueprinttarget(::google::protobuf::uint64 value);

  // required uint64 blueprintAmount = 3;
  inline bool has_blueprintamount() const;
  inline void clear_blueprintamount();
  static const int kBlueprintAmountFieldNumber = 3;
  inline ::google::protobuf::uint64 blueprintamount() const;
  inline void set_blueprintamount(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Item.InstanceData)
 private:
  inline void set_has_dataint();
  inline void clear_has_dataint();
  inline void set_has_blueprinttarget();
  inline void clear_has_blueprinttarget();
  inline void set_has_blueprintamount();
  inline void clear_has_blueprintamount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 dataint_;
  ::google::protobuf::uint64 blueprinttarget_;
  ::google::protobuf::uint64 blueprintamount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static Item_InstanceData* default_instance_;
};
// -------------------------------------------------------------------

class Item_ConditionData : public ::google::protobuf::Message {
 public:
  Item_ConditionData();
  virtual ~Item_ConditionData();

  Item_ConditionData(const Item_ConditionData& from);

  inline Item_ConditionData& operator=(const Item_ConditionData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Item_ConditionData& default_instance();

  void Swap(Item_ConditionData* other);

  // implements Message ----------------------------------------------

  Item_ConditionData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Item_ConditionData& from);
  void MergeFrom(const Item_ConditionData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float condition = 1;
  inline bool has_condition() const;
  inline void clear_condition();
  static const int kConditionFieldNumber = 1;
  inline float condition() const;
  inline void set_condition(float value);

  // required float maxCondition = 2;
  inline bool has_maxcondition() const;
  inline void clear_maxcondition();
  static const int kMaxConditionFieldNumber = 2;
  inline float maxcondition() const;
  inline void set_maxcondition(float value);

  // @@protoc_insertion_point(class_scope:Item.ConditionData)
 private:
  inline void set_has_condition();
  inline void clear_has_condition();
  inline void set_has_maxcondition();
  inline void clear_has_maxcondition();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float condition_;
  float maxcondition_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static Item_ConditionData* default_instance_;
};
// -------------------------------------------------------------------

class Item : public ::google::protobuf::Message {
 public:
  Item();
  virtual ~Item();

  Item(const Item& from);

  inline Item& operator=(const Item& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Item& default_instance();

  void Swap(Item* other);

  // implements Message ----------------------------------------------

  Item* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Item& from);
  void MergeFrom(const Item& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Item_InstanceData InstanceData;
  typedef Item_ConditionData ConditionData;

  // accessors -------------------------------------------------------

  // required uint32 UID = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUIDFieldNumber = 1;
  inline ::google::protobuf::uint32 uid() const;
  inline void set_uid(::google::protobuf::uint32 value);

  // required uint64 itemid = 2;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemidFieldNumber = 2;
  inline ::google::protobuf::uint64 itemid() const;
  inline void set_itemid(::google::protobuf::uint64 value);

  // required uint64 slot = 3;
  inline bool has_slot() const;
  inline void clear_slot();
  static const int kSlotFieldNumber = 3;
  inline ::google::protobuf::uint64 slot() const;
  inline void set_slot(::google::protobuf::uint64 value);

  // required uint64 amount = 4;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 4;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // required uint64 flags = 5;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 5;
  inline ::google::protobuf::uint64 flags() const;
  inline void set_flags(::google::protobuf::uint64 value);

  // required float removetime = 6;
  inline bool has_removetime() const;
  inline void clear_removetime();
  static const int kRemovetimeFieldNumber = 6;
  inline float removetime() const;
  inline void set_removetime(float value);

  // required float locktime = 7;
  inline bool has_locktime() const;
  inline void clear_locktime();
  static const int kLocktimeFieldNumber = 7;
  inline float locktime() const;
  inline void set_locktime(float value);

  // required uint32 worldEntity = 8;
  inline bool has_worldentity() const;
  inline void clear_worldentity();
  static const int kWorldEntityFieldNumber = 8;
  inline ::google::protobuf::uint32 worldentity() const;
  inline void set_worldentity(::google::protobuf::uint32 value);

  // optional .Item.InstanceData instanceData = 9;
  inline bool has_instancedata() const;
  inline void clear_instancedata();
  static const int kInstanceDataFieldNumber = 9;
  inline const ::Item_InstanceData& instancedata() const;
  inline ::Item_InstanceData* mutable_instancedata();
  inline ::Item_InstanceData* release_instancedata();
  inline void set_allocated_instancedata(::Item_InstanceData* instancedata);

  // required uint32 heldEntity = 10;
  inline bool has_heldentity() const;
  inline void clear_heldentity();
  static const int kHeldEntityFieldNumber = 10;
  inline ::google::protobuf::uint32 heldentity() const;
  inline void set_heldentity(::google::protobuf::uint32 value);

  // optional .Item.ConditionData conditionData = 11;
  inline bool has_conditiondata() const;
  inline void clear_conditiondata();
  static const int kConditionDataFieldNumber = 11;
  inline const ::Item_ConditionData& conditiondata() const;
  inline ::Item_ConditionData* mutable_conditiondata();
  inline ::Item_ConditionData* release_conditiondata();
  inline void set_allocated_conditiondata(::Item_ConditionData* conditiondata);

  // optional string name = 14;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 14;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string text = 15;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 15;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // required uint64 skinid = 16;
  inline bool has_skinid() const;
  inline void clear_skinid();
  static const int kSkinidFieldNumber = 16;
  inline ::google::protobuf::uint64 skinid() const;
  inline void set_skinid(::google::protobuf::uint64 value);

  // optional .ItemContainer contents = 100;
  inline bool has_contents() const;
  inline void clear_contents();
  static const int kContentsFieldNumber = 100;
  inline const ::ItemContainer& contents() const;
  inline ::ItemContainer* mutable_contents();
  inline ::ItemContainer* release_contents();
  inline void set_allocated_contents(::ItemContainer* contents);

  // @@protoc_insertion_point(class_scope:Item)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_slot();
  inline void clear_has_slot();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_removetime();
  inline void clear_has_removetime();
  inline void set_has_locktime();
  inline void clear_has_locktime();
  inline void set_has_worldentity();
  inline void clear_has_worldentity();
  inline void set_has_instancedata();
  inline void clear_has_instancedata();
  inline void set_has_heldentity();
  inline void clear_has_heldentity();
  inline void set_has_conditiondata();
  inline void clear_has_conditiondata();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_skinid();
  inline void clear_has_skinid();
  inline void set_has_contents();
  inline void clear_has_contents();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 itemid_;
  ::google::protobuf::uint64 slot_;
  ::google::protobuf::uint32 uid_;
  float removetime_;
  ::google::protobuf::uint64 amount_;
  ::google::protobuf::uint64 flags_;
  float locktime_;
  ::google::protobuf::uint32 worldentity_;
  ::Item_InstanceData* instancedata_;
  ::Item_ConditionData* conditiondata_;
  ::std::string* name_;
  ::std::string* text_;
  ::google::protobuf::uint64 skinid_;
  ::ItemContainer* contents_;
  ::google::protobuf::uint32 heldentity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static Item* default_instance_;
};
// -------------------------------------------------------------------

class ItemContainer : public ::google::protobuf::Message {
 public:
  ItemContainer();
  virtual ~ItemContainer();

  ItemContainer(const ItemContainer& from);

  inline ItemContainer& operator=(const ItemContainer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ItemContainer& default_instance();

  void Swap(ItemContainer* other);

  // implements Message ----------------------------------------------

  ItemContainer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ItemContainer& from);
  void MergeFrom(const ItemContainer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 UID = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUIDFieldNumber = 1;
  inline ::google::protobuf::uint32 uid() const;
  inline void set_uid(::google::protobuf::uint32 value);

  // required uint64 slots = 2;
  inline bool has_slots() const;
  inline void clear_slots();
  static const int kSlotsFieldNumber = 2;
  inline ::google::protobuf::uint64 slots() const;
  inline void set_slots(::google::protobuf::uint64 value);

  // required float temperature = 3;
  inline bool has_temperature() const;
  inline void clear_temperature();
  static const int kTemperatureFieldNumber = 3;
  inline float temperature() const;
  inline void set_temperature(float value);

  // required uint64 flags = 4;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 4;
  inline ::google::protobuf::uint64 flags() const;
  inline void set_flags(::google::protobuf::uint64 value);

  // required uint64 allowedContents = 5;
  inline bool has_allowedcontents() const;
  inline void clear_allowedcontents();
  static const int kAllowedContentsFieldNumber = 5;
  inline ::google::protobuf::uint64 allowedcontents() const;
  inline void set_allowedcontents(::google::protobuf::uint64 value);

  // required uint64 maxStackSize = 6;
  inline bool has_maxstacksize() const;
  inline void clear_maxstacksize();
  static const int kMaxStackSizeFieldNumber = 6;
  inline ::google::protobuf::uint64 maxstacksize() const;
  inline void set_maxstacksize(::google::protobuf::uint64 value);

  // required uint64 allowedItem = 7;
  inline bool has_alloweditem() const;
  inline void clear_alloweditem();
  static const int kAllowedItemFieldNumber = 7;
  inline ::google::protobuf::uint64 alloweditem() const;
  inline void set_alloweditem(::google::protobuf::uint64 value);

  // repeated uint64 availableSlots = 8;
  inline int availableslots_size() const;
  inline void clear_availableslots();
  static const int kAvailableSlotsFieldNumber = 8;
  inline ::google::protobuf::uint64 availableslots(int index) const;
  inline void set_availableslots(int index, ::google::protobuf::uint64 value);
  inline void add_availableslots(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      availableslots() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_availableslots();

  // repeated .Item contents = 100;
  inline int contents_size() const;
  inline void clear_contents();
  static const int kContentsFieldNumber = 100;
  inline const ::Item& contents(int index) const;
  inline ::Item* mutable_contents(int index);
  inline ::Item* add_contents();
  inline const ::google::protobuf::RepeatedPtrField< ::Item >&
      contents() const;
  inline ::google::protobuf::RepeatedPtrField< ::Item >*
      mutable_contents();

  // @@protoc_insertion_point(class_scope:ItemContainer)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_slots();
  inline void clear_has_slots();
  inline void set_has_temperature();
  inline void clear_has_temperature();
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_allowedcontents();
  inline void clear_has_allowedcontents();
  inline void set_has_maxstacksize();
  inline void clear_has_maxstacksize();
  inline void set_has_alloweditem();
  inline void clear_has_alloweditem();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 slots_;
  ::google::protobuf::uint32 uid_;
  float temperature_;
  ::google::protobuf::uint64 flags_;
  ::google::protobuf::uint64 allowedcontents_;
  ::google::protobuf::uint64 maxstacksize_;
  ::google::protobuf::uint64 alloweditem_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > availableslots_;
  ::google::protobuf::RepeatedPtrField< ::Item > contents_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static ItemContainer* default_instance_;
};
// -------------------------------------------------------------------

class PlayerInventory : public ::google::protobuf::Message {
 public:
  PlayerInventory();
  virtual ~PlayerInventory();

  PlayerInventory(const PlayerInventory& from);

  inline PlayerInventory& operator=(const PlayerInventory& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerInventory& default_instance();

  void Swap(PlayerInventory* other);

  // implements Message ----------------------------------------------

  PlayerInventory* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerInventory& from);
  void MergeFrom(const PlayerInventory& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ItemContainer invMain = 1;
  inline bool has_invmain() const;
  inline void clear_invmain();
  static const int kInvMainFieldNumber = 1;
  inline const ::ItemContainer& invmain() const;
  inline ::ItemContainer* mutable_invmain();
  inline ::ItemContainer* release_invmain();
  inline void set_allocated_invmain(::ItemContainer* invmain);

  // optional .ItemContainer invBelt = 2;
  inline bool has_invbelt() const;
  inline void clear_invbelt();
  static const int kInvBeltFieldNumber = 2;
  inline const ::ItemContainer& invbelt() const;
  inline ::ItemContainer* mutable_invbelt();
  inline ::ItemContainer* release_invbelt();
  inline void set_allocated_invbelt(::ItemContainer* invbelt);

  // optional .ItemContainer invWear = 4;
  inline bool has_invwear() const;
  inline void clear_invwear();
  static const int kInvWearFieldNumber = 4;
  inline const ::ItemContainer& invwear() const;
  inline ::ItemContainer* mutable_invwear();
  inline ::ItemContainer* release_invwear();
  inline void set_allocated_invwear(::ItemContainer* invwear);

  // @@protoc_insertion_point(class_scope:PlayerInventory)
 private:
  inline void set_has_invmain();
  inline void clear_has_invmain();
  inline void set_has_invbelt();
  inline void clear_has_invbelt();
  inline void set_has_invwear();
  inline void clear_has_invwear();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ItemContainer* invmain_;
  ::ItemContainer* invbelt_;
  ::ItemContainer* invwear_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static PlayerInventory* default_instance_;
};
// -------------------------------------------------------------------

class PlayerMetabolism : public ::google::protobuf::Message {
 public:
  PlayerMetabolism();
  virtual ~PlayerMetabolism();

  PlayerMetabolism(const PlayerMetabolism& from);

  inline PlayerMetabolism& operator=(const PlayerMetabolism& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerMetabolism& default_instance();

  void Swap(PlayerMetabolism* other);

  // implements Message ----------------------------------------------

  PlayerMetabolism* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerMetabolism& from);
  void MergeFrom(const PlayerMetabolism& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float health = 1;
  inline bool has_health() const;
  inline void clear_health();
  static const int kHealthFieldNumber = 1;
  inline float health() const;
  inline void set_health(float value);

  // required float calories = 2;
  inline bool has_calories() const;
  inline void clear_calories();
  static const int kCaloriesFieldNumber = 2;
  inline float calories() const;
  inline void set_calories(float value);

  // required float hydration = 3;
  inline bool has_hydration() const;
  inline void clear_hydration();
  static const int kHydrationFieldNumber = 3;
  inline float hydration() const;
  inline void set_hydration(float value);

  // required float heartrate = 4;
  inline bool has_heartrate() const;
  inline void clear_heartrate();
  static const int kHeartrateFieldNumber = 4;
  inline float heartrate() const;
  inline void set_heartrate(float value);

  // required float temperature = 5;
  inline bool has_temperature() const;
  inline void clear_temperature();
  static const int kTemperatureFieldNumber = 5;
  inline float temperature() const;
  inline void set_temperature(float value);

  // required float poison = 6;
  inline bool has_poison() const;
  inline void clear_poison();
  static const int kPoisonFieldNumber = 6;
  inline float poison() const;
  inline void set_poison(float value);

  // required float radiation_level = 7;
  inline bool has_radiation_level() const;
  inline void clear_radiation_level();
  static const int kRadiationLevelFieldNumber = 7;
  inline float radiation_level() const;
  inline void set_radiation_level(float value);

  // required float wetness = 8;
  inline bool has_wetness() const;
  inline void clear_wetness();
  static const int kWetnessFieldNumber = 8;
  inline float wetness() const;
  inline void set_wetness(float value);

  // required float dirtyness = 9;
  inline bool has_dirtyness() const;
  inline void clear_dirtyness();
  static const int kDirtynessFieldNumber = 9;
  inline float dirtyness() const;
  inline void set_dirtyness(float value);

  // required float oxygen = 10;
  inline bool has_oxygen() const;
  inline void clear_oxygen();
  static const int kOxygenFieldNumber = 10;
  inline float oxygen() const;
  inline void set_oxygen(float value);

  // required float bleeding = 11;
  inline bool has_bleeding() const;
  inline void clear_bleeding();
  static const int kBleedingFieldNumber = 11;
  inline float bleeding() const;
  inline void set_bleeding(float value);

  // required float radiation_poisoning = 12;
  inline bool has_radiation_poisoning() const;
  inline void clear_radiation_poisoning();
  static const int kRadiationPoisoningFieldNumber = 12;
  inline float radiation_poisoning() const;
  inline void set_radiation_poisoning(float value);

  // required float comfort = 13;
  inline bool has_comfort() const;
  inline void clear_comfort();
  static const int kComfortFieldNumber = 13;
  inline float comfort() const;
  inline void set_comfort(float value);

  // required float pending_health = 14;
  inline bool has_pending_health() const;
  inline void clear_pending_health();
  static const int kPendingHealthFieldNumber = 14;
  inline float pending_health() const;
  inline void set_pending_health(float value);

  // @@protoc_insertion_point(class_scope:PlayerMetabolism)
 private:
  inline void set_has_health();
  inline void clear_has_health();
  inline void set_has_calories();
  inline void clear_has_calories();
  inline void set_has_hydration();
  inline void clear_has_hydration();
  inline void set_has_heartrate();
  inline void clear_has_heartrate();
  inline void set_has_temperature();
  inline void clear_has_temperature();
  inline void set_has_poison();
  inline void clear_has_poison();
  inline void set_has_radiation_level();
  inline void clear_has_radiation_level();
  inline void set_has_wetness();
  inline void clear_has_wetness();
  inline void set_has_dirtyness();
  inline void clear_has_dirtyness();
  inline void set_has_oxygen();
  inline void clear_has_oxygen();
  inline void set_has_bleeding();
  inline void clear_has_bleeding();
  inline void set_has_radiation_poisoning();
  inline void clear_has_radiation_poisoning();
  inline void set_has_comfort();
  inline void clear_has_comfort();
  inline void set_has_pending_health();
  inline void clear_has_pending_health();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float health_;
  float calories_;
  float hydration_;
  float heartrate_;
  float temperature_;
  float poison_;
  float radiation_level_;
  float wetness_;
  float dirtyness_;
  float oxygen_;
  float bleeding_;
  float radiation_poisoning_;
  float comfort_;
  float pending_health_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static PlayerMetabolism* default_instance_;
};
// -------------------------------------------------------------------

class ModelState : public ::google::protobuf::Message {
 public:
  ModelState();
  virtual ~ModelState();

  ModelState(const ModelState& from);

  inline ModelState& operator=(const ModelState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelState& default_instance();

  void Swap(ModelState* other);

  // implements Message ----------------------------------------------

  ModelState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModelState& from);
  void MergeFrom(const ModelState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float waterLevel = 4;
  inline bool has_waterlevel() const;
  inline void clear_waterlevel();
  static const int kWaterLevelFieldNumber = 4;
  inline float waterlevel() const;
  inline void set_waterlevel(float value);

  // required .Vector3Serialized lookDir = 10;
  inline bool has_lookdir() const;
  inline void clear_lookdir();
  static const int kLookDirFieldNumber = 10;
  inline const ::Vector3Serialized& lookdir() const;
  inline ::Vector3Serialized* mutable_lookdir();
  inline ::Vector3Serialized* release_lookdir();
  inline void set_allocated_lookdir(::Vector3Serialized* lookdir);

  // required uint64 flags = 11;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 11;
  inline ::google::protobuf::uint64 flags() const;
  inline void set_flags(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ModelState)
 private:
  inline void set_has_waterlevel();
  inline void clear_has_waterlevel();
  inline void set_has_lookdir();
  inline void clear_has_lookdir();
  inline void set_has_flags();
  inline void clear_has_flags();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Vector3Serialized* lookdir_;
  ::google::protobuf::uint64 flags_;
  float waterlevel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static ModelState* default_instance_;
};
// -------------------------------------------------------------------

class PersistantPlayer : public ::google::protobuf::Message {
 public:
  PersistantPlayer();
  virtual ~PersistantPlayer();

  PersistantPlayer(const PersistantPlayer& from);

  inline PersistantPlayer& operator=(const PersistantPlayer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PersistantPlayer& default_instance();

  void Swap(PersistantPlayer* other);

  // implements Message ----------------------------------------------

  PersistantPlayer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PersistantPlayer& from);
  void MergeFrom(const PersistantPlayer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 unlockedItems = 3;
  inline int unlockeditems_size() const;
  inline void clear_unlockeditems();
  static const int kUnlockedItemsFieldNumber = 3;
  inline ::google::protobuf::uint64 unlockeditems(int index) const;
  inline void set_unlockeditems(int index, ::google::protobuf::uint64 value);
  inline void add_unlockeditems(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      unlockeditems() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_unlockeditems();

  // required uint64 protocolVersion = 100;
  inline bool has_protocolversion() const;
  inline void clear_protocolversion();
  static const int kProtocolVersionFieldNumber = 100;
  inline ::google::protobuf::uint64 protocolversion() const;
  inline void set_protocolversion(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:PersistantPlayer)
 private:
  inline void set_has_protocolversion();
  inline void clear_has_protocolversion();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > unlockeditems_;
  ::google::protobuf::uint64 protocolversion_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static PersistantPlayer* default_instance_;
};
// -------------------------------------------------------------------

class PlayerLifeStory_DeathInfo : public ::google::protobuf::Message {
 public:
  PlayerLifeStory_DeathInfo();
  virtual ~PlayerLifeStory_DeathInfo();

  PlayerLifeStory_DeathInfo(const PlayerLifeStory_DeathInfo& from);

  inline PlayerLifeStory_DeathInfo& operator=(const PlayerLifeStory_DeathInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerLifeStory_DeathInfo& default_instance();

  void Swap(PlayerLifeStory_DeathInfo* other);

  // implements Message ----------------------------------------------

  PlayerLifeStory_DeathInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerLifeStory_DeathInfo& from);
  void MergeFrom(const PlayerLifeStory_DeathInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string attackerName = 1;
  inline bool has_attackername() const;
  inline void clear_attackername();
  static const int kAttackerNameFieldNumber = 1;
  inline const ::std::string& attackername() const;
  inline void set_attackername(const ::std::string& value);
  inline void set_attackername(const char* value);
  inline void set_attackername(const char* value, size_t size);
  inline ::std::string* mutable_attackername();
  inline ::std::string* release_attackername();
  inline void set_allocated_attackername(::std::string* attackername);

  // required uint64 attackerSteamID = 2;
  inline bool has_attackersteamid() const;
  inline void clear_attackersteamid();
  static const int kAttackerSteamIDFieldNumber = 2;
  inline ::google::protobuf::uint64 attackersteamid() const;
  inline void set_attackersteamid(::google::protobuf::uint64 value);

  // optional string hitBone = 3;
  inline bool has_hitbone() const;
  inline void clear_hitbone();
  static const int kHitBoneFieldNumber = 3;
  inline const ::std::string& hitbone() const;
  inline void set_hitbone(const ::std::string& value);
  inline void set_hitbone(const char* value);
  inline void set_hitbone(const char* value, size_t size);
  inline ::std::string* mutable_hitbone();
  inline ::std::string* release_hitbone();
  inline void set_allocated_hitbone(::std::string* hitbone);

  // optional string inflictorName = 4;
  inline bool has_inflictorname() const;
  inline void clear_inflictorname();
  static const int kInflictorNameFieldNumber = 4;
  inline const ::std::string& inflictorname() const;
  inline void set_inflictorname(const ::std::string& value);
  inline void set_inflictorname(const char* value);
  inline void set_inflictorname(const char* value, size_t size);
  inline ::std::string* mutable_inflictorname();
  inline ::std::string* release_inflictorname();
  inline void set_allocated_inflictorname(::std::string* inflictorname);

  // required uint64 lastDamageType = 5;
  inline bool has_lastdamagetype() const;
  inline void clear_lastdamagetype();
  static const int kLastDamageTypeFieldNumber = 5;
  inline ::google::protobuf::uint64 lastdamagetype() const;
  inline void set_lastdamagetype(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:PlayerLifeStory.DeathInfo)
 private:
  inline void set_has_attackername();
  inline void clear_has_attackername();
  inline void set_has_attackersteamid();
  inline void clear_has_attackersteamid();
  inline void set_has_hitbone();
  inline void clear_has_hitbone();
  inline void set_has_inflictorname();
  inline void clear_has_inflictorname();
  inline void set_has_lastdamagetype();
  inline void clear_has_lastdamagetype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* attackername_;
  ::google::protobuf::uint64 attackersteamid_;
  ::std::string* hitbone_;
  ::std::string* inflictorname_;
  ::google::protobuf::uint64 lastdamagetype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static PlayerLifeStory_DeathInfo* default_instance_;
};
// -------------------------------------------------------------------

class PlayerLifeStory : public ::google::protobuf::Message {
 public:
  PlayerLifeStory();
  virtual ~PlayerLifeStory();

  PlayerLifeStory(const PlayerLifeStory& from);

  inline PlayerLifeStory& operator=(const PlayerLifeStory& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerLifeStory& default_instance();

  void Swap(PlayerLifeStory* other);

  // implements Message ----------------------------------------------

  PlayerLifeStory* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerLifeStory& from);
  void MergeFrom(const PlayerLifeStory& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PlayerLifeStory_DeathInfo DeathInfo;

  // accessors -------------------------------------------------------

  // required float secondsAlive = 100;
  inline bool has_secondsalive() const;
  inline void clear_secondsalive();
  static const int kSecondsAliveFieldNumber = 100;
  inline float secondsalive() const;
  inline void set_secondsalive(float value);

  // required float metersWalked = 101;
  inline bool has_meterswalked() const;
  inline void clear_meterswalked();
  static const int kMetersWalkedFieldNumber = 101;
  inline float meterswalked() const;
  inline void set_meterswalked(float value);

  // required float metersRun = 102;
  inline bool has_metersrun() const;
  inline void clear_metersrun();
  static const int kMetersRunFieldNumber = 102;
  inline float metersrun() const;
  inline void set_metersrun(float value);

  // required float secondsSleeping = 103;
  inline bool has_secondssleeping() const;
  inline void clear_secondssleeping();
  static const int kSecondsSleepingFieldNumber = 103;
  inline float secondssleeping() const;
  inline void set_secondssleeping(float value);

  // required uint32 timeBorn = 104;
  inline bool has_timeborn() const;
  inline void clear_timeborn();
  static const int kTimeBornFieldNumber = 104;
  inline ::google::protobuf::uint32 timeborn() const;
  inline void set_timeborn(::google::protobuf::uint32 value);

  // required uint32 timeDead = 105;
  inline bool has_timedead() const;
  inline void clear_timedead();
  static const int kTimeDeadFieldNumber = 105;
  inline ::google::protobuf::uint32 timedead() const;
  inline void set_timedead(::google::protobuf::uint32 value);

  // optional .PlayerLifeStory.DeathInfo deathInfo = 200;
  inline bool has_deathinfo() const;
  inline void clear_deathinfo();
  static const int kDeathInfoFieldNumber = 200;
  inline const ::PlayerLifeStory_DeathInfo& deathinfo() const;
  inline ::PlayerLifeStory_DeathInfo* mutable_deathinfo();
  inline ::PlayerLifeStory_DeathInfo* release_deathinfo();
  inline void set_allocated_deathinfo(::PlayerLifeStory_DeathInfo* deathinfo);

  // @@protoc_insertion_point(class_scope:PlayerLifeStory)
 private:
  inline void set_has_secondsalive();
  inline void clear_has_secondsalive();
  inline void set_has_meterswalked();
  inline void clear_has_meterswalked();
  inline void set_has_metersrun();
  inline void clear_has_metersrun();
  inline void set_has_secondssleeping();
  inline void clear_has_secondssleeping();
  inline void set_has_timeborn();
  inline void clear_has_timeborn();
  inline void set_has_timedead();
  inline void clear_has_timedead();
  inline void set_has_deathinfo();
  inline void clear_has_deathinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float secondsalive_;
  float meterswalked_;
  float metersrun_;
  float secondssleeping_;
  ::google::protobuf::uint32 timeborn_;
  ::google::protobuf::uint32 timedead_;
  ::PlayerLifeStory_DeathInfo* deathinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static PlayerLifeStory* default_instance_;
};
// -------------------------------------------------------------------

class BasePlayer : public ::google::protobuf::Message {
 public:
  BasePlayer();
  virtual ~BasePlayer();

  BasePlayer(const BasePlayer& from);

  inline BasePlayer& operator=(const BasePlayer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BasePlayer& default_instance();

  void Swap(BasePlayer* other);

  // implements Message ----------------------------------------------

  BasePlayer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BasePlayer& from);
  void MergeFrom(const BasePlayer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required uint64 userid = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);

  // optional .PlayerInventory inventory = 3;
  inline bool has_inventory() const;
  inline void clear_inventory();
  static const int kInventoryFieldNumber = 3;
  inline const ::PlayerInventory& inventory() const;
  inline ::PlayerInventory* mutable_inventory();
  inline ::PlayerInventory* release_inventory();
  inline void set_allocated_inventory(::PlayerInventory* inventory);

  // optional .PlayerMetabolism metabolism = 4;
  inline bool has_metabolism() const;
  inline void clear_metabolism();
  static const int kMetabolismFieldNumber = 4;
  inline const ::PlayerMetabolism& metabolism() const;
  inline ::PlayerMetabolism* mutable_metabolism();
  inline ::PlayerMetabolism* release_metabolism();
  inline void set_allocated_metabolism(::PlayerMetabolism* metabolism);

  // optional .ModelState modelState = 6;
  inline bool has_modelstate() const;
  inline void clear_modelstate();
  static const int kModelStateFieldNumber = 6;
  inline const ::ModelState& modelstate() const;
  inline ::ModelState* mutable_modelstate();
  inline ::ModelState* release_modelstate();
  inline void set_allocated_modelstate(::ModelState* modelstate);

  // required uint64 playerFlags = 7;
  inline bool has_playerflags() const;
  inline void clear_playerflags();
  static const int kPlayerFlagsFieldNumber = 7;
  inline ::google::protobuf::uint64 playerflags() const;
  inline void set_playerflags(::google::protobuf::uint64 value);

  // required uint32 heldEntity = 8;
  inline bool has_heldentity() const;
  inline void clear_heldentity();
  static const int kHeldEntityFieldNumber = 8;
  inline ::google::protobuf::uint32 heldentity() const;
  inline void set_heldentity(::google::protobuf::uint32 value);

  // required float health = 9;
  inline bool has_health() const;
  inline void clear_health();
  static const int kHealthFieldNumber = 9;
  inline float health() const;
  inline void set_health(float value);

  // optional .PersistantPlayer persistantData = 10;
  inline bool has_persistantdata() const;
  inline void clear_persistantdata();
  static const int kPersistantDataFieldNumber = 10;
  inline const ::PersistantPlayer& persistantdata() const;
  inline ::PersistantPlayer* mutable_persistantdata();
  inline ::PersistantPlayer* release_persistantdata();
  inline void set_allocated_persistantdata(::PersistantPlayer* persistantdata);

  // required float skinCol = 15;
  inline bool has_skincol() const;
  inline void clear_skincol();
  static const int kSkinColFieldNumber = 15;
  inline float skincol() const;
  inline void set_skincol(float value);

  // required float skinTex = 16;
  inline bool has_skintex() const;
  inline void clear_skintex();
  static const int kSkinTexFieldNumber = 16;
  inline float skintex() const;
  inline void set_skintex(float value);

  // required float skinMesh = 17;
  inline bool has_skinmesh() const;
  inline void clear_skinmesh();
  static const int kSkinMeshFieldNumber = 17;
  inline float skinmesh() const;
  inline void set_skinmesh(float value);

  // optional .PlayerLifeStory currentLife = 20;
  inline bool has_currentlife() const;
  inline void clear_currentlife();
  static const int kCurrentLifeFieldNumber = 20;
  inline const ::PlayerLifeStory& currentlife() const;
  inline ::PlayerLifeStory* mutable_currentlife();
  inline ::PlayerLifeStory* release_currentlife();
  inline void set_allocated_currentlife(::PlayerLifeStory* currentlife);

  // optional .PlayerLifeStory previousLife = 21;
  inline bool has_previouslife() const;
  inline void clear_previouslife();
  static const int kPreviousLifeFieldNumber = 21;
  inline const ::PlayerLifeStory& previouslife() const;
  inline ::PlayerLifeStory* mutable_previouslife();
  inline ::PlayerLifeStory* release_previouslife();
  inline void set_allocated_previouslife(::PlayerLifeStory* previouslife);

  // @@protoc_insertion_point(class_scope:BasePlayer)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_inventory();
  inline void clear_has_inventory();
  inline void set_has_metabolism();
  inline void clear_has_metabolism();
  inline void set_has_modelstate();
  inline void clear_has_modelstate();
  inline void set_has_playerflags();
  inline void clear_has_playerflags();
  inline void set_has_heldentity();
  inline void clear_has_heldentity();
  inline void set_has_health();
  inline void clear_has_health();
  inline void set_has_persistantdata();
  inline void clear_has_persistantdata();
  inline void set_has_skincol();
  inline void clear_has_skincol();
  inline void set_has_skintex();
  inline void clear_has_skintex();
  inline void set_has_skinmesh();
  inline void clear_has_skinmesh();
  inline void set_has_currentlife();
  inline void clear_has_currentlife();
  inline void set_has_previouslife();
  inline void clear_has_previouslife();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint64 userid_;
  ::PlayerInventory* inventory_;
  ::PlayerMetabolism* metabolism_;
  ::ModelState* modelstate_;
  ::google::protobuf::uint64 playerflags_;
  ::google::protobuf::uint32 heldentity_;
  float health_;
  ::PersistantPlayer* persistantdata_;
  float skincol_;
  float skintex_;
  ::PlayerLifeStory* currentlife_;
  ::PlayerLifeStory* previouslife_;
  float skinmesh_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static BasePlayer* default_instance_;
};
// -------------------------------------------------------------------

class WorldItem : public ::google::protobuf::Message {
 public:
  WorldItem();
  virtual ~WorldItem();

  WorldItem(const WorldItem& from);

  inline WorldItem& operator=(const WorldItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WorldItem& default_instance();

  void Swap(WorldItem* other);

  // implements Message ----------------------------------------------

  WorldItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WorldItem& from);
  void MergeFrom(const WorldItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Item item = 1;
  inline bool has_item() const;
  inline void clear_item();
  static const int kItemFieldNumber = 1;
  inline const ::Item& item() const;
  inline ::Item* mutable_item();
  inline ::Item* release_item();
  inline void set_allocated_item(::Item* item);

  // @@protoc_insertion_point(class_scope:WorldItem)
 private:
  inline void set_has_item();
  inline void clear_has_item();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Item* item_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static WorldItem* default_instance_;
};
// -------------------------------------------------------------------

class BaseResource : public ::google::protobuf::Message {
 public:
  BaseResource();
  virtual ~BaseResource();

  BaseResource(const BaseResource& from);

  inline BaseResource& operator=(const BaseResource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BaseResource& default_instance();

  void Swap(BaseResource* other);

  // implements Message ----------------------------------------------

  BaseResource* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BaseResource& from);
  void MergeFrom(const BaseResource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 stage = 1;
  inline bool has_stage() const;
  inline void clear_stage();
  static const int kStageFieldNumber = 1;
  inline ::google::protobuf::uint64 stage() const;
  inline void set_stage(::google::protobuf::uint64 value);

  // required float health = 2;
  inline bool has_health() const;
  inline void clear_health();
  static const int kHealthFieldNumber = 2;
  inline float health() const;
  inline void set_health(float value);

  // @@protoc_insertion_point(class_scope:BaseResource)
 private:
  inline void set_has_stage();
  inline void clear_has_stage();
  inline void set_has_health();
  inline void clear_has_health();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 stage_;
  float health_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static BaseResource* default_instance_;
};
// -------------------------------------------------------------------

class BuildingBlock : public ::google::protobuf::Message {
 public:
  BuildingBlock();
  virtual ~BuildingBlock();

  BuildingBlock(const BuildingBlock& from);

  inline BuildingBlock& operator=(const BuildingBlock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuildingBlock& default_instance();

  void Swap(BuildingBlock* other);

  // implements Message ----------------------------------------------

  BuildingBlock* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuildingBlock& from);
  void MergeFrom(const BuildingBlock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 grade = 2;
  inline bool has_grade() const;
  inline void clear_grade();
  static const int kGradeFieldNumber = 2;
  inline ::google::protobuf::uint64 grade() const;
  inline void set_grade(::google::protobuf::uint64 value);

  // required bool beingDemolished = 3;
  inline bool has_beingdemolished() const;
  inline void clear_beingdemolished();
  static const int kBeingDemolishedFieldNumber = 3;
  inline bool beingdemolished() const;
  inline void set_beingdemolished(bool value);

  // required float stability = 4;
  inline bool has_stability() const;
  inline void clear_stability();
  static const int kStabilityFieldNumber = 4;
  inline float stability() const;
  inline void set_stability(float value);

  // required uint32 buildingID = 5;
  inline bool has_buildingid() const;
  inline void clear_buildingid();
  static const int kBuildingIDFieldNumber = 5;
  inline ::google::protobuf::uint32 buildingid() const;
  inline void set_buildingid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:BuildingBlock)
 private:
  inline void set_has_grade();
  inline void clear_has_grade();
  inline void set_has_beingdemolished();
  inline void clear_has_beingdemolished();
  inline void set_has_stability();
  inline void clear_has_stability();
  inline void set_has_buildingid();
  inline void clear_has_buildingid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 grade_;
  bool beingdemolished_;
  float stability_;
  ::google::protobuf::uint32 buildingid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static BuildingBlock* default_instance_;
};
// -------------------------------------------------------------------

class Environment : public ::google::protobuf::Message {
 public:
  Environment();
  virtual ~Environment();

  Environment(const Environment& from);

  inline Environment& operator=(const Environment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Environment& default_instance();

  void Swap(Environment* other);

  // implements Message ----------------------------------------------

  Environment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Environment& from);
  void MergeFrom(const Environment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 dateTime = 1;
  inline bool has_datetime() const;
  inline void clear_datetime();
  static const int kDateTimeFieldNumber = 1;
  inline ::google::protobuf::uint64 datetime() const;
  inline void set_datetime(::google::protobuf::uint64 value);

  // required float clouds = 2;
  inline bool has_clouds() const;
  inline void clear_clouds();
  static const int kCloudsFieldNumber = 2;
  inline float clouds() const;
  inline void set_clouds(float value);

  // required float fog = 3;
  inline bool has_fog() const;
  inline void clear_fog();
  static const int kFogFieldNumber = 3;
  inline float fog() const;
  inline void set_fog(float value);

  // required float wind = 4;
  inline bool has_wind() const;
  inline void clear_wind();
  static const int kWindFieldNumber = 4;
  inline float wind() const;
  inline void set_wind(float value);

  // required float rain = 5;
  inline bool has_rain() const;
  inline void clear_rain();
  static const int kRainFieldNumber = 5;
  inline float rain() const;
  inline void set_rain(float value);

  // @@protoc_insertion_point(class_scope:Environment)
 private:
  inline void set_has_datetime();
  inline void clear_has_datetime();
  inline void set_has_clouds();
  inline void clear_has_clouds();
  inline void set_has_fog();
  inline void clear_has_fog();
  inline void set_has_wind();
  inline void clear_has_wind();
  inline void set_has_rain();
  inline void clear_has_rain();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 datetime_;
  float clouds_;
  float fog_;
  float wind_;
  float rain_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static Environment* default_instance_;
};
// -------------------------------------------------------------------

class Corpse : public ::google::protobuf::Message {
 public:
  Corpse();
  virtual ~Corpse();

  Corpse(const Corpse& from);

  inline Corpse& operator=(const Corpse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Corpse& default_instance();

  void Swap(Corpse* other);

  // implements Message ----------------------------------------------

  Corpse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Corpse& from);
  void MergeFrom(const Corpse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 parentID = 1;
  inline bool has_parentid() const;
  inline void clear_parentid();
  static const int kParentIDFieldNumber = 1;
  inline ::google::protobuf::uint32 parentid() const;
  inline void set_parentid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Corpse)
 private:
  inline void set_has_parentid();
  inline void clear_has_parentid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 parentid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static Corpse* default_instance_;
};
// -------------------------------------------------------------------

class ParentInfo : public ::google::protobuf::Message {
 public:
  ParentInfo();
  virtual ~ParentInfo();

  ParentInfo(const ParentInfo& from);

  inline ParentInfo& operator=(const ParentInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParentInfo& default_instance();

  void Swap(ParentInfo* other);

  // implements Message ----------------------------------------------

  ParentInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ParentInfo& from);
  void MergeFrom(const ParentInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint32 uid() const;
  inline void set_uid(::google::protobuf::uint32 value);

  // required uint32 bone = 2;
  inline bool has_bone() const;
  inline void clear_bone();
  static const int kBoneFieldNumber = 2;
  inline ::google::protobuf::uint32 bone() const;
  inline void set_bone(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ParentInfo)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_bone();
  inline void clear_has_bone();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 uid_;
  ::google::protobuf::uint32 bone_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static ParentInfo* default_instance_;
};
// -------------------------------------------------------------------

class KeyLock : public ::google::protobuf::Message {
 public:
  KeyLock();
  virtual ~KeyLock();

  KeyLock(const KeyLock& from);

  inline KeyLock& operator=(const KeyLock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyLock& default_instance();

  void Swap(KeyLock* other);

  // implements Message ----------------------------------------------

  KeyLock* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeyLock& from);
  void MergeFrom(const KeyLock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::uint64 code() const;
  inline void set_code(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:KeyLock)
 private:
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static KeyLock* default_instance_;
};
// -------------------------------------------------------------------

class CodeLock_Private : public ::google::protobuf::Message {
 public:
  CodeLock_Private();
  virtual ~CodeLock_Private();

  CodeLock_Private(const CodeLock_Private& from);

  inline CodeLock_Private& operator=(const CodeLock_Private& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CodeLock_Private& default_instance();

  void Swap(CodeLock_Private* other);

  // implements Message ----------------------------------------------

  CodeLock_Private* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CodeLock_Private& from);
  void MergeFrom(const CodeLock_Private& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline const ::std::string& code() const;
  inline void set_code(const ::std::string& value);
  inline void set_code(const char* value);
  inline void set_code(const char* value, size_t size);
  inline ::std::string* mutable_code();
  inline ::std::string* release_code();
  inline void set_allocated_code(::std::string* code);

  // repeated uint64 users = 2;
  inline int users_size() const;
  inline void clear_users();
  static const int kUsersFieldNumber = 2;
  inline ::google::protobuf::uint64 users(int index) const;
  inline void set_users(int index, ::google::protobuf::uint64 value);
  inline void add_users(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      users() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_users();

  // repeated uint64 guests = 3;
  inline int guests_size() const;
  inline void clear_guests();
  static const int kGuestsFieldNumber = 3;
  inline ::google::protobuf::uint64 guests(int index) const;
  inline void set_guests(int index, ::google::protobuf::uint64 value);
  inline void add_guests(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      guests() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_guests();

  // optional string guestCode = 4;
  inline bool has_guestcode() const;
  inline void clear_guestcode();
  static const int kGuestCodeFieldNumber = 4;
  inline const ::std::string& guestcode() const;
  inline void set_guestcode(const ::std::string& value);
  inline void set_guestcode(const char* value);
  inline void set_guestcode(const char* value, size_t size);
  inline ::std::string* mutable_guestcode();
  inline ::std::string* release_guestcode();
  inline void set_allocated_guestcode(::std::string* guestcode);

  // repeated uint64 guestUsers = 5;
  inline int guestusers_size() const;
  inline void clear_guestusers();
  static const int kGuestUsersFieldNumber = 5;
  inline ::google::protobuf::uint64 guestusers(int index) const;
  inline void set_guestusers(int index, ::google::protobuf::uint64 value);
  inline void add_guestusers(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      guestusers() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_guestusers();

  // @@protoc_insertion_point(class_scope:CodeLock.Private)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_guestcode();
  inline void clear_has_guestcode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* code_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > users_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > guests_;
  ::std::string* guestcode_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > guestusers_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static CodeLock_Private* default_instance_;
};
// -------------------------------------------------------------------

class CodeLock : public ::google::protobuf::Message {
 public:
  CodeLock();
  virtual ~CodeLock();

  CodeLock(const CodeLock& from);

  inline CodeLock& operator=(const CodeLock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CodeLock& default_instance();

  void Swap(CodeLock* other);

  // implements Message ----------------------------------------------

  CodeLock* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CodeLock& from);
  void MergeFrom(const CodeLock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CodeLock_Private Private;

  // accessors -------------------------------------------------------

  // optional .CodeLock.Private pv = 1;
  inline bool has_pv() const;
  inline void clear_pv();
  static const int kPvFieldNumber = 1;
  inline const ::CodeLock_Private& pv() const;
  inline ::CodeLock_Private* mutable_pv();
  inline ::CodeLock_Private* release_pv();
  inline void set_allocated_pv(::CodeLock_Private* pv);

  // required bool hasCode = 2;
  inline bool has_hascode() const;
  inline void clear_hascode();
  static const int kHasCodeFieldNumber = 2;
  inline bool hascode() const;
  inline void set_hascode(bool value);

  // required bool hasGuestCode = 3;
  inline bool has_hasguestcode() const;
  inline void clear_hasguestcode();
  static const int kHasGuestCodeFieldNumber = 3;
  inline bool hasguestcode() const;
  inline void set_hasguestcode(bool value);

  // @@protoc_insertion_point(class_scope:CodeLock)
 private:
  inline void set_has_pv();
  inline void clear_has_pv();
  inline void set_has_hascode();
  inline void clear_has_hascode();
  inline void set_has_hasguestcode();
  inline void clear_has_hasguestcode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::CodeLock_Private* pv_;
  bool hascode_;
  bool hasguestcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static CodeLock* default_instance_;
};
// -------------------------------------------------------------------

class EntitySlots : public ::google::protobuf::Message {
 public:
  EntitySlots();
  virtual ~EntitySlots();

  EntitySlots(const EntitySlots& from);

  inline EntitySlots& operator=(const EntitySlots& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EntitySlots& default_instance();

  void Swap(EntitySlots* other);

  // implements Message ----------------------------------------------

  EntitySlots* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EntitySlots& from);
  void MergeFrom(const EntitySlots& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 slotLock = 1;
  inline bool has_slotlock() const;
  inline void clear_slotlock();
  static const int kSlotLockFieldNumber = 1;
  inline ::google::protobuf::uint32 slotlock() const;
  inline void set_slotlock(::google::protobuf::uint32 value);

  // required uint32 slotFireMod = 2;
  inline bool has_slotfiremod() const;
  inline void clear_slotfiremod();
  static const int kSlotFireModFieldNumber = 2;
  inline ::google::protobuf::uint32 slotfiremod() const;
  inline void set_slotfiremod(::google::protobuf::uint32 value);

  // required uint32 slotUpperModification = 3;
  inline bool has_slotuppermodification() const;
  inline void clear_slotuppermodification();
  static const int kSlotUpperModificationFieldNumber = 3;
  inline ::google::protobuf::uint32 slotuppermodification() const;
  inline void set_slotuppermodification(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:EntitySlots)
 private:
  inline void set_has_slotlock();
  inline void clear_has_slotlock();
  inline void set_has_slotfiremod();
  inline void clear_has_slotfiremod();
  inline void set_has_slotuppermodification();
  inline void clear_has_slotuppermodification();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 slotlock_;
  ::google::protobuf::uint32 slotfiremod_;
  ::google::protobuf::uint32 slotuppermodification_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static EntitySlots* default_instance_;
};
// -------------------------------------------------------------------

class PlayerNameID : public ::google::protobuf::Message {
 public:
  PlayerNameID();
  virtual ~PlayerNameID();

  PlayerNameID(const PlayerNameID& from);

  inline PlayerNameID& operator=(const PlayerNameID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerNameID& default_instance();

  void Swap(PlayerNameID* other);

  // implements Message ----------------------------------------------

  PlayerNameID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerNameID& from);
  void MergeFrom(const PlayerNameID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // required uint64 userid = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:PlayerNameID)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_userid();
  inline void clear_has_userid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::google::protobuf::uint64 userid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static PlayerNameID* default_instance_;
};
// -------------------------------------------------------------------

class BuildingPrivilege : public ::google::protobuf::Message {
 public:
  BuildingPrivilege();
  virtual ~BuildingPrivilege();

  BuildingPrivilege(const BuildingPrivilege& from);

  inline BuildingPrivilege& operator=(const BuildingPrivilege& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuildingPrivilege& default_instance();

  void Swap(BuildingPrivilege* other);

  // implements Message ----------------------------------------------

  BuildingPrivilege* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuildingPrivilege& from);
  void MergeFrom(const BuildingPrivilege& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PlayerNameID users = 1;
  inline int users_size() const;
  inline void clear_users();
  static const int kUsersFieldNumber = 1;
  inline const ::PlayerNameID& users(int index) const;
  inline ::PlayerNameID* mutable_users(int index);
  inline ::PlayerNameID* add_users();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerNameID >&
      users() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerNameID >*
      mutable_users();

  // @@protoc_insertion_point(class_scope:BuildingPrivilege)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::PlayerNameID > users_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static BuildingPrivilege* default_instance_;
};
// -------------------------------------------------------------------

class StorageBox : public ::google::protobuf::Message {
 public:
  StorageBox();
  virtual ~StorageBox();

  StorageBox(const StorageBox& from);

  inline StorageBox& operator=(const StorageBox& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StorageBox& default_instance();

  void Swap(StorageBox* other);

  // implements Message ----------------------------------------------

  StorageBox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StorageBox& from);
  void MergeFrom(const StorageBox& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ItemContainer contents = 1;
  inline bool has_contents() const;
  inline void clear_contents();
  static const int kContentsFieldNumber = 1;
  inline const ::ItemContainer& contents() const;
  inline ::ItemContainer* mutable_contents();
  inline ::ItemContainer* release_contents();
  inline void set_allocated_contents(::ItemContainer* contents);

  // @@protoc_insertion_point(class_scope:StorageBox)
 private:
  inline void set_has_contents();
  inline void clear_has_contents();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ItemContainer* contents_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static StorageBox* default_instance_;
};
// -------------------------------------------------------------------

class HeldEntity : public ::google::protobuf::Message {
 public:
  HeldEntity();
  virtual ~HeldEntity();

  HeldEntity(const HeldEntity& from);

  inline HeldEntity& operator=(const HeldEntity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeldEntity& default_instance();

  void Swap(HeldEntity* other);

  // implements Message ----------------------------------------------

  HeldEntity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeldEntity& from);
  void MergeFrom(const HeldEntity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 itemUID = 1;
  inline bool has_itemuid() const;
  inline void clear_itemuid();
  static const int kItemUIDFieldNumber = 1;
  inline ::google::protobuf::uint32 itemuid() const;
  inline void set_itemuid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:HeldEntity)
 private:
  inline void set_has_itemuid();
  inline void clear_has_itemuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 itemuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static HeldEntity* default_instance_;
};
// -------------------------------------------------------------------

class Magazine : public ::google::protobuf::Message {
 public:
  Magazine();
  virtual ~Magazine();

  Magazine(const Magazine& from);

  inline Magazine& operator=(const Magazine& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Magazine& default_instance();

  void Swap(Magazine* other);

  // implements Message ----------------------------------------------

  Magazine* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Magazine& from);
  void MergeFrom(const Magazine& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 capacity = 1;
  inline bool has_capacity() const;
  inline void clear_capacity();
  static const int kCapacityFieldNumber = 1;
  inline ::google::protobuf::uint64 capacity() const;
  inline void set_capacity(::google::protobuf::uint64 value);

  // required uint64 contents = 2;
  inline bool has_contents() const;
  inline void clear_contents();
  static const int kContentsFieldNumber = 2;
  inline ::google::protobuf::uint64 contents() const;
  inline void set_contents(::google::protobuf::uint64 value);

  // required uint64 ammoType = 3;
  inline bool has_ammotype() const;
  inline void clear_ammotype();
  static const int kAmmoTypeFieldNumber = 3;
  inline ::google::protobuf::uint64 ammotype() const;
  inline void set_ammotype(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Magazine)
 private:
  inline void set_has_capacity();
  inline void clear_has_capacity();
  inline void set_has_contents();
  inline void clear_has_contents();
  inline void set_has_ammotype();
  inline void clear_has_ammotype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 capacity_;
  ::google::protobuf::uint64 contents_;
  ::google::protobuf::uint64 ammotype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static Magazine* default_instance_;
};
// -------------------------------------------------------------------

class BaseProjectile : public ::google::protobuf::Message {
 public:
  BaseProjectile();
  virtual ~BaseProjectile();

  BaseProjectile(const BaseProjectile& from);

  inline BaseProjectile& operator=(const BaseProjectile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BaseProjectile& default_instance();

  void Swap(BaseProjectile* other);

  // implements Message ----------------------------------------------

  BaseProjectile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BaseProjectile& from);
  void MergeFrom(const BaseProjectile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Magazine primaryMagazine = 1;
  inline bool has_primarymagazine() const;
  inline void clear_primarymagazine();
  static const int kPrimaryMagazineFieldNumber = 1;
  inline const ::Magazine& primarymagazine() const;
  inline ::Magazine* mutable_primarymagazine();
  inline ::Magazine* release_primarymagazine();
  inline void set_allocated_primarymagazine(::Magazine* primarymagazine);

  // @@protoc_insertion_point(class_scope:BaseProjectile)
 private:
  inline void set_has_primarymagazine();
  inline void clear_has_primarymagazine();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Magazine* primarymagazine_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static BaseProjectile* default_instance_;
};
// -------------------------------------------------------------------

class BaseNPC : public ::google::protobuf::Message {
 public:
  BaseNPC();
  virtual ~BaseNPC();

  BaseNPC(const BaseNPC& from);

  inline BaseNPC& operator=(const BaseNPC& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BaseNPC& default_instance();

  void Swap(BaseNPC* other);

  // implements Message ----------------------------------------------

  BaseNPC* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BaseNPC& from);
  void MergeFrom(const BaseNPC& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 flags = 2;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 2;
  inline ::google::protobuf::uint64 flags() const;
  inline void set_flags(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:BaseNPC)
 private:
  inline void set_has_flags();
  inline void clear_has_flags();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 flags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static BaseNPC* default_instance_;
};
// -------------------------------------------------------------------

class Loot : public ::google::protobuf::Message {
 public:
  Loot();
  virtual ~Loot();

  Loot(const Loot& from);

  inline Loot& operator=(const Loot& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Loot& default_instance();

  void Swap(Loot* other);

  // implements Message ----------------------------------------------

  Loot* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Loot& from);
  void MergeFrom(const Loot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ItemContainer contents = 1;
  inline bool has_contents() const;
  inline void clear_contents();
  static const int kContentsFieldNumber = 1;
  inline const ::ItemContainer& contents() const;
  inline ::ItemContainer* mutable_contents();
  inline ::ItemContainer* release_contents();
  inline void set_allocated_contents(::ItemContainer* contents);

  // @@protoc_insertion_point(class_scope:Loot)
 private:
  inline void set_has_contents();
  inline void clear_has_contents();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ItemContainer* contents_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static Loot* default_instance_;
};
// -------------------------------------------------------------------

class GenericSpawner_SpawnedEnt : public ::google::protobuf::Message {
 public:
  GenericSpawner_SpawnedEnt();
  virtual ~GenericSpawner_SpawnedEnt();

  GenericSpawner_SpawnedEnt(const GenericSpawner_SpawnedEnt& from);

  inline GenericSpawner_SpawnedEnt& operator=(const GenericSpawner_SpawnedEnt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GenericSpawner_SpawnedEnt& default_instance();

  void Swap(GenericSpawner_SpawnedEnt* other);

  // implements Message ----------------------------------------------

  GenericSpawner_SpawnedEnt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GenericSpawner_SpawnedEnt& from);
  void MergeFrom(const GenericSpawner_SpawnedEnt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint32 uid() const;
  inline void set_uid(::google::protobuf::uint32 value);

  // required uint32 spawnPointIndex = 2;
  inline bool has_spawnpointindex() const;
  inline void clear_spawnpointindex();
  static const int kSpawnPointIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 spawnpointindex() const;
  inline void set_spawnpointindex(::google::protobuf::uint32 value);

  // required bool mobile = 3;
  inline bool has_mobile() const;
  inline void clear_mobile();
  static const int kMobileFieldNumber = 3;
  inline bool mobile() const;
  inline void set_mobile(bool value);

  // @@protoc_insertion_point(class_scope:GenericSpawner.SpawnedEnt)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_spawnpointindex();
  inline void clear_has_spawnpointindex();
  inline void set_has_mobile();
  inline void clear_has_mobile();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 uid_;
  ::google::protobuf::uint32 spawnpointindex_;
  bool mobile_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static GenericSpawner_SpawnedEnt* default_instance_;
};
// -------------------------------------------------------------------

class GenericSpawner : public ::google::protobuf::Message {
 public:
  GenericSpawner();
  virtual ~GenericSpawner();

  GenericSpawner(const GenericSpawner& from);

  inline GenericSpawner& operator=(const GenericSpawner& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GenericSpawner& default_instance();

  void Swap(GenericSpawner* other);

  // implements Message ----------------------------------------------

  GenericSpawner* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GenericSpawner& from);
  void MergeFrom(const GenericSpawner& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GenericSpawner_SpawnedEnt SpawnedEnt;

  // accessors -------------------------------------------------------

  // repeated .GenericSpawner.SpawnedEnt ents = 1;
  inline int ents_size() const;
  inline void clear_ents();
  static const int kEntsFieldNumber = 1;
  inline const ::GenericSpawner_SpawnedEnt& ents(int index) const;
  inline ::GenericSpawner_SpawnedEnt* mutable_ents(int index);
  inline ::GenericSpawner_SpawnedEnt* add_ents();
  inline const ::google::protobuf::RepeatedPtrField< ::GenericSpawner_SpawnedEnt >&
      ents() const;
  inline ::google::protobuf::RepeatedPtrField< ::GenericSpawner_SpawnedEnt >*
      mutable_ents();

  // @@protoc_insertion_point(class_scope:GenericSpawner)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::GenericSpawner_SpawnedEnt > ents_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static GenericSpawner* default_instance_;
};
// -------------------------------------------------------------------

class SleepingBag_Private : public ::google::protobuf::Message {
 public:
  SleepingBag_Private();
  virtual ~SleepingBag_Private();

  SleepingBag_Private(const SleepingBag_Private& from);

  inline SleepingBag_Private& operator=(const SleepingBag_Private& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SleepingBag_Private& default_instance();

  void Swap(SleepingBag_Private* other);

  // implements Message ----------------------------------------------

  SleepingBag_Private* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SleepingBag_Private& from);
  void MergeFrom(const SleepingBag_Private& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 deployerID = 1;
  inline bool has_deployerid() const;
  inline void clear_deployerid();
  static const int kDeployerIDFieldNumber = 1;
  inline ::google::protobuf::uint64 deployerid() const;
  inline void set_deployerid(::google::protobuf::uint64 value);

  // optional string deployerName = 2;
  inline bool has_deployername() const;
  inline void clear_deployername();
  static const int kDeployerNameFieldNumber = 2;
  inline const ::std::string& deployername() const;
  inline void set_deployername(const ::std::string& value);
  inline void set_deployername(const char* value);
  inline void set_deployername(const char* value, size_t size);
  inline ::std::string* mutable_deployername();
  inline ::std::string* release_deployername();
  inline void set_allocated_deployername(::std::string* deployername);

  // @@protoc_insertion_point(class_scope:SleepingBag.Private)
 private:
  inline void set_has_deployerid();
  inline void clear_has_deployerid();
  inline void set_has_deployername();
  inline void clear_has_deployername();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 deployerid_;
  ::std::string* deployername_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static SleepingBag_Private* default_instance_;
};
// -------------------------------------------------------------------

class SleepingBag : public ::google::protobuf::Message {
 public:
  SleepingBag();
  virtual ~SleepingBag();

  SleepingBag(const SleepingBag& from);

  inline SleepingBag& operator=(const SleepingBag& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SleepingBag& default_instance();

  void Swap(SleepingBag* other);

  // implements Message ----------------------------------------------

  SleepingBag* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SleepingBag& from);
  void MergeFrom(const SleepingBag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SleepingBag_Private Private;

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .SleepingBag.Private privateData = 2;
  inline bool has_privatedata() const;
  inline void clear_privatedata();
  static const int kPrivateDataFieldNumber = 2;
  inline const ::SleepingBag_Private& privatedata() const;
  inline ::SleepingBag_Private* mutable_privatedata();
  inline ::SleepingBag_Private* release_privatedata();
  inline void set_allocated_privatedata(::SleepingBag_Private* privatedata);

  // required uint64 deployerID = 3;
  inline bool has_deployerid() const;
  inline void clear_deployerid();
  static const int kDeployerIDFieldNumber = 3;
  inline ::google::protobuf::uint64 deployerid() const;
  inline void set_deployerid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:SleepingBag)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_privatedata();
  inline void clear_has_privatedata();
  inline void set_has_deployerid();
  inline void clear_has_deployerid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::SleepingBag_Private* privatedata_;
  ::google::protobuf::uint64 deployerid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static SleepingBag* default_instance_;
};
// -------------------------------------------------------------------

class LootableCorpse_Private : public ::google::protobuf::Message {
 public:
  LootableCorpse_Private();
  virtual ~LootableCorpse_Private();

  LootableCorpse_Private(const LootableCorpse_Private& from);

  inline LootableCorpse_Private& operator=(const LootableCorpse_Private& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LootableCorpse_Private& default_instance();

  void Swap(LootableCorpse_Private* other);

  // implements Message ----------------------------------------------

  LootableCorpse_Private* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LootableCorpse_Private& from);
  void MergeFrom(const LootableCorpse_Private& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ItemContainer container = 1;
  inline int container_size() const;
  inline void clear_container();
  static const int kContainerFieldNumber = 1;
  inline const ::ItemContainer& container(int index) const;
  inline ::ItemContainer* mutable_container(int index);
  inline ::ItemContainer* add_container();
  inline const ::google::protobuf::RepeatedPtrField< ::ItemContainer >&
      container() const;
  inline ::google::protobuf::RepeatedPtrField< ::ItemContainer >*
      mutable_container();

  // @@protoc_insertion_point(class_scope:LootableCorpse.Private)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::ItemContainer > container_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static LootableCorpse_Private* default_instance_;
};
// -------------------------------------------------------------------

class LootableCorpse : public ::google::protobuf::Message {
 public:
  LootableCorpse();
  virtual ~LootableCorpse();

  LootableCorpse(const LootableCorpse& from);

  inline LootableCorpse& operator=(const LootableCorpse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LootableCorpse& default_instance();

  void Swap(LootableCorpse* other);

  // implements Message ----------------------------------------------

  LootableCorpse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LootableCorpse& from);
  void MergeFrom(const LootableCorpse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef LootableCorpse_Private Private;

  // accessors -------------------------------------------------------

  // optional .LootableCorpse.Private privateData = 1;
  inline bool has_privatedata() const;
  inline void clear_privatedata();
  static const int kPrivateDataFieldNumber = 1;
  inline const ::LootableCorpse_Private& privatedata() const;
  inline ::LootableCorpse_Private* mutable_privatedata();
  inline ::LootableCorpse_Private* release_privatedata();
  inline void set_allocated_privatedata(::LootableCorpse_Private* privatedata);

  // required uint64 playerID = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 2;
  inline ::google::protobuf::uint64 playerid() const;
  inline void set_playerid(::google::protobuf::uint64 value);

  // optional string playerName = 3;
  inline bool has_playername() const;
  inline void clear_playername();
  static const int kPlayerNameFieldNumber = 3;
  inline const ::std::string& playername() const;
  inline void set_playername(const ::std::string& value);
  inline void set_playername(const char* value);
  inline void set_playername(const char* value, size_t size);
  inline ::std::string* mutable_playername();
  inline ::std::string* release_playername();
  inline void set_allocated_playername(::std::string* playername);

  // @@protoc_insertion_point(class_scope:LootableCorpse)
 private:
  inline void set_has_privatedata();
  inline void clear_has_privatedata();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_playername();
  inline void clear_has_playername();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::LootableCorpse_Private* privatedata_;
  ::google::protobuf::uint64 playerid_;
  ::std::string* playername_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static LootableCorpse* default_instance_;
};
// -------------------------------------------------------------------

class Sign : public ::google::protobuf::Message {
 public:
  Sign();
  virtual ~Sign();

  Sign(const Sign& from);

  inline Sign& operator=(const Sign& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sign& default_instance();

  void Swap(Sign* other);

  // implements Message ----------------------------------------------

  Sign* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sign& from);
  void MergeFrom(const Sign& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 imageid = 3;
  inline bool has_imageid() const;
  inline void clear_imageid();
  static const int kImageidFieldNumber = 3;
  inline ::google::protobuf::uint32 imageid() const;
  inline void set_imageid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Sign)
 private:
  inline void set_has_imageid();
  inline void clear_has_imageid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 imageid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static Sign* default_instance_;
};
// -------------------------------------------------------------------

class BaseCombat : public ::google::protobuf::Message {
 public:
  BaseCombat();
  virtual ~BaseCombat();

  BaseCombat(const BaseCombat& from);

  inline BaseCombat& operator=(const BaseCombat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BaseCombat& default_instance();

  void Swap(BaseCombat* other);

  // implements Message ----------------------------------------------

  BaseCombat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BaseCombat& from);
  void MergeFrom(const BaseCombat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::uint64 state() const;
  inline void set_state(::google::protobuf::uint64 value);

  // required float health = 2;
  inline bool has_health() const;
  inline void clear_health();
  static const int kHealthFieldNumber = 2;
  inline float health() const;
  inline void set_health(float value);

  // @@protoc_insertion_point(class_scope:BaseCombat)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_health();
  inline void clear_has_health();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 state_;
  float health_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static BaseCombat* default_instance_;
};
// -------------------------------------------------------------------

class MapEntity : public ::google::protobuf::Message {
 public:
  MapEntity();
  virtual ~MapEntity();

  MapEntity(const MapEntity& from);

  inline MapEntity& operator=(const MapEntity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapEntity& default_instance();

  void Swap(MapEntity* other);

  // implements Message ----------------------------------------------

  MapEntity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapEntity& from);
  void MergeFrom(const MapEntity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 fogImages = 1;
  inline int fogimages_size() const;
  inline void clear_fogimages();
  static const int kFogImagesFieldNumber = 1;
  inline ::google::protobuf::uint32 fogimages(int index) const;
  inline void set_fogimages(int index, ::google::protobuf::uint32 value);
  inline void add_fogimages(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      fogimages() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_fogimages();

  // repeated uint32 paintImages = 2;
  inline int paintimages_size() const;
  inline void clear_paintimages();
  static const int kPaintImagesFieldNumber = 2;
  inline ::google::protobuf::uint32 paintimages(int index) const;
  inline void set_paintimages(int index, ::google::protobuf::uint32 value);
  inline void add_paintimages(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      paintimages() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_paintimages();

  // @@protoc_insertion_point(class_scope:MapEntity)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > fogimages_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > paintimages_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static MapEntity* default_instance_;
};
// -------------------------------------------------------------------

class ResearchTable : public ::google::protobuf::Message {
 public:
  ResearchTable();
  virtual ~ResearchTable();

  ResearchTable(const ResearchTable& from);

  inline ResearchTable& operator=(const ResearchTable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResearchTable& default_instance();

  void Swap(ResearchTable* other);

  // implements Message ----------------------------------------------

  ResearchTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResearchTable& from);
  void MergeFrom(const ResearchTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float researchTimeLeft = 1;
  inline bool has_researchtimeleft() const;
  inline void clear_researchtimeleft();
  static const int kResearchTimeLeftFieldNumber = 1;
  inline float researchtimeleft() const;
  inline void set_researchtimeleft(float value);

  // @@protoc_insertion_point(class_scope:ResearchTable)
 private:
  inline void set_has_researchtimeleft();
  inline void clear_has_researchtimeleft();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float researchtimeleft_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static ResearchTable* default_instance_;
};
// -------------------------------------------------------------------

class DudExplosive : public ::google::protobuf::Message {
 public:
  DudExplosive();
  virtual ~DudExplosive();

  DudExplosive(const DudExplosive& from);

  inline DudExplosive& operator=(const DudExplosive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DudExplosive& default_instance();

  void Swap(DudExplosive* other);

  // implements Message ----------------------------------------------

  DudExplosive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DudExplosive& from);
  void MergeFrom(const DudExplosive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float fuseTimeLeft = 1;
  inline bool has_fusetimeleft() const;
  inline void clear_fusetimeleft();
  static const int kFuseTimeLeftFieldNumber = 1;
  inline float fusetimeleft() const;
  inline void set_fusetimeleft(float value);

  // @@protoc_insertion_point(class_scope:DudExplosive)
 private:
  inline void set_has_fusetimeleft();
  inline void clear_has_fusetimeleft();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float fusetimeleft_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static DudExplosive* default_instance_;
};
// -------------------------------------------------------------------

class ResourceExtractor : public ::google::protobuf::Message {
 public:
  ResourceExtractor();
  virtual ~ResourceExtractor();

  ResourceExtractor(const ResourceExtractor& from);

  inline ResourceExtractor& operator=(const ResourceExtractor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceExtractor& default_instance();

  void Swap(ResourceExtractor* other);

  // implements Message ----------------------------------------------

  ResourceExtractor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceExtractor& from);
  void MergeFrom(const ResourceExtractor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ItemContainer fuelContents = 1;
  inline bool has_fuelcontents() const;
  inline void clear_fuelcontents();
  static const int kFuelContentsFieldNumber = 1;
  inline const ::ItemContainer& fuelcontents() const;
  inline ::ItemContainer* mutable_fuelcontents();
  inline ::ItemContainer* release_fuelcontents();
  inline void set_allocated_fuelcontents(::ItemContainer* fuelcontents);

  // optional .ItemContainer outputContents = 2;
  inline bool has_outputcontents() const;
  inline void clear_outputcontents();
  static const int kOutputContentsFieldNumber = 2;
  inline const ::ItemContainer& outputcontents() const;
  inline ::ItemContainer* mutable_outputcontents();
  inline ::ItemContainer* release_outputcontents();
  inline void set_allocated_outputcontents(::ItemContainer* outputcontents);

  // @@protoc_insertion_point(class_scope:ResourceExtractor)
 private:
  inline void set_has_fuelcontents();
  inline void clear_has_fuelcontents();
  inline void set_has_outputcontents();
  inline void clear_has_outputcontents();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ItemContainer* fuelcontents_;
  ::ItemContainer* outputcontents_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static ResourceExtractor* default_instance_;
};
// -------------------------------------------------------------------

class MiningQuarry : public ::google::protobuf::Message {
 public:
  MiningQuarry();
  virtual ~MiningQuarry();

  MiningQuarry(const MiningQuarry& from);

  inline MiningQuarry& operator=(const MiningQuarry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MiningQuarry& default_instance();

  void Swap(MiningQuarry* other);

  // implements Message ----------------------------------------------

  MiningQuarry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MiningQuarry& from);
  void MergeFrom(const MiningQuarry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ResourceExtractor extractor = 1;
  inline bool has_extractor() const;
  inline void clear_extractor();
  static const int kExtractorFieldNumber = 1;
  inline const ::ResourceExtractor& extractor() const;
  inline ::ResourceExtractor* mutable_extractor();
  inline ::ResourceExtractor* release_extractor();
  inline void set_allocated_extractor(::ResourceExtractor* extractor);

  // @@protoc_insertion_point(class_scope:MiningQuarry)
 private:
  inline void set_has_extractor();
  inline void clear_has_extractor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ResourceExtractor* extractor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static MiningQuarry* default_instance_;
};
// -------------------------------------------------------------------

class PlantEntity : public ::google::protobuf::Message {
 public:
  PlantEntity();
  virtual ~PlantEntity();

  PlantEntity(const PlantEntity& from);

  inline PlantEntity& operator=(const PlantEntity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlantEntity& default_instance();

  void Swap(PlantEntity* other);

  // implements Message ----------------------------------------------

  PlantEntity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlantEntity& from);
  void MergeFrom(const PlantEntity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::uint64 state() const;
  inline void set_state(::google::protobuf::uint64 value);

  // required float age = 2;
  inline bool has_age() const;
  inline void clear_age();
  static const int kAgeFieldNumber = 2;
  inline float age() const;
  inline void set_age(float value);

  // required uint64 genetics = 3;
  inline bool has_genetics() const;
  inline void clear_genetics();
  static const int kGeneticsFieldNumber = 3;
  inline ::google::protobuf::uint64 genetics() const;
  inline void set_genetics(::google::protobuf::uint64 value);

  // required uint64 water = 4;
  inline bool has_water() const;
  inline void clear_water();
  static const int kWaterFieldNumber = 4;
  inline ::google::protobuf::uint64 water() const;
  inline void set_water(::google::protobuf::uint64 value);

  // required float healthy = 5;
  inline bool has_healthy() const;
  inline void clear_healthy();
  static const int kHealthyFieldNumber = 5;
  inline float healthy() const;
  inline void set_healthy(float value);

  // @@protoc_insertion_point(class_scope:PlantEntity)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_age();
  inline void clear_has_age();
  inline void set_has_genetics();
  inline void clear_has_genetics();
  inline void set_has_water();
  inline void clear_has_water();
  inline void set_has_healthy();
  inline void clear_has_healthy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 state_;
  ::google::protobuf::uint64 genetics_;
  float age_;
  float healthy_;
  ::google::protobuf::uint64 water_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static PlantEntity* default_instance_;
};
// -------------------------------------------------------------------

class Helicopter : public ::google::protobuf::Message {
 public:
  Helicopter();
  virtual ~Helicopter();

  Helicopter(const Helicopter& from);

  inline Helicopter& operator=(const Helicopter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Helicopter& default_instance();

  void Swap(Helicopter* other);

  // implements Message ----------------------------------------------

  Helicopter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Helicopter& from);
  void MergeFrom(const Helicopter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Vector3Serialized tiltRot = 1;
  inline bool has_tiltrot() const;
  inline void clear_tiltrot();
  static const int kTiltRotFieldNumber = 1;
  inline const ::Vector3Serialized& tiltrot() const;
  inline ::Vector3Serialized* mutable_tiltrot();
  inline ::Vector3Serialized* release_tiltrot();
  inline void set_allocated_tiltrot(::Vector3Serialized* tiltrot);

  // required .Vector3Serialized leftGun = 2;
  inline bool has_leftgun() const;
  inline void clear_leftgun();
  static const int kLeftGunFieldNumber = 2;
  inline const ::Vector3Serialized& leftgun() const;
  inline ::Vector3Serialized* mutable_leftgun();
  inline ::Vector3Serialized* release_leftgun();
  inline void set_allocated_leftgun(::Vector3Serialized* leftgun);

  // required .Vector3Serialized rightGun = 3;
  inline bool has_rightgun() const;
  inline void clear_rightgun();
  static const int kRightGunFieldNumber = 3;
  inline const ::Vector3Serialized& rightgun() const;
  inline ::Vector3Serialized* mutable_rightgun();
  inline ::Vector3Serialized* release_rightgun();
  inline void set_allocated_rightgun(::Vector3Serialized* rightgun);

  // required .Vector3Serialized spotlightVec = 4;
  inline bool has_spotlightvec() const;
  inline void clear_spotlightvec();
  static const int kSpotlightVecFieldNumber = 4;
  inline const ::Vector3Serialized& spotlightvec() const;
  inline ::Vector3Serialized* mutable_spotlightvec();
  inline ::Vector3Serialized* release_spotlightvec();
  inline void set_allocated_spotlightvec(::Vector3Serialized* spotlightvec);

  // repeated float weakspothealths = 5;
  inline int weakspothealths_size() const;
  inline void clear_weakspothealths();
  static const int kWeakspothealthsFieldNumber = 5;
  inline float weakspothealths(int index) const;
  inline void set_weakspothealths(int index, float value);
  inline void add_weakspothealths(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      weakspothealths() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_weakspothealths();

  // @@protoc_insertion_point(class_scope:Helicopter)
 private:
  inline void set_has_tiltrot();
  inline void clear_has_tiltrot();
  inline void set_has_leftgun();
  inline void clear_has_leftgun();
  inline void set_has_rightgun();
  inline void clear_has_rightgun();
  inline void set_has_spotlightvec();
  inline void clear_has_spotlightvec();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Vector3Serialized* tiltrot_;
  ::Vector3Serialized* leftgun_;
  ::Vector3Serialized* rightgun_;
  ::Vector3Serialized* spotlightvec_;
  ::google::protobuf::RepeatedField< float > weakspothealths_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static Helicopter* default_instance_;
};
// -------------------------------------------------------------------

class Landmine : public ::google::protobuf::Message {
 public:
  Landmine();
  virtual ~Landmine();

  Landmine(const Landmine& from);

  inline Landmine& operator=(const Landmine& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Landmine& default_instance();

  void Swap(Landmine* other);

  // implements Message ----------------------------------------------

  Landmine* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Landmine& from);
  void MergeFrom(const Landmine& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 triggeredID = 1;
  inline bool has_triggeredid() const;
  inline void clear_triggeredid();
  static const int kTriggeredIDFieldNumber = 1;
  inline ::google::protobuf::uint64 triggeredid() const;
  inline void set_triggeredid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Landmine)
 private:
  inline void set_has_triggeredid();
  inline void clear_has_triggeredid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 triggeredid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static Landmine* default_instance_;
};
// -------------------------------------------------------------------

class AutoTurret : public ::google::protobuf::Message {
 public:
  AutoTurret();
  virtual ~AutoTurret();

  AutoTurret(const AutoTurret& from);

  inline AutoTurret& operator=(const AutoTurret& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AutoTurret& default_instance();

  void Swap(AutoTurret* other);

  // implements Message ----------------------------------------------

  AutoTurret* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AutoTurret& from);
  void MergeFrom(const AutoTurret& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Vector3Serialized aimPos = 1;
  inline bool has_aimpos() const;
  inline void clear_aimpos();
  static const int kAimPosFieldNumber = 1;
  inline const ::Vector3Serialized& aimpos() const;
  inline ::Vector3Serialized* mutable_aimpos();
  inline ::Vector3Serialized* release_aimpos();
  inline void set_allocated_aimpos(::Vector3Serialized* aimpos);

  // required .Vector3Serialized aimDir = 2;
  inline bool has_aimdir() const;
  inline void clear_aimdir();
  static const int kAimDirFieldNumber = 2;
  inline const ::Vector3Serialized& aimdir() const;
  inline ::Vector3Serialized* mutable_aimdir();
  inline ::Vector3Serialized* release_aimdir();
  inline void set_allocated_aimdir(::Vector3Serialized* aimdir);

  // required uint32 targetID = 3;
  inline bool has_targetid() const;
  inline void clear_targetid();
  static const int kTargetIDFieldNumber = 3;
  inline ::google::protobuf::uint32 targetid() const;
  inline void set_targetid(::google::protobuf::uint32 value);

  // repeated .PlayerNameID users = 4;
  inline int users_size() const;
  inline void clear_users();
  static const int kUsersFieldNumber = 4;
  inline const ::PlayerNameID& users(int index) const;
  inline ::PlayerNameID* mutable_users(int index);
  inline ::PlayerNameID* add_users();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerNameID >&
      users() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerNameID >*
      mutable_users();

  // @@protoc_insertion_point(class_scope:AutoTurret)
 private:
  inline void set_has_aimpos();
  inline void clear_has_aimpos();
  inline void set_has_aimdir();
  inline void clear_has_aimdir();
  inline void set_has_targetid();
  inline void clear_has_targetid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Vector3Serialized* aimpos_;
  ::Vector3Serialized* aimdir_;
  ::google::protobuf::RepeatedPtrField< ::PlayerNameID > users_;
  ::google::protobuf::uint32 targetid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static AutoTurret* default_instance_;
};
// -------------------------------------------------------------------

class SphereEntity : public ::google::protobuf::Message {
 public:
  SphereEntity();
  virtual ~SphereEntity();

  SphereEntity(const SphereEntity& from);

  inline SphereEntity& operator=(const SphereEntity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SphereEntity& default_instance();

  void Swap(SphereEntity* other);

  // implements Message ----------------------------------------------

  SphereEntity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SphereEntity& from);
  void MergeFrom(const SphereEntity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float radius = 1;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 1;
  inline float radius() const;
  inline void set_radius(float value);

  // @@protoc_insertion_point(class_scope:SphereEntity)
 private:
  inline void set_has_radius();
  inline void clear_has_radius();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float radius_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static SphereEntity* default_instance_;
};
// -------------------------------------------------------------------

class StabilityEntity : public ::google::protobuf::Message {
 public:
  StabilityEntity();
  virtual ~StabilityEntity();

  StabilityEntity(const StabilityEntity& from);

  inline StabilityEntity& operator=(const StabilityEntity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StabilityEntity& default_instance();

  void Swap(StabilityEntity* other);

  // implements Message ----------------------------------------------

  StabilityEntity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StabilityEntity& from);
  void MergeFrom(const StabilityEntity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float stability = 1;
  inline bool has_stability() const;
  inline void clear_stability();
  static const int kStabilityFieldNumber = 1;
  inline float stability() const;
  inline void set_stability(float value);

  // required uint64 distanceFromGround = 2;
  inline bool has_distancefromground() const;
  inline void clear_distancefromground();
  static const int kDistanceFromGroundFieldNumber = 2;
  inline ::google::protobuf::uint64 distancefromground() const;
  inline void set_distancefromground(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:StabilityEntity)
 private:
  inline void set_has_stability();
  inline void clear_has_stability();
  inline void set_has_distancefromground();
  inline void clear_has_distancefromground();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 distancefromground_;
  float stability_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static StabilityEntity* default_instance_;
};
// -------------------------------------------------------------------

class OwnerInfo : public ::google::protobuf::Message {
 public:
  OwnerInfo();
  virtual ~OwnerInfo();

  OwnerInfo(const OwnerInfo& from);

  inline OwnerInfo& operator=(const OwnerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OwnerInfo& default_instance();

  void Swap(OwnerInfo* other);

  // implements Message ----------------------------------------------

  OwnerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OwnerInfo& from);
  void MergeFrom(const OwnerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 steamid = 1;
  inline bool has_steamid() const;
  inline void clear_steamid();
  static const int kSteamidFieldNumber = 1;
  inline ::google::protobuf::uint64 steamid() const;
  inline void set_steamid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:OwnerInfo)
 private:
  inline void set_has_steamid();
  inline void clear_has_steamid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 steamid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static OwnerInfo* default_instance_;
};
// -------------------------------------------------------------------

class DecayEntity : public ::google::protobuf::Message {
 public:
  DecayEntity();
  virtual ~DecayEntity();

  DecayEntity(const DecayEntity& from);

  inline DecayEntity& operator=(const DecayEntity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DecayEntity& default_instance();

  void Swap(DecayEntity* other);

  // implements Message ----------------------------------------------

  DecayEntity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DecayEntity& from);
  void MergeFrom(const DecayEntity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float decayTimer = 1;
  inline bool has_decaytimer() const;
  inline void clear_decaytimer();
  static const int kDecayTimerFieldNumber = 1;
  inline float decaytimer() const;
  inline void set_decaytimer(float value);

  // @@protoc_insertion_point(class_scope:DecayEntity)
 private:
  inline void set_has_decaytimer();
  inline void clear_has_decaytimer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float decaytimer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static DecayEntity* default_instance_;
};
// -------------------------------------------------------------------

class Spawnable : public ::google::protobuf::Message {
 public:
  Spawnable();
  virtual ~Spawnable();

  Spawnable(const Spawnable& from);

  inline Spawnable& operator=(const Spawnable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Spawnable& default_instance();

  void Swap(Spawnable* other);

  // implements Message ----------------------------------------------

  Spawnable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Spawnable& from);
  void MergeFrom(const Spawnable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 population = 1;
  inline bool has_population() const;
  inline void clear_population();
  static const int kPopulationFieldNumber = 1;
  inline ::google::protobuf::uint32 population() const;
  inline void set_population(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Spawnable)
 private:
  inline void set_has_population();
  inline void clear_has_population();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 population_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static Spawnable* default_instance_;
};
// -------------------------------------------------------------------

class ServerGib : public ::google::protobuf::Message {
 public:
  ServerGib();
  virtual ~ServerGib();

  ServerGib(const ServerGib& from);

  inline ServerGib& operator=(const ServerGib& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerGib& default_instance();

  void Swap(ServerGib* other);

  // implements Message ----------------------------------------------

  ServerGib* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerGib& from);
  void MergeFrom(const ServerGib& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string gibName = 1;
  inline bool has_gibname() const;
  inline void clear_gibname();
  static const int kGibNameFieldNumber = 1;
  inline const ::std::string& gibname() const;
  inline void set_gibname(const ::std::string& value);
  inline void set_gibname(const char* value);
  inline void set_gibname(const char* value, size_t size);
  inline ::std::string* mutable_gibname();
  inline ::std::string* release_gibname();
  inline void set_allocated_gibname(::std::string* gibname);

  // @@protoc_insertion_point(class_scope:ServerGib)
 private:
  inline void set_has_gibname();
  inline void clear_has_gibname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gibname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static ServerGib* default_instance_;
};
// -------------------------------------------------------------------

class VendingMachine_SellOrder : public ::google::protobuf::Message {
 public:
  VendingMachine_SellOrder();
  virtual ~VendingMachine_SellOrder();

  VendingMachine_SellOrder(const VendingMachine_SellOrder& from);

  inline VendingMachine_SellOrder& operator=(const VendingMachine_SellOrder& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VendingMachine_SellOrder& default_instance();

  void Swap(VendingMachine_SellOrder* other);

  // implements Message ----------------------------------------------

  VendingMachine_SellOrder* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VendingMachine_SellOrder& from);
  void MergeFrom(const VendingMachine_SellOrder& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 itemToSellID = 1;
  inline bool has_itemtosellid() const;
  inline void clear_itemtosellid();
  static const int kItemToSellIDFieldNumber = 1;
  inline ::google::protobuf::uint64 itemtosellid() const;
  inline void set_itemtosellid(::google::protobuf::uint64 value);

  // required uint64 itemToSellAmount = 2;
  inline bool has_itemtosellamount() const;
  inline void clear_itemtosellamount();
  static const int kItemToSellAmountFieldNumber = 2;
  inline ::google::protobuf::uint64 itemtosellamount() const;
  inline void set_itemtosellamount(::google::protobuf::uint64 value);

  // required uint64 currencyID = 3;
  inline bool has_currencyid() const;
  inline void clear_currencyid();
  static const int kCurrencyIDFieldNumber = 3;
  inline ::google::protobuf::uint64 currencyid() const;
  inline void set_currencyid(::google::protobuf::uint64 value);

  // required uint64 currencyAmountPerItem = 4;
  inline bool has_currencyamountperitem() const;
  inline void clear_currencyamountperitem();
  static const int kCurrencyAmountPerItemFieldNumber = 4;
  inline ::google::protobuf::uint64 currencyamountperitem() const;
  inline void set_currencyamountperitem(::google::protobuf::uint64 value);

  // required uint64 inStock = 5;
  inline bool has_instock() const;
  inline void clear_instock();
  static const int kInStockFieldNumber = 5;
  inline ::google::protobuf::uint64 instock() const;
  inline void set_instock(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:VendingMachine.SellOrder)
 private:
  inline void set_has_itemtosellid();
  inline void clear_has_itemtosellid();
  inline void set_has_itemtosellamount();
  inline void clear_has_itemtosellamount();
  inline void set_has_currencyid();
  inline void clear_has_currencyid();
  inline void set_has_currencyamountperitem();
  inline void clear_has_currencyamountperitem();
  inline void set_has_instock();
  inline void clear_has_instock();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 itemtosellid_;
  ::google::protobuf::uint64 itemtosellamount_;
  ::google::protobuf::uint64 currencyid_;
  ::google::protobuf::uint64 currencyamountperitem_;
  ::google::protobuf::uint64 instock_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static VendingMachine_SellOrder* default_instance_;
};
// -------------------------------------------------------------------

class VendingMachine_SellOrderContainer : public ::google::protobuf::Message {
 public:
  VendingMachine_SellOrderContainer();
  virtual ~VendingMachine_SellOrderContainer();

  VendingMachine_SellOrderContainer(const VendingMachine_SellOrderContainer& from);

  inline VendingMachine_SellOrderContainer& operator=(const VendingMachine_SellOrderContainer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VendingMachine_SellOrderContainer& default_instance();

  void Swap(VendingMachine_SellOrderContainer* other);

  // implements Message ----------------------------------------------

  VendingMachine_SellOrderContainer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VendingMachine_SellOrderContainer& from);
  void MergeFrom(const VendingMachine_SellOrderContainer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .VendingMachine.SellOrder sellOrders = 1;
  inline int sellorders_size() const;
  inline void clear_sellorders();
  static const int kSellOrdersFieldNumber = 1;
  inline const ::VendingMachine_SellOrder& sellorders(int index) const;
  inline ::VendingMachine_SellOrder* mutable_sellorders(int index);
  inline ::VendingMachine_SellOrder* add_sellorders();
  inline const ::google::protobuf::RepeatedPtrField< ::VendingMachine_SellOrder >&
      sellorders() const;
  inline ::google::protobuf::RepeatedPtrField< ::VendingMachine_SellOrder >*
      mutable_sellorders();

  // @@protoc_insertion_point(class_scope:VendingMachine.SellOrderContainer)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::VendingMachine_SellOrder > sellorders_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static VendingMachine_SellOrderContainer* default_instance_;
};
// -------------------------------------------------------------------

class VendingMachine : public ::google::protobuf::Message {
 public:
  VendingMachine();
  virtual ~VendingMachine();

  VendingMachine(const VendingMachine& from);

  inline VendingMachine& operator=(const VendingMachine& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VendingMachine& default_instance();

  void Swap(VendingMachine* other);

  // implements Message ----------------------------------------------

  VendingMachine* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VendingMachine& from);
  void MergeFrom(const VendingMachine& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef VendingMachine_SellOrder SellOrder;
  typedef VendingMachine_SellOrderContainer SellOrderContainer;

  // accessors -------------------------------------------------------

  // optional .VendingMachine.SellOrderContainer sellOrderContainer = 1;
  inline bool has_sellordercontainer() const;
  inline void clear_sellordercontainer();
  static const int kSellOrderContainerFieldNumber = 1;
  inline const ::VendingMachine_SellOrderContainer& sellordercontainer() const;
  inline ::VendingMachine_SellOrderContainer* mutable_sellordercontainer();
  inline ::VendingMachine_SellOrderContainer* release_sellordercontainer();
  inline void set_allocated_sellordercontainer(::VendingMachine_SellOrderContainer* sellordercontainer);

  // optional string shopName = 2;
  inline bool has_shopname() const;
  inline void clear_shopname();
  static const int kShopNameFieldNumber = 2;
  inline const ::std::string& shopname() const;
  inline void set_shopname(const ::std::string& value);
  inline void set_shopname(const char* value);
  inline void set_shopname(const char* value, size_t size);
  inline ::std::string* mutable_shopname();
  inline ::std::string* release_shopname();
  inline void set_allocated_shopname(::std::string* shopname);

  // @@protoc_insertion_point(class_scope:VendingMachine)
 private:
  inline void set_has_sellordercontainer();
  inline void clear_has_sellordercontainer();
  inline void set_has_shopname();
  inline void clear_has_shopname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::VendingMachine_SellOrderContainer* sellordercontainer_;
  ::std::string* shopname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static VendingMachine* default_instance_;
};
// -------------------------------------------------------------------

class SpinnerWheel : public ::google::protobuf::Message {
 public:
  SpinnerWheel();
  virtual ~SpinnerWheel();

  SpinnerWheel(const SpinnerWheel& from);

  inline SpinnerWheel& operator=(const SpinnerWheel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpinnerWheel& default_instance();

  void Swap(SpinnerWheel* other);

  // implements Message ----------------------------------------------

  SpinnerWheel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SpinnerWheel& from);
  void MergeFrom(const SpinnerWheel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Vector3Serialized spin = 1;
  inline bool has_spin() const;
  inline void clear_spin();
  static const int kSpinFieldNumber = 1;
  inline const ::Vector3Serialized& spin() const;
  inline ::Vector3Serialized* mutable_spin();
  inline ::Vector3Serialized* release_spin();
  inline void set_allocated_spin(::Vector3Serialized* spin);

  // @@protoc_insertion_point(class_scope:SpinnerWheel)
 private:
  inline void set_has_spin();
  inline void clear_has_spin();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Vector3Serialized* spin_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static SpinnerWheel* default_instance_;
};
// -------------------------------------------------------------------

class Entity : public ::google::protobuf::Message {
 public:
  Entity();
  virtual ~Entity();

  Entity(const Entity& from);

  inline Entity& operator=(const Entity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Entity& default_instance();

  void Swap(Entity* other);

  // implements Message ----------------------------------------------

  Entity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Entity& from);
  void MergeFrom(const Entity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .BaseNetworkable baseNetworkable = 1;
  inline bool has_basenetworkable() const;
  inline void clear_basenetworkable();
  static const int kBaseNetworkableFieldNumber = 1;
  inline const ::BaseNetworkable& basenetworkable() const;
  inline ::BaseNetworkable* mutable_basenetworkable();
  inline ::BaseNetworkable* release_basenetworkable();
  inline void set_allocated_basenetworkable(::BaseNetworkable* basenetworkable);

  // optional .BaseEntity baseEntity = 2;
  inline bool has_baseentity() const;
  inline void clear_baseentity();
  static const int kBaseEntityFieldNumber = 2;
  inline const ::BaseEntity& baseentity() const;
  inline ::BaseEntity* mutable_baseentity();
  inline ::BaseEntity* release_baseentity();
  inline void set_allocated_baseentity(::BaseEntity* baseentity);

  // optional .BasePlayer basePlayer = 3;
  inline bool has_baseplayer() const;
  inline void clear_baseplayer();
  static const int kBasePlayerFieldNumber = 3;
  inline const ::BasePlayer& baseplayer() const;
  inline ::BasePlayer* mutable_baseplayer();
  inline ::BasePlayer* release_baseplayer();
  inline void set_allocated_baseplayer(::BasePlayer* baseplayer);

  // optional .WorldItem worldItem = 4;
  inline bool has_worlditem() const;
  inline void clear_worlditem();
  static const int kWorldItemFieldNumber = 4;
  inline const ::WorldItem& worlditem() const;
  inline ::WorldItem* mutable_worlditem();
  inline ::WorldItem* release_worlditem();
  inline void set_allocated_worlditem(::WorldItem* worlditem);

  // optional .BaseResource resource = 5;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 5;
  inline const ::BaseResource& resource() const;
  inline ::BaseResource* mutable_resource();
  inline ::BaseResource* release_resource();
  inline void set_allocated_resource(::BaseResource* resource);

  // optional .BuildingBlock buildingBlock = 6;
  inline bool has_buildingblock() const;
  inline void clear_buildingblock();
  static const int kBuildingBlockFieldNumber = 6;
  inline const ::BuildingBlock& buildingblock() const;
  inline ::BuildingBlock* mutable_buildingblock();
  inline ::BuildingBlock* release_buildingblock();
  inline void set_allocated_buildingblock(::BuildingBlock* buildingblock);

  // optional .Environment environment = 7;
  inline bool has_environment() const;
  inline void clear_environment();
  static const int kEnvironmentFieldNumber = 7;
  inline const ::Environment& environment() const;
  inline ::Environment* mutable_environment();
  inline ::Environment* release_environment();
  inline void set_allocated_environment(::Environment* environment);

  // optional .Corpse corpse = 8;
  inline bool has_corpse() const;
  inline void clear_corpse();
  static const int kCorpseFieldNumber = 8;
  inline const ::Corpse& corpse() const;
  inline ::Corpse* mutable_corpse();
  inline ::Corpse* release_corpse();
  inline void set_allocated_corpse(::Corpse* corpse);

  // optional .ParentInfo parent = 10;
  inline bool has_parent() const;
  inline void clear_parent();
  static const int kParentFieldNumber = 10;
  inline const ::ParentInfo& parent() const;
  inline ::ParentInfo* mutable_parent();
  inline ::ParentInfo* release_parent();
  inline void set_allocated_parent(::ParentInfo* parent);

  // optional .KeyLock keyLock = 11;
  inline bool has_keylock() const;
  inline void clear_keylock();
  static const int kKeyLockFieldNumber = 11;
  inline const ::KeyLock& keylock() const;
  inline ::KeyLock* mutable_keylock();
  inline ::KeyLock* release_keylock();
  inline void set_allocated_keylock(::KeyLock* keylock);

  // optional .CodeLock codeLock = 12;
  inline bool has_codelock() const;
  inline void clear_codelock();
  static const int kCodeLockFieldNumber = 12;
  inline const ::CodeLock& codelock() const;
  inline ::CodeLock* mutable_codelock();
  inline ::CodeLock* release_codelock();
  inline void set_allocated_codelock(::CodeLock* codelock);

  // optional .EntitySlots entitySlots = 13;
  inline bool has_entityslots() const;
  inline void clear_entityslots();
  static const int kEntitySlotsFieldNumber = 13;
  inline const ::EntitySlots& entityslots() const;
  inline ::EntitySlots* mutable_entityslots();
  inline ::EntitySlots* release_entityslots();
  inline void set_allocated_entityslots(::EntitySlots* entityslots);

  // optional .BuildingPrivilege buildingPrivilege = 14;
  inline bool has_buildingprivilege() const;
  inline void clear_buildingprivilege();
  static const int kBuildingPrivilegeFieldNumber = 14;
  inline const ::BuildingPrivilege& buildingprivilege() const;
  inline ::BuildingPrivilege* mutable_buildingprivilege();
  inline ::BuildingPrivilege* release_buildingprivilege();
  inline void set_allocated_buildingprivilege(::BuildingPrivilege* buildingprivilege);

  // optional .StorageBox storageBox = 15;
  inline bool has_storagebox() const;
  inline void clear_storagebox();
  static const int kStorageBoxFieldNumber = 15;
  inline const ::StorageBox& storagebox() const;
  inline ::StorageBox* mutable_storagebox();
  inline ::StorageBox* release_storagebox();
  inline void set_allocated_storagebox(::StorageBox* storagebox);

  // optional .HeldEntity heldEntity = 16;
  inline bool has_heldentity() const;
  inline void clear_heldentity();
  static const int kHeldEntityFieldNumber = 16;
  inline const ::HeldEntity& heldentity() const;
  inline ::HeldEntity* mutable_heldentity();
  inline ::HeldEntity* release_heldentity();
  inline void set_allocated_heldentity(::HeldEntity* heldentity);

  // optional .BaseProjectile baseProjectile = 17;
  inline bool has_baseprojectile() const;
  inline void clear_baseprojectile();
  static const int kBaseProjectileFieldNumber = 17;
  inline const ::BaseProjectile& baseprojectile() const;
  inline ::BaseProjectile* mutable_baseprojectile();
  inline ::BaseProjectile* release_baseprojectile();
  inline void set_allocated_baseprojectile(::BaseProjectile* baseprojectile);

  // optional .BaseNPC baseNPC = 18;
  inline bool has_basenpc() const;
  inline void clear_basenpc();
  static const int kBaseNPCFieldNumber = 18;
  inline const ::BaseNPC& basenpc() const;
  inline ::BaseNPC* mutable_basenpc();
  inline ::BaseNPC* release_basenpc();
  inline void set_allocated_basenpc(::BaseNPC* basenpc);

  // optional .Loot loot = 19;
  inline bool has_loot() const;
  inline void clear_loot();
  static const int kLootFieldNumber = 19;
  inline const ::Loot& loot() const;
  inline ::Loot* mutable_loot();
  inline ::Loot* release_loot();
  inline void set_allocated_loot(::Loot* loot);

  // optional .GenericSpawner genericSpawner = 20;
  inline bool has_genericspawner() const;
  inline void clear_genericspawner();
  static const int kGenericSpawnerFieldNumber = 20;
  inline const ::GenericSpawner& genericspawner() const;
  inline ::GenericSpawner* mutable_genericspawner();
  inline ::GenericSpawner* release_genericspawner();
  inline void set_allocated_genericspawner(::GenericSpawner* genericspawner);

  // optional .SleepingBag sleepingBag = 21;
  inline bool has_sleepingbag() const;
  inline void clear_sleepingbag();
  static const int kSleepingBagFieldNumber = 21;
  inline const ::SleepingBag& sleepingbag() const;
  inline ::SleepingBag* mutable_sleepingbag();
  inline ::SleepingBag* release_sleepingbag();
  inline void set_allocated_sleepingbag(::SleepingBag* sleepingbag);

  // optional .LootableCorpse lootableCorpse = 22;
  inline bool has_lootablecorpse() const;
  inline void clear_lootablecorpse();
  static const int kLootableCorpseFieldNumber = 22;
  inline const ::LootableCorpse& lootablecorpse() const;
  inline ::LootableCorpse* mutable_lootablecorpse();
  inline ::LootableCorpse* release_lootablecorpse();
  inline void set_allocated_lootablecorpse(::LootableCorpse* lootablecorpse);

  // optional .Sign sign = 23;
  inline bool has_sign() const;
  inline void clear_sign();
  static const int kSignFieldNumber = 23;
  inline const ::Sign& sign() const;
  inline ::Sign* mutable_sign();
  inline ::Sign* release_sign();
  inline void set_allocated_sign(::Sign* sign);

  // optional .BaseCombat baseCombat = 24;
  inline bool has_basecombat() const;
  inline void clear_basecombat();
  static const int kBaseCombatFieldNumber = 24;
  inline const ::BaseCombat& basecombat() const;
  inline ::BaseCombat* mutable_basecombat();
  inline ::BaseCombat* release_basecombat();
  inline void set_allocated_basecombat(::BaseCombat* basecombat);

  // optional .MapEntity mapEntity = 25;
  inline bool has_mapentity() const;
  inline void clear_mapentity();
  static const int kMapEntityFieldNumber = 25;
  inline const ::MapEntity& mapentity() const;
  inline ::MapEntity* mutable_mapentity();
  inline ::MapEntity* release_mapentity();
  inline void set_allocated_mapentity(::MapEntity* mapentity);

  // optional .ResearchTable researchTable = 26;
  inline bool has_researchtable() const;
  inline void clear_researchtable();
  static const int kResearchTableFieldNumber = 26;
  inline const ::ResearchTable& researchtable() const;
  inline ::ResearchTable* mutable_researchtable();
  inline ::ResearchTable* release_researchtable();
  inline void set_allocated_researchtable(::ResearchTable* researchtable);

  // optional .DudExplosive dudExplosive = 27;
  inline bool has_dudexplosive() const;
  inline void clear_dudexplosive();
  static const int kDudExplosiveFieldNumber = 27;
  inline const ::DudExplosive& dudexplosive() const;
  inline ::DudExplosive* mutable_dudexplosive();
  inline ::DudExplosive* release_dudexplosive();
  inline void set_allocated_dudexplosive(::DudExplosive* dudexplosive);

  // optional .MiningQuarry miningQuarry = 28;
  inline bool has_miningquarry() const;
  inline void clear_miningquarry();
  static const int kMiningQuarryFieldNumber = 28;
  inline const ::MiningQuarry& miningquarry() const;
  inline ::MiningQuarry* mutable_miningquarry();
  inline ::MiningQuarry* release_miningquarry();
  inline void set_allocated_miningquarry(::MiningQuarry* miningquarry);

  // optional .PlantEntity plantEntity = 29;
  inline bool has_plantentity() const;
  inline void clear_plantentity();
  static const int kPlantEntityFieldNumber = 29;
  inline const ::PlantEntity& plantentity() const;
  inline ::PlantEntity* mutable_plantentity();
  inline ::PlantEntity* release_plantentity();
  inline void set_allocated_plantentity(::PlantEntity* plantentity);

  // optional .Helicopter helicopter = 30;
  inline bool has_helicopter() const;
  inline void clear_helicopter();
  static const int kHelicopterFieldNumber = 30;
  inline const ::Helicopter& helicopter() const;
  inline ::Helicopter* mutable_helicopter();
  inline ::Helicopter* release_helicopter();
  inline void set_allocated_helicopter(::Helicopter* helicopter);

  // optional .Landmine landmine = 31;
  inline bool has_landmine() const;
  inline void clear_landmine();
  static const int kLandmineFieldNumber = 31;
  inline const ::Landmine& landmine() const;
  inline ::Landmine* mutable_landmine();
  inline ::Landmine* release_landmine();
  inline void set_allocated_landmine(::Landmine* landmine);

  // optional .AutoTurret autoturret = 32;
  inline bool has_autoturret() const;
  inline void clear_autoturret();
  static const int kAutoturretFieldNumber = 32;
  inline const ::AutoTurret& autoturret() const;
  inline ::AutoTurret* mutable_autoturret();
  inline ::AutoTurret* release_autoturret();
  inline void set_allocated_autoturret(::AutoTurret* autoturret);

  // optional .SphereEntity sphereEntity = 33;
  inline bool has_sphereentity() const;
  inline void clear_sphereentity();
  static const int kSphereEntityFieldNumber = 33;
  inline const ::SphereEntity& sphereentity() const;
  inline ::SphereEntity* mutable_sphereentity();
  inline ::SphereEntity* release_sphereentity();
  inline void set_allocated_sphereentity(::SphereEntity* sphereentity);

  // optional .StabilityEntity stabilityEntity = 34;
  inline bool has_stabilityentity() const;
  inline void clear_stabilityentity();
  static const int kStabilityEntityFieldNumber = 34;
  inline const ::StabilityEntity& stabilityentity() const;
  inline ::StabilityEntity* mutable_stabilityentity();
  inline ::StabilityEntity* release_stabilityentity();
  inline void set_allocated_stabilityentity(::StabilityEntity* stabilityentity);

  // optional .OwnerInfo ownerInfo = 35;
  inline bool has_ownerinfo() const;
  inline void clear_ownerinfo();
  static const int kOwnerInfoFieldNumber = 35;
  inline const ::OwnerInfo& ownerinfo() const;
  inline ::OwnerInfo* mutable_ownerinfo();
  inline ::OwnerInfo* release_ownerinfo();
  inline void set_allocated_ownerinfo(::OwnerInfo* ownerinfo);

  // optional .DecayEntity decayEntity = 36;
  inline bool has_decayentity() const;
  inline void clear_decayentity();
  static const int kDecayEntityFieldNumber = 36;
  inline const ::DecayEntity& decayentity() const;
  inline ::DecayEntity* mutable_decayentity();
  inline ::DecayEntity* release_decayentity();
  inline void set_allocated_decayentity(::DecayEntity* decayentity);

  // optional .Spawnable spawnable = 37;
  inline bool has_spawnable() const;
  inline void clear_spawnable();
  static const int kSpawnableFieldNumber = 37;
  inline const ::Spawnable& spawnable() const;
  inline ::Spawnable* mutable_spawnable();
  inline ::Spawnable* release_spawnable();
  inline void set_allocated_spawnable(::Spawnable* spawnable);

  // optional .ServerGib servergib = 38;
  inline bool has_servergib() const;
  inline void clear_servergib();
  static const int kServergibFieldNumber = 38;
  inline const ::ServerGib& servergib() const;
  inline ::ServerGib* mutable_servergib();
  inline ::ServerGib* release_servergib();
  inline void set_allocated_servergib(::ServerGib* servergib);

  // optional .VendingMachine vendingMachine = 39;
  inline bool has_vendingmachine() const;
  inline void clear_vendingmachine();
  static const int kVendingMachineFieldNumber = 39;
  inline const ::VendingMachine& vendingmachine() const;
  inline ::VendingMachine* mutable_vendingmachine();
  inline ::VendingMachine* release_vendingmachine();
  inline void set_allocated_vendingmachine(::VendingMachine* vendingmachine);

  // optional .SpinnerWheel spinnerWheel = 40;
  inline bool has_spinnerwheel() const;
  inline void clear_spinnerwheel();
  static const int kSpinnerWheelFieldNumber = 40;
  inline const ::SpinnerWheel& spinnerwheel() const;
  inline ::SpinnerWheel* mutable_spinnerwheel();
  inline ::SpinnerWheel* release_spinnerwheel();
  inline void set_allocated_spinnerwheel(::SpinnerWheel* spinnerwheel);

  // required bool createdThisFrame = 100;
  inline bool has_createdthisframe() const;
  inline void clear_createdthisframe();
  static const int kCreatedThisFrameFieldNumber = 100;
  inline bool createdthisframe() const;
  inline void set_createdthisframe(bool value);

  // @@protoc_insertion_point(class_scope:Entity)
 private:
  inline void set_has_basenetworkable();
  inline void clear_has_basenetworkable();
  inline void set_has_baseentity();
  inline void clear_has_baseentity();
  inline void set_has_baseplayer();
  inline void clear_has_baseplayer();
  inline void set_has_worlditem();
  inline void clear_has_worlditem();
  inline void set_has_resource();
  inline void clear_has_resource();
  inline void set_has_buildingblock();
  inline void clear_has_buildingblock();
  inline void set_has_environment();
  inline void clear_has_environment();
  inline void set_has_corpse();
  inline void clear_has_corpse();
  inline void set_has_parent();
  inline void clear_has_parent();
  inline void set_has_keylock();
  inline void clear_has_keylock();
  inline void set_has_codelock();
  inline void clear_has_codelock();
  inline void set_has_entityslots();
  inline void clear_has_entityslots();
  inline void set_has_buildingprivilege();
  inline void clear_has_buildingprivilege();
  inline void set_has_storagebox();
  inline void clear_has_storagebox();
  inline void set_has_heldentity();
  inline void clear_has_heldentity();
  inline void set_has_baseprojectile();
  inline void clear_has_baseprojectile();
  inline void set_has_basenpc();
  inline void clear_has_basenpc();
  inline void set_has_loot();
  inline void clear_has_loot();
  inline void set_has_genericspawner();
  inline void clear_has_genericspawner();
  inline void set_has_sleepingbag();
  inline void clear_has_sleepingbag();
  inline void set_has_lootablecorpse();
  inline void clear_has_lootablecorpse();
  inline void set_has_sign();
  inline void clear_has_sign();
  inline void set_has_basecombat();
  inline void clear_has_basecombat();
  inline void set_has_mapentity();
  inline void clear_has_mapentity();
  inline void set_has_researchtable();
  inline void clear_has_researchtable();
  inline void set_has_dudexplosive();
  inline void clear_has_dudexplosive();
  inline void set_has_miningquarry();
  inline void clear_has_miningquarry();
  inline void set_has_plantentity();
  inline void clear_has_plantentity();
  inline void set_has_helicopter();
  inline void clear_has_helicopter();
  inline void set_has_landmine();
  inline void clear_has_landmine();
  inline void set_has_autoturret();
  inline void clear_has_autoturret();
  inline void set_has_sphereentity();
  inline void clear_has_sphereentity();
  inline void set_has_stabilityentity();
  inline void clear_has_stabilityentity();
  inline void set_has_ownerinfo();
  inline void clear_has_ownerinfo();
  inline void set_has_decayentity();
  inline void clear_has_decayentity();
  inline void set_has_spawnable();
  inline void clear_has_spawnable();
  inline void set_has_servergib();
  inline void clear_has_servergib();
  inline void set_has_vendingmachine();
  inline void clear_has_vendingmachine();
  inline void set_has_spinnerwheel();
  inline void clear_has_spinnerwheel();
  inline void set_has_createdthisframe();
  inline void clear_has_createdthisframe();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::BaseNetworkable* basenetworkable_;
  ::BaseEntity* baseentity_;
  ::BasePlayer* baseplayer_;
  ::WorldItem* worlditem_;
  ::BaseResource* resource_;
  ::BuildingBlock* buildingblock_;
  ::Environment* environment_;
  ::Corpse* corpse_;
  ::ParentInfo* parent_;
  ::KeyLock* keylock_;
  ::CodeLock* codelock_;
  ::EntitySlots* entityslots_;
  ::BuildingPrivilege* buildingprivilege_;
  ::StorageBox* storagebox_;
  ::HeldEntity* heldentity_;
  ::BaseProjectile* baseprojectile_;
  ::BaseNPC* basenpc_;
  ::Loot* loot_;
  ::GenericSpawner* genericspawner_;
  ::SleepingBag* sleepingbag_;
  ::LootableCorpse* lootablecorpse_;
  ::Sign* sign_;
  ::BaseCombat* basecombat_;
  ::MapEntity* mapentity_;
  ::ResearchTable* researchtable_;
  ::DudExplosive* dudexplosive_;
  ::MiningQuarry* miningquarry_;
  ::PlantEntity* plantentity_;
  ::Helicopter* helicopter_;
  ::Landmine* landmine_;
  ::AutoTurret* autoturret_;
  ::SphereEntity* sphereentity_;
  ::StabilityEntity* stabilityentity_;
  ::OwnerInfo* ownerinfo_;
  ::DecayEntity* decayentity_;
  ::Spawnable* spawnable_;
  ::ServerGib* servergib_;
  ::VendingMachine* vendingmachine_;
  ::SpinnerWheel* spinnerwheel_;
  bool createdthisframe_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(40 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static Entity* default_instance_;
};
// -------------------------------------------------------------------

class Approval : public ::google::protobuf::Message {
 public:
  Approval();
  virtual ~Approval();

  Approval(const Approval& from);

  inline Approval& operator=(const Approval& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Approval& default_instance();

  void Swap(Approval* other);

  // implements Message ----------------------------------------------

  Approval* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Approval& from);
  void MergeFrom(const Approval& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline const ::std::string& level() const;
  inline void set_level(const ::std::string& value);
  inline void set_level(const char* value);
  inline void set_level(const char* value, size_t size);
  inline ::std::string* mutable_level();
  inline ::std::string* release_level();
  inline void set_allocated_level(::std::string* level);

  // optional string hostname = 3;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 3;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // required bool modded = 4;
  inline bool has_modded() const;
  inline void clear_modded();
  static const int kModdedFieldNumber = 4;
  inline bool modded() const;
  inline void set_modded(bool value);

  // required bool official = 5;
  inline bool has_official() const;
  inline void clear_official();
  static const int kOfficialFieldNumber = 5;
  inline bool official() const;
  inline void set_official(bool value);

  // required uint64 steamid = 6;
  inline bool has_steamid() const;
  inline void clear_steamid();
  static const int kSteamidFieldNumber = 6;
  inline ::google::protobuf::uint64 steamid() const;
  inline void set_steamid(::google::protobuf::uint64 value);

  // required uint32 ipaddress = 7;
  inline bool has_ipaddress() const;
  inline void clear_ipaddress();
  static const int kIpaddressFieldNumber = 7;
  inline ::google::protobuf::uint32 ipaddress() const;
  inline void set_ipaddress(::google::protobuf::uint32 value);

  // required uint64 port = 8;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 8;
  inline ::google::protobuf::uint64 port() const;
  inline void set_port(::google::protobuf::uint64 value);

  // required uint32 levelSeed = 9;
  inline bool has_levelseed() const;
  inline void clear_levelseed();
  static const int kLevelSeedFieldNumber = 9;
  inline ::google::protobuf::uint32 levelseed() const;
  inline void set_levelseed(::google::protobuf::uint32 value);

  // required uint32 levelSize = 10;
  inline bool has_levelsize() const;
  inline void clear_levelsize();
  static const int kLevelSizeFieldNumber = 10;
  inline ::google::protobuf::uint32 levelsize() const;
  inline void set_levelsize(::google::protobuf::uint32 value);

  // optional string checksum = 11;
  inline bool has_checksum() const;
  inline void clear_checksum();
  static const int kChecksumFieldNumber = 11;
  inline const ::std::string& checksum() const;
  inline void set_checksum(const ::std::string& value);
  inline void set_checksum(const char* value);
  inline void set_checksum(const char* value, size_t size);
  inline ::std::string* mutable_checksum();
  inline ::std::string* release_checksum();
  inline void set_allocated_checksum(::std::string* checksum);

  // @@protoc_insertion_point(class_scope:Approval)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_modded();
  inline void clear_has_modded();
  inline void set_has_official();
  inline void clear_has_official();
  inline void set_has_steamid();
  inline void clear_has_steamid();
  inline void set_has_ipaddress();
  inline void clear_has_ipaddress();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_levelseed();
  inline void clear_has_levelseed();
  inline void set_has_levelsize();
  inline void clear_has_levelsize();
  inline void set_has_checksum();
  inline void clear_has_checksum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* level_;
  ::std::string* hostname_;
  bool modded_;
  bool official_;
  ::google::protobuf::uint32 ipaddress_;
  ::google::protobuf::uint64 steamid_;
  ::google::protobuf::uint64 port_;
  ::google::protobuf::uint32 levelseed_;
  ::google::protobuf::uint32 levelsize_;
  ::std::string* checksum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static Approval* default_instance_;
};
// -------------------------------------------------------------------

class Attack : public ::google::protobuf::Message {
 public:
  Attack();
  virtual ~Attack();

  Attack(const Attack& from);

  inline Attack& operator=(const Attack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Attack& default_instance();

  void Swap(Attack* other);

  // implements Message ----------------------------------------------

  Attack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Attack& from);
  void MergeFrom(const Attack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Vector3Serialized pointStart = 1;
  inline bool has_pointstart() const;
  inline void clear_pointstart();
  static const int kPointStartFieldNumber = 1;
  inline const ::Vector3Serialized& pointstart() const;
  inline ::Vector3Serialized* mutable_pointstart();
  inline ::Vector3Serialized* release_pointstart();
  inline void set_allocated_pointstart(::Vector3Serialized* pointstart);

  // required .Vector3Serialized pointEnd = 2;
  inline bool has_pointend() const;
  inline void clear_pointend();
  static const int kPointEndFieldNumber = 2;
  inline const ::Vector3Serialized& pointend() const;
  inline ::Vector3Serialized* mutable_pointend();
  inline ::Vector3Serialized* release_pointend();
  inline void set_allocated_pointend(::Vector3Serialized* pointend);

  // required uint32 hitID = 3;
  inline bool has_hitid() const;
  inline void clear_hitid();
  static const int kHitIDFieldNumber = 3;
  inline ::google::protobuf::uint32 hitid() const;
  inline void set_hitid(::google::protobuf::uint32 value);

  // required uint32 hitBone = 4;
  inline bool has_hitbone() const;
  inline void clear_hitbone();
  static const int kHitBoneFieldNumber = 4;
  inline ::google::protobuf::uint32 hitbone() const;
  inline void set_hitbone(::google::protobuf::uint32 value);

  // required .Vector3Serialized hitNormalLocal = 5;
  inline bool has_hitnormallocal() const;
  inline void clear_hitnormallocal();
  static const int kHitNormalLocalFieldNumber = 5;
  inline const ::Vector3Serialized& hitnormallocal() const;
  inline ::Vector3Serialized* mutable_hitnormallocal();
  inline ::Vector3Serialized* release_hitnormallocal();
  inline void set_allocated_hitnormallocal(::Vector3Serialized* hitnormallocal);

  // required .Vector3Serialized hitPositionLocal = 6;
  inline bool has_hitpositionlocal() const;
  inline void clear_hitpositionlocal();
  static const int kHitPositionLocalFieldNumber = 6;
  inline const ::Vector3Serialized& hitpositionlocal() const;
  inline ::Vector3Serialized* mutable_hitpositionlocal();
  inline ::Vector3Serialized* release_hitpositionlocal();
  inline void set_allocated_hitpositionlocal(::Vector3Serialized* hitpositionlocal);

  // required .Vector3Serialized hitNormalWorld = 7;
  inline bool has_hitnormalworld() const;
  inline void clear_hitnormalworld();
  static const int kHitNormalWorldFieldNumber = 7;
  inline const ::Vector3Serialized& hitnormalworld() const;
  inline ::Vector3Serialized* mutable_hitnormalworld();
  inline ::Vector3Serialized* release_hitnormalworld();
  inline void set_allocated_hitnormalworld(::Vector3Serialized* hitnormalworld);

  // required .Vector3Serialized hitPositionWorld = 8;
  inline bool has_hitpositionworld() const;
  inline void clear_hitpositionworld();
  static const int kHitPositionWorldFieldNumber = 8;
  inline const ::Vector3Serialized& hitpositionworld() const;
  inline ::Vector3Serialized* mutable_hitpositionworld();
  inline ::Vector3Serialized* release_hitpositionworld();
  inline void set_allocated_hitpositionworld(::Vector3Serialized* hitpositionworld);

  // required uint32 hitPartID = 9;
  inline bool has_hitpartid() const;
  inline void clear_hitpartid();
  static const int kHitPartIDFieldNumber = 9;
  inline ::google::protobuf::uint32 hitpartid() const;
  inline void set_hitpartid(::google::protobuf::uint32 value);

  // required uint32 hitMaterialID = 10;
  inline bool has_hitmaterialid() const;
  inline void clear_hitmaterialid();
  static const int kHitMaterialIDFieldNumber = 10;
  inline ::google::protobuf::uint32 hitmaterialid() const;
  inline void set_hitmaterialid(::google::protobuf::uint32 value);

  // required uint32 hitItem = 11;
  inline bool has_hititem() const;
  inline void clear_hititem();
  static const int kHitItemFieldNumber = 11;
  inline ::google::protobuf::uint32 hititem() const;
  inline void set_hititem(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Attack)
 private:
  inline void set_has_pointstart();
  inline void clear_has_pointstart();
  inline void set_has_pointend();
  inline void clear_has_pointend();
  inline void set_has_hitid();
  inline void clear_has_hitid();
  inline void set_has_hitbone();
  inline void clear_has_hitbone();
  inline void set_has_hitnormallocal();
  inline void clear_has_hitnormallocal();
  inline void set_has_hitpositionlocal();
  inline void clear_has_hitpositionlocal();
  inline void set_has_hitnormalworld();
  inline void clear_has_hitnormalworld();
  inline void set_has_hitpositionworld();
  inline void clear_has_hitpositionworld();
  inline void set_has_hitpartid();
  inline void clear_has_hitpartid();
  inline void set_has_hitmaterialid();
  inline void clear_has_hitmaterialid();
  inline void set_has_hititem();
  inline void clear_has_hititem();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Vector3Serialized* pointstart_;
  ::Vector3Serialized* pointend_;
  ::google::protobuf::uint32 hitid_;
  ::google::protobuf::uint32 hitbone_;
  ::Vector3Serialized* hitnormallocal_;
  ::Vector3Serialized* hitpositionlocal_;
  ::Vector3Serialized* hitnormalworld_;
  ::Vector3Serialized* hitpositionworld_;
  ::google::protobuf::uint32 hitpartid_;
  ::google::protobuf::uint32 hitmaterialid_;
  ::google::protobuf::uint32 hititem_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static Attack* default_instance_;
};
// -------------------------------------------------------------------

class ClientReady_ClientInfo : public ::google::protobuf::Message {
 public:
  ClientReady_ClientInfo();
  virtual ~ClientReady_ClientInfo();

  ClientReady_ClientInfo(const ClientReady_ClientInfo& from);

  inline ClientReady_ClientInfo& operator=(const ClientReady_ClientInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientReady_ClientInfo& default_instance();

  void Swap(ClientReady_ClientInfo* other);

  // implements Message ----------------------------------------------

  ClientReady_ClientInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientReady_ClientInfo& from);
  void MergeFrom(const ClientReady_ClientInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:ClientReady.ClientInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static ClientReady_ClientInfo* default_instance_;
};
// -------------------------------------------------------------------

class ClientReady : public ::google::protobuf::Message {
 public:
  ClientReady();
  virtual ~ClientReady();

  ClientReady(const ClientReady& from);

  inline ClientReady& operator=(const ClientReady& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientReady& default_instance();

  void Swap(ClientReady* other);

  // implements Message ----------------------------------------------

  ClientReady* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientReady& from);
  void MergeFrom(const ClientReady& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ClientReady_ClientInfo ClientInfo;

  // accessors -------------------------------------------------------

  // repeated .ClientReady.ClientInfo clientInfo = 1;
  inline int clientinfo_size() const;
  inline void clear_clientinfo();
  static const int kClientInfoFieldNumber = 1;
  inline const ::ClientReady_ClientInfo& clientinfo(int index) const;
  inline ::ClientReady_ClientInfo* mutable_clientinfo(int index);
  inline ::ClientReady_ClientInfo* add_clientinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::ClientReady_ClientInfo >&
      clientinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::ClientReady_ClientInfo >*
      mutable_clientinfo();

  // @@protoc_insertion_point(class_scope:ClientReady)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::ClientReady_ClientInfo > clientinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static ClientReady* default_instance_;
};
// -------------------------------------------------------------------

class CreateBuilding : public ::google::protobuf::Message {
 public:
  CreateBuilding();
  virtual ~CreateBuilding();

  CreateBuilding(const CreateBuilding& from);

  inline CreateBuilding& operator=(const CreateBuilding& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateBuilding& default_instance();

  void Swap(CreateBuilding* other);

  // implements Message ----------------------------------------------

  CreateBuilding* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateBuilding& from);
  void MergeFrom(const CreateBuilding& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 entity = 1;
  inline bool has_entity() const;
  inline void clear_entity();
  static const int kEntityFieldNumber = 1;
  inline ::google::protobuf::uint32 entity() const;
  inline void set_entity(::google::protobuf::uint32 value);

  // required uint32 socket = 2;
  inline bool has_socket() const;
  inline void clear_socket();
  static const int kSocketFieldNumber = 2;
  inline ::google::protobuf::uint32 socket() const;
  inline void set_socket(::google::protobuf::uint32 value);

  // required bool onterrain = 3;
  inline bool has_onterrain() const;
  inline void clear_onterrain();
  static const int kOnterrainFieldNumber = 3;
  inline bool onterrain() const;
  inline void set_onterrain(bool value);

  // required .Vector3Serialized position = 4;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 4;
  inline const ::Vector3Serialized& position() const;
  inline ::Vector3Serialized* mutable_position();
  inline ::Vector3Serialized* release_position();
  inline void set_allocated_position(::Vector3Serialized* position);

  // required .Vector3Serialized normal = 5;
  inline bool has_normal() const;
  inline void clear_normal();
  static const int kNormalFieldNumber = 5;
  inline const ::Vector3Serialized& normal() const;
  inline ::Vector3Serialized* mutable_normal();
  inline ::Vector3Serialized* release_normal();
  inline void set_allocated_normal(::Vector3Serialized* normal);

  // required .RaySerialized ray = 6;
  inline bool has_ray() const;
  inline void clear_ray();
  static const int kRayFieldNumber = 6;
  inline const ::RaySerialized& ray() const;
  inline ::RaySerialized* mutable_ray();
  inline ::RaySerialized* release_ray();
  inline void set_allocated_ray(::RaySerialized* ray);

  // required uint32 blockID = 7;
  inline bool has_blockid() const;
  inline void clear_blockid();
  static const int kBlockIDFieldNumber = 7;
  inline ::google::protobuf::uint32 blockid() const;
  inline void set_blockid(::google::protobuf::uint32 value);

  // required .Vector3Serialized rotation = 8;
  inline bool has_rotation() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 8;
  inline const ::Vector3Serialized& rotation() const;
  inline ::Vector3Serialized* mutable_rotation();
  inline ::Vector3Serialized* release_rotation();
  inline void set_allocated_rotation(::Vector3Serialized* rotation);

  // @@protoc_insertion_point(class_scope:CreateBuilding)
 private:
  inline void set_has_entity();
  inline void clear_has_entity();
  inline void set_has_socket();
  inline void clear_has_socket();
  inline void set_has_onterrain();
  inline void clear_has_onterrain();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_normal();
  inline void clear_has_normal();
  inline void set_has_ray();
  inline void clear_has_ray();
  inline void set_has_blockid();
  inline void clear_has_blockid();
  inline void set_has_rotation();
  inline void clear_has_rotation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 entity_;
  ::google::protobuf::uint32 socket_;
  ::Vector3Serialized* position_;
  ::Vector3Serialized* normal_;
  bool onterrain_;
  ::google::protobuf::uint32 blockid_;
  ::RaySerialized* ray_;
  ::Vector3Serialized* rotation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static CreateBuilding* default_instance_;
};
// -------------------------------------------------------------------

class EntityList : public ::google::protobuf::Message {
 public:
  EntityList();
  virtual ~EntityList();

  EntityList(const EntityList& from);

  inline EntityList& operator=(const EntityList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityList& default_instance();

  void Swap(EntityList* other);

  // implements Message ----------------------------------------------

  EntityList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EntityList& from);
  void MergeFrom(const EntityList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Entity entity = 1;
  inline int entity_size() const;
  inline void clear_entity();
  static const int kEntityFieldNumber = 1;
  inline const ::Entity& entity(int index) const;
  inline ::Entity* mutable_entity(int index);
  inline ::Entity* add_entity();
  inline const ::google::protobuf::RepeatedPtrField< ::Entity >&
      entity() const;
  inline ::google::protobuf::RepeatedPtrField< ::Entity >*
      mutable_entity();

  // @@protoc_insertion_point(class_scope:EntityList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Entity > entity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static EntityList* default_instance_;
};
// -------------------------------------------------------------------

class ModuleMessage : public ::google::protobuf::Message {
 public:
  ModuleMessage();
  virtual ~ModuleMessage();

  ModuleMessage(const ModuleMessage& from);

  inline ModuleMessage& operator=(const ModuleMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModuleMessage& default_instance();

  void Swap(ModuleMessage* other);

  // implements Message ----------------------------------------------

  ModuleMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModuleMessage& from);
  void MergeFrom(const ModuleMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 itemid = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemidFieldNumber = 1;
  inline ::google::protobuf::uint32 itemid() const;
  inline void set_itemid(::google::protobuf::uint32 value);

  // required uint64 moduleid = 2;
  inline bool has_moduleid() const;
  inline void clear_moduleid();
  static const int kModuleidFieldNumber = 2;
  inline ::google::protobuf::uint64 moduleid() const;
  inline void set_moduleid(::google::protobuf::uint64 value);

  // required uint64 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint64 type() const;
  inline void set_type(::google::protobuf::uint64 value);

  // optional bytes data = 4;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:ModuleMessage)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_moduleid();
  inline void clear_has_moduleid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 moduleid_;
  ::google::protobuf::uint64 type_;
  ::std::string* data_;
  ::google::protobuf::uint32 itemid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static ModuleMessage* default_instance_;
};
// -------------------------------------------------------------------

class PlayerAttack : public ::google::protobuf::Message {
 public:
  PlayerAttack();
  virtual ~PlayerAttack();

  PlayerAttack(const PlayerAttack& from);

  inline PlayerAttack& operator=(const PlayerAttack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerAttack& default_instance();

  void Swap(PlayerAttack* other);

  // implements Message ----------------------------------------------

  PlayerAttack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerAttack& from);
  void MergeFrom(const PlayerAttack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Attack attack = 1;
  inline bool has_attack() const;
  inline void clear_attack();
  static const int kAttackFieldNumber = 1;
  inline const ::Attack& attack() const;
  inline ::Attack* mutable_attack();
  inline ::Attack* release_attack();
  inline void set_allocated_attack(::Attack* attack);

  // required uint64 projectileID = 2;
  inline bool has_projectileid() const;
  inline void clear_projectileid();
  static const int kProjectileIDFieldNumber = 2;
  inline ::google::protobuf::uint64 projectileid() const;
  inline void set_projectileid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:PlayerAttack)
 private:
  inline void set_has_attack();
  inline void clear_has_attack();
  inline void set_has_projectileid();
  inline void clear_has_projectileid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Attack* attack_;
  ::google::protobuf::uint64 projectileid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static PlayerAttack* default_instance_;
};
// -------------------------------------------------------------------

class PlayerProjectileAttack : public ::google::protobuf::Message {
 public:
  PlayerProjectileAttack();
  virtual ~PlayerProjectileAttack();

  PlayerProjectileAttack(const PlayerProjectileAttack& from);

  inline PlayerProjectileAttack& operator=(const PlayerProjectileAttack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerProjectileAttack& default_instance();

  void Swap(PlayerProjectileAttack* other);

  // implements Message ----------------------------------------------

  PlayerProjectileAttack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerProjectileAttack& from);
  void MergeFrom(const PlayerProjectileAttack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .PlayerAttack playerAttack = 1;
  inline bool has_playerattack() const;
  inline void clear_playerattack();
  static const int kPlayerAttackFieldNumber = 1;
  inline const ::PlayerAttack& playerattack() const;
  inline ::PlayerAttack* mutable_playerattack();
  inline ::PlayerAttack* release_playerattack();
  inline void set_allocated_playerattack(::PlayerAttack* playerattack);

  // required .Vector3Serialized hitVelocity = 2;
  inline bool has_hitvelocity() const;
  inline void clear_hitvelocity();
  static const int kHitVelocityFieldNumber = 2;
  inline const ::Vector3Serialized& hitvelocity() const;
  inline ::Vector3Serialized* mutable_hitvelocity();
  inline ::Vector3Serialized* release_hitvelocity();
  inline void set_allocated_hitvelocity(::Vector3Serialized* hitvelocity);

  // required float hitDistance = 3;
  inline bool has_hitdistance() const;
  inline void clear_hitdistance();
  static const int kHitDistanceFieldNumber = 3;
  inline float hitdistance() const;
  inline void set_hitdistance(float value);

  // @@protoc_insertion_point(class_scope:PlayerProjectileAttack)
 private:
  inline void set_has_playerattack();
  inline void clear_has_playerattack();
  inline void set_has_hitvelocity();
  inline void clear_has_hitvelocity();
  inline void set_has_hitdistance();
  inline void clear_has_hitdistance();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::PlayerAttack* playerattack_;
  ::Vector3Serialized* hitvelocity_;
  float hitdistance_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static PlayerProjectileAttack* default_instance_;
};
// -------------------------------------------------------------------

class PlayerProjectileRicochet : public ::google::protobuf::Message {
 public:
  PlayerProjectileRicochet();
  virtual ~PlayerProjectileRicochet();

  PlayerProjectileRicochet(const PlayerProjectileRicochet& from);

  inline PlayerProjectileRicochet& operator=(const PlayerProjectileRicochet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerProjectileRicochet& default_instance();

  void Swap(PlayerProjectileRicochet* other);

  // implements Message ----------------------------------------------

  PlayerProjectileRicochet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerProjectileRicochet& from);
  void MergeFrom(const PlayerProjectileRicochet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 projectileID = 1;
  inline bool has_projectileid() const;
  inline void clear_projectileid();
  static const int kProjectileIDFieldNumber = 1;
  inline ::google::protobuf::uint64 projectileid() const;
  inline void set_projectileid(::google::protobuf::uint64 value);

  // required .Vector3Serialized hitPosition = 2;
  inline bool has_hitposition() const;
  inline void clear_hitposition();
  static const int kHitPositionFieldNumber = 2;
  inline const ::Vector3Serialized& hitposition() const;
  inline ::Vector3Serialized* mutable_hitposition();
  inline ::Vector3Serialized* release_hitposition();
  inline void set_allocated_hitposition(::Vector3Serialized* hitposition);

  // required .Vector3Serialized inVelocity = 3;
  inline bool has_invelocity() const;
  inline void clear_invelocity();
  static const int kInVelocityFieldNumber = 3;
  inline const ::Vector3Serialized& invelocity() const;
  inline ::Vector3Serialized* mutable_invelocity();
  inline ::Vector3Serialized* release_invelocity();
  inline void set_allocated_invelocity(::Vector3Serialized* invelocity);

  // required .Vector3Serialized outVelocity = 4;
  inline bool has_outvelocity() const;
  inline void clear_outvelocity();
  static const int kOutVelocityFieldNumber = 4;
  inline const ::Vector3Serialized& outvelocity() const;
  inline ::Vector3Serialized* mutable_outvelocity();
  inline ::Vector3Serialized* release_outvelocity();
  inline void set_allocated_outvelocity(::Vector3Serialized* outvelocity);

  // @@protoc_insertion_point(class_scope:PlayerProjectileRicochet)
 private:
  inline void set_has_projectileid();
  inline void clear_has_projectileid();
  inline void set_has_hitposition();
  inline void clear_has_hitposition();
  inline void set_has_invelocity();
  inline void clear_has_invelocity();
  inline void set_has_outvelocity();
  inline void clear_has_outvelocity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 projectileid_;
  ::Vector3Serialized* hitposition_;
  ::Vector3Serialized* invelocity_;
  ::Vector3Serialized* outvelocity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static PlayerProjectileRicochet* default_instance_;
};
// -------------------------------------------------------------------

class PlayerProjectileUpdate : public ::google::protobuf::Message {
 public:
  PlayerProjectileUpdate();
  virtual ~PlayerProjectileUpdate();

  PlayerProjectileUpdate(const PlayerProjectileUpdate& from);

  inline PlayerProjectileUpdate& operator=(const PlayerProjectileUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerProjectileUpdate& default_instance();

  void Swap(PlayerProjectileUpdate* other);

  // implements Message ----------------------------------------------

  PlayerProjectileUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerProjectileUpdate& from);
  void MergeFrom(const PlayerProjectileUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 projectileID = 1;
  inline bool has_projectileid() const;
  inline void clear_projectileid();
  static const int kProjectileIDFieldNumber = 1;
  inline ::google::protobuf::uint64 projectileid() const;
  inline void set_projectileid(::google::protobuf::uint64 value);

  // required .Vector3Serialized curPosition = 2;
  inline bool has_curposition() const;
  inline void clear_curposition();
  static const int kCurPositionFieldNumber = 2;
  inline const ::Vector3Serialized& curposition() const;
  inline ::Vector3Serialized* mutable_curposition();
  inline ::Vector3Serialized* release_curposition();
  inline void set_allocated_curposition(::Vector3Serialized* curposition);

  // @@protoc_insertion_point(class_scope:PlayerProjectileUpdate)
 private:
  inline void set_has_projectileid();
  inline void clear_has_projectileid();
  inline void set_has_curposition();
  inline void clear_has_curposition();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 projectileid_;
  ::Vector3Serialized* curposition_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static PlayerProjectileUpdate* default_instance_;
};
// -------------------------------------------------------------------

class PlayerUpdateLoot : public ::google::protobuf::Message {
 public:
  PlayerUpdateLoot();
  virtual ~PlayerUpdateLoot();

  PlayerUpdateLoot(const PlayerUpdateLoot& from);

  inline PlayerUpdateLoot& operator=(const PlayerUpdateLoot& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerUpdateLoot& default_instance();

  void Swap(PlayerUpdateLoot* other);

  // implements Message ----------------------------------------------

  PlayerUpdateLoot* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerUpdateLoot& from);
  void MergeFrom(const PlayerUpdateLoot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 itemID = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIDFieldNumber = 1;
  inline ::google::protobuf::uint32 itemid() const;
  inline void set_itemid(::google::protobuf::uint32 value);

  // required uint32 entityID = 2;
  inline bool has_entityid() const;
  inline void clear_entityid();
  static const int kEntityIDFieldNumber = 2;
  inline ::google::protobuf::uint32 entityid() const;
  inline void set_entityid(::google::protobuf::uint32 value);

  // repeated .ItemContainer containers = 3;
  inline int containers_size() const;
  inline void clear_containers();
  static const int kContainersFieldNumber = 3;
  inline const ::ItemContainer& containers(int index) const;
  inline ::ItemContainer* mutable_containers(int index);
  inline ::ItemContainer* add_containers();
  inline const ::google::protobuf::RepeatedPtrField< ::ItemContainer >&
      containers() const;
  inline ::google::protobuf::RepeatedPtrField< ::ItemContainer >*
      mutable_containers();

  // @@protoc_insertion_point(class_scope:PlayerUpdateLoot)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_entityid();
  inline void clear_has_entityid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 itemid_;
  ::google::protobuf::uint32 entityid_;
  ::google::protobuf::RepeatedPtrField< ::ItemContainer > containers_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static PlayerUpdateLoot* default_instance_;
};
// -------------------------------------------------------------------

class ProjectileShoot_Projectile : public ::google::protobuf::Message {
 public:
  ProjectileShoot_Projectile();
  virtual ~ProjectileShoot_Projectile();

  ProjectileShoot_Projectile(const ProjectileShoot_Projectile& from);

  inline ProjectileShoot_Projectile& operator=(const ProjectileShoot_Projectile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProjectileShoot_Projectile& default_instance();

  void Swap(ProjectileShoot_Projectile* other);

  // implements Message ----------------------------------------------

  ProjectileShoot_Projectile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProjectileShoot_Projectile& from);
  void MergeFrom(const ProjectileShoot_Projectile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 projectileID = 1;
  inline bool has_projectileid() const;
  inline void clear_projectileid();
  static const int kProjectileIDFieldNumber = 1;
  inline ::google::protobuf::uint64 projectileid() const;
  inline void set_projectileid(::google::protobuf::uint64 value);

  // required .Vector3Serialized startPos = 2;
  inline bool has_startpos() const;
  inline void clear_startpos();
  static const int kStartPosFieldNumber = 2;
  inline const ::Vector3Serialized& startpos() const;
  inline ::Vector3Serialized* mutable_startpos();
  inline ::Vector3Serialized* release_startpos();
  inline void set_allocated_startpos(::Vector3Serialized* startpos);

  // required .Vector3Serialized startVel = 3;
  inline bool has_startvel() const;
  inline void clear_startvel();
  static const int kStartVelFieldNumber = 3;
  inline const ::Vector3Serialized& startvel() const;
  inline ::Vector3Serialized* mutable_startvel();
  inline ::Vector3Serialized* release_startvel();
  inline void set_allocated_startvel(::Vector3Serialized* startvel);

  // required uint64 seed = 4;
  inline bool has_seed() const;
  inline void clear_seed();
  static const int kSeedFieldNumber = 4;
  inline ::google::protobuf::uint64 seed() const;
  inline void set_seed(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ProjectileShoot.Projectile)
 private:
  inline void set_has_projectileid();
  inline void clear_has_projectileid();
  inline void set_has_startpos();
  inline void clear_has_startpos();
  inline void set_has_startvel();
  inline void clear_has_startvel();
  inline void set_has_seed();
  inline void clear_has_seed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 projectileid_;
  ::Vector3Serialized* startpos_;
  ::Vector3Serialized* startvel_;
  ::google::protobuf::uint64 seed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static ProjectileShoot_Projectile* default_instance_;
};
// -------------------------------------------------------------------

class ProjectileShoot : public ::google::protobuf::Message {
 public:
  ProjectileShoot();
  virtual ~ProjectileShoot();

  ProjectileShoot(const ProjectileShoot& from);

  inline ProjectileShoot& operator=(const ProjectileShoot& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProjectileShoot& default_instance();

  void Swap(ProjectileShoot* other);

  // implements Message ----------------------------------------------

  ProjectileShoot* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProjectileShoot& from);
  void MergeFrom(const ProjectileShoot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ProjectileShoot_Projectile Projectile;

  // accessors -------------------------------------------------------

  // required uint64 ammoType = 1;
  inline bool has_ammotype() const;
  inline void clear_ammotype();
  static const int kAmmoTypeFieldNumber = 1;
  inline ::google::protobuf::uint64 ammotype() const;
  inline void set_ammotype(::google::protobuf::uint64 value);

  // repeated .ProjectileShoot.Projectile projectiles = 2;
  inline int projectiles_size() const;
  inline void clear_projectiles();
  static const int kProjectilesFieldNumber = 2;
  inline const ::ProjectileShoot_Projectile& projectiles(int index) const;
  inline ::ProjectileShoot_Projectile* mutable_projectiles(int index);
  inline ::ProjectileShoot_Projectile* add_projectiles();
  inline const ::google::protobuf::RepeatedPtrField< ::ProjectileShoot_Projectile >&
      projectiles() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProjectileShoot_Projectile >*
      mutable_projectiles();

  // @@protoc_insertion_point(class_scope:ProjectileShoot)
 private:
  inline void set_has_ammotype();
  inline void clear_has_ammotype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 ammotype_;
  ::google::protobuf::RepeatedPtrField< ::ProjectileShoot_Projectile > projectiles_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static ProjectileShoot* default_instance_;
};
// -------------------------------------------------------------------

class RespawnInformation_SpawnOptions : public ::google::protobuf::Message {
 public:
  RespawnInformation_SpawnOptions();
  virtual ~RespawnInformation_SpawnOptions();

  RespawnInformation_SpawnOptions(const RespawnInformation_SpawnOptions& from);

  inline RespawnInformation_SpawnOptions& operator=(const RespawnInformation_SpawnOptions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RespawnInformation_SpawnOptions& default_instance();

  void Swap(RespawnInformation_SpawnOptions* other);

  // implements Message ----------------------------------------------

  RespawnInformation_SpawnOptions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RespawnInformation_SpawnOptions& from);
  void MergeFrom(const RespawnInformation_SpawnOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RespawnInformation_SpawnOptions_RespawnType RespawnType;
  static const RespawnType SleepingBag = RespawnInformation_SpawnOptions_RespawnType_SleepingBag;
  static const RespawnType Bed = RespawnInformation_SpawnOptions_RespawnType_Bed;
  static inline bool RespawnType_IsValid(int value) {
    return RespawnInformation_SpawnOptions_RespawnType_IsValid(value);
  }
  static const RespawnType RespawnType_MIN =
    RespawnInformation_SpawnOptions_RespawnType_RespawnType_MIN;
  static const RespawnType RespawnType_MAX =
    RespawnInformation_SpawnOptions_RespawnType_RespawnType_MAX;
  static const int RespawnType_ARRAYSIZE =
    RespawnInformation_SpawnOptions_RespawnType_RespawnType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RespawnType_descriptor() {
    return RespawnInformation_SpawnOptions_RespawnType_descriptor();
  }
  static inline const ::std::string& RespawnType_Name(RespawnType value) {
    return RespawnInformation_SpawnOptions_RespawnType_Name(value);
  }
  static inline bool RespawnType_Parse(const ::std::string& name,
      RespawnType* value) {
    return RespawnInformation_SpawnOptions_RespawnType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .RespawnInformation.SpawnOptions.RespawnType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::RespawnInformation_SpawnOptions_RespawnType type() const;
  inline void set_type(::RespawnInformation_SpawnOptions_RespawnType value);

  // required uint32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required float unlockSeconds = 4;
  inline bool has_unlockseconds() const;
  inline void clear_unlockseconds();
  static const int kUnlockSecondsFieldNumber = 4;
  inline float unlockseconds() const;
  inline void set_unlockseconds(float value);

  // @@protoc_insertion_point(class_scope:RespawnInformation.SpawnOptions)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_unlockseconds();
  inline void clear_has_unlockseconds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::uint32 id_;
  ::std::string* name_;
  float unlockseconds_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static RespawnInformation_SpawnOptions* default_instance_;
};
// -------------------------------------------------------------------

class RespawnInformation : public ::google::protobuf::Message {
 public:
  RespawnInformation();
  virtual ~RespawnInformation();

  RespawnInformation(const RespawnInformation& from);

  inline RespawnInformation& operator=(const RespawnInformation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RespawnInformation& default_instance();

  void Swap(RespawnInformation* other);

  // implements Message ----------------------------------------------

  RespawnInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RespawnInformation& from);
  void MergeFrom(const RespawnInformation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RespawnInformation_SpawnOptions SpawnOptions;

  // accessors -------------------------------------------------------

  // repeated .RespawnInformation.SpawnOptions spawnOptions = 1;
  inline int spawnoptions_size() const;
  inline void clear_spawnoptions();
  static const int kSpawnOptionsFieldNumber = 1;
  inline const ::RespawnInformation_SpawnOptions& spawnoptions(int index) const;
  inline ::RespawnInformation_SpawnOptions* mutable_spawnoptions(int index);
  inline ::RespawnInformation_SpawnOptions* add_spawnoptions();
  inline const ::google::protobuf::RepeatedPtrField< ::RespawnInformation_SpawnOptions >&
      spawnoptions() const;
  inline ::google::protobuf::RepeatedPtrField< ::RespawnInformation_SpawnOptions >*
      mutable_spawnoptions();

  // optional .PlayerLifeStory previousLife = 2;
  inline bool has_previouslife() const;
  inline void clear_previouslife();
  static const int kPreviousLifeFieldNumber = 2;
  inline const ::PlayerLifeStory& previouslife() const;
  inline ::PlayerLifeStory* mutable_previouslife();
  inline ::PlayerLifeStory* release_previouslife();
  inline void set_allocated_previouslife(::PlayerLifeStory* previouslife);

  // required bool fadeIn = 3;
  inline bool has_fadein() const;
  inline void clear_fadein();
  static const int kFadeInFieldNumber = 3;
  inline bool fadein() const;
  inline void set_fadein(bool value);

  // @@protoc_insertion_point(class_scope:RespawnInformation)
 private:
  inline void set_has_previouslife();
  inline void clear_has_previouslife();
  inline void set_has_fadein();
  inline void clear_has_fadein();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::RespawnInformation_SpawnOptions > spawnoptions_;
  ::PlayerLifeStory* previouslife_;
  bool fadein_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static RespawnInformation* default_instance_;
};
// -------------------------------------------------------------------

class TakeDamage : public ::google::protobuf::Message {
 public:
  TakeDamage();
  virtual ~TakeDamage();

  TakeDamage(const TakeDamage& from);

  inline TakeDamage& operator=(const TakeDamage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TakeDamage& default_instance();

  void Swap(TakeDamage* other);

  // implements Message ----------------------------------------------

  TakeDamage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TakeDamage& from);
  void MergeFrom(const TakeDamage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float amount = 1;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 1;
  inline float amount() const;
  inline void set_amount(float value);

  // required .Vector3Serialized direction = 2;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 2;
  inline const ::Vector3Serialized& direction() const;
  inline ::Vector3Serialized* mutable_direction();
  inline ::Vector3Serialized* release_direction();
  inline void set_allocated_direction(::Vector3Serialized* direction);

  // required uint64 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint64 type() const;
  inline void set_type(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:TakeDamage)
 private:
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Vector3Serialized* direction_;
  ::google::protobuf::uint64 type_;
  float amount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static TakeDamage* default_instance_;
};
// -------------------------------------------------------------------

class UpdateItem : public ::google::protobuf::Message {
 public:
  UpdateItem();
  virtual ~UpdateItem();

  UpdateItem(const UpdateItem& from);

  inline UpdateItem& operator=(const UpdateItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateItem& default_instance();

  void Swap(UpdateItem* other);

  // implements Message ----------------------------------------------

  UpdateItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateItem& from);
  void MergeFrom(const UpdateItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Item item = 1;
  inline bool has_item() const;
  inline void clear_item();
  static const int kItemFieldNumber = 1;
  inline const ::Item& item() const;
  inline ::Item* mutable_item();
  inline ::Item* release_item();
  inline void set_allocated_item(::Item* item);

  // @@protoc_insertion_point(class_scope:UpdateItem)
 private:
  inline void set_has_item();
  inline void clear_has_item();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Item* item_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static UpdateItem* default_instance_;
};
// -------------------------------------------------------------------

class UpdateItemContainer : public ::google::protobuf::Message {
 public:
  UpdateItemContainer();
  virtual ~UpdateItemContainer();

  UpdateItemContainer(const UpdateItemContainer& from);

  inline UpdateItemContainer& operator=(const UpdateItemContainer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateItemContainer& default_instance();

  void Swap(UpdateItemContainer* other);

  // implements Message ----------------------------------------------

  UpdateItemContainer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateItemContainer& from);
  void MergeFrom(const UpdateItemContainer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint64 type() const;
  inline void set_type(::google::protobuf::uint64 value);

  // repeated .ItemContainer container = 2;
  inline int container_size() const;
  inline void clear_container();
  static const int kContainerFieldNumber = 2;
  inline const ::ItemContainer& container(int index) const;
  inline ::ItemContainer* mutable_container(int index);
  inline ::ItemContainer* add_container();
  inline const ::google::protobuf::RepeatedPtrField< ::ItemContainer >&
      container() const;
  inline ::google::protobuf::RepeatedPtrField< ::ItemContainer >*
      mutable_container();

  // @@protoc_insertion_point(class_scope:UpdateItemContainer)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 type_;
  ::google::protobuf::RepeatedPtrField< ::ItemContainer > container_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_main_2eproto();
  friend void protobuf_AssignDesc_main_2eproto();
  friend void protobuf_ShutdownFile_main_2eproto();

  void InitAsDefaultInstance();
  static UpdateItemContainer* default_instance_;
};
// ===================================================================


// ===================================================================

// Vector3Serialized

// required float x = 1;
inline bool Vector3Serialized::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector3Serialized::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector3Serialized::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector3Serialized::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Vector3Serialized::x() const {
  return x_;
}
inline void Vector3Serialized::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 2;
inline bool Vector3Serialized::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector3Serialized::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector3Serialized::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector3Serialized::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Vector3Serialized::y() const {
  return y_;
}
inline void Vector3Serialized::set_y(float value) {
  set_has_y();
  y_ = value;
}

// required float z = 3;
inline bool Vector3Serialized::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector3Serialized::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector3Serialized::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector3Serialized::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Vector3Serialized::z() const {
  return z_;
}
inline void Vector3Serialized::set_z(float value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// RaySerialized

// required .Vector3Serialized origin = 1;
inline bool RaySerialized::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RaySerialized::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RaySerialized::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RaySerialized::clear_origin() {
  if (origin_ != NULL) origin_->::Vector3Serialized::Clear();
  clear_has_origin();
}
inline const ::Vector3Serialized& RaySerialized::origin() const {
  return origin_ != NULL ? *origin_ : *default_instance_->origin_;
}
inline ::Vector3Serialized* RaySerialized::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) origin_ = new ::Vector3Serialized;
  return origin_;
}
inline ::Vector3Serialized* RaySerialized::release_origin() {
  clear_has_origin();
  ::Vector3Serialized* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline void RaySerialized::set_allocated_origin(::Vector3Serialized* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
}

// required .Vector3Serialized direction = 2;
inline bool RaySerialized::has_direction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RaySerialized::set_has_direction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RaySerialized::clear_has_direction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RaySerialized::clear_direction() {
  if (direction_ != NULL) direction_->::Vector3Serialized::Clear();
  clear_has_direction();
}
inline const ::Vector3Serialized& RaySerialized::direction() const {
  return direction_ != NULL ? *direction_ : *default_instance_->direction_;
}
inline ::Vector3Serialized* RaySerialized::mutable_direction() {
  set_has_direction();
  if (direction_ == NULL) direction_ = new ::Vector3Serialized;
  return direction_;
}
inline ::Vector3Serialized* RaySerialized::release_direction() {
  clear_has_direction();
  ::Vector3Serialized* temp = direction_;
  direction_ = NULL;
  return temp;
}
inline void RaySerialized::set_allocated_direction(::Vector3Serialized* direction) {
  delete direction_;
  direction_ = direction;
  if (direction) {
    set_has_direction();
  } else {
    clear_has_direction();
  }
}

// -------------------------------------------------------------------

// BaseNetworkable

// required uint32 uid = 1;
inline bool BaseNetworkable::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BaseNetworkable::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BaseNetworkable::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BaseNetworkable::clear_uid() {
  uid_ = 0u;
  clear_has_uid();
}
inline ::google::protobuf::uint32 BaseNetworkable::uid() const {
  return uid_;
}
inline void BaseNetworkable::set_uid(::google::protobuf::uint32 value) {
  set_has_uid();
  uid_ = value;
}

// required uint32 group = 2;
inline bool BaseNetworkable::has_group() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BaseNetworkable::set_has_group() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BaseNetworkable::clear_has_group() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BaseNetworkable::clear_group() {
  group_ = 0u;
  clear_has_group();
}
inline ::google::protobuf::uint32 BaseNetworkable::group() const {
  return group_;
}
inline void BaseNetworkable::set_group(::google::protobuf::uint32 value) {
  set_has_group();
  group_ = value;
}

// required uint32 prefabID = 3;
inline bool BaseNetworkable::has_prefabid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BaseNetworkable::set_has_prefabid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BaseNetworkable::clear_has_prefabid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BaseNetworkable::clear_prefabid() {
  prefabid_ = 0u;
  clear_has_prefabid();
}
inline ::google::protobuf::uint32 BaseNetworkable::prefabid() const {
  return prefabid_;
}
inline void BaseNetworkable::set_prefabid(::google::protobuf::uint32 value) {
  set_has_prefabid();
  prefabid_ = value;
}

// -------------------------------------------------------------------

// BaseEntity

// required .Vector3Serialized pos = 1;
inline bool BaseEntity::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BaseEntity::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BaseEntity::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BaseEntity::clear_pos() {
  if (pos_ != NULL) pos_->::Vector3Serialized::Clear();
  clear_has_pos();
}
inline const ::Vector3Serialized& BaseEntity::pos() const {
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::Vector3Serialized* BaseEntity::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::Vector3Serialized;
  return pos_;
}
inline ::Vector3Serialized* BaseEntity::release_pos() {
  clear_has_pos();
  ::Vector3Serialized* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void BaseEntity::set_allocated_pos(::Vector3Serialized* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
}

// required .Vector3Serialized rot = 2;
inline bool BaseEntity::has_rot() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BaseEntity::set_has_rot() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BaseEntity::clear_has_rot() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BaseEntity::clear_rot() {
  if (rot_ != NULL) rot_->::Vector3Serialized::Clear();
  clear_has_rot();
}
inline const ::Vector3Serialized& BaseEntity::rot() const {
  return rot_ != NULL ? *rot_ : *default_instance_->rot_;
}
inline ::Vector3Serialized* BaseEntity::mutable_rot() {
  set_has_rot();
  if (rot_ == NULL) rot_ = new ::Vector3Serialized;
  return rot_;
}
inline ::Vector3Serialized* BaseEntity::release_rot() {
  clear_has_rot();
  ::Vector3Serialized* temp = rot_;
  rot_ = NULL;
  return temp;
}
inline void BaseEntity::set_allocated_rot(::Vector3Serialized* rot) {
  delete rot_;
  rot_ = rot;
  if (rot) {
    set_has_rot();
  } else {
    clear_has_rot();
  }
}

// required uint64 flags = 3;
inline bool BaseEntity::has_flags() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BaseEntity::set_has_flags() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BaseEntity::clear_has_flags() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BaseEntity::clear_flags() {
  flags_ = GOOGLE_ULONGLONG(0);
  clear_has_flags();
}
inline ::google::protobuf::uint64 BaseEntity::flags() const {
  return flags_;
}
inline void BaseEntity::set_flags(::google::protobuf::uint64 value) {
  set_has_flags();
  flags_ = value;
}

// optional uint64 skinid = 4;
inline bool BaseEntity::has_skinid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BaseEntity::set_has_skinid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BaseEntity::clear_has_skinid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BaseEntity::clear_skinid() {
  skinid_ = GOOGLE_ULONGLONG(0);
  clear_has_skinid();
}
inline ::google::protobuf::uint64 BaseEntity::skinid() const {
  return skinid_;
}
inline void BaseEntity::set_skinid(::google::protobuf::uint64 value) {
  set_has_skinid();
  skinid_ = value;
}

// -------------------------------------------------------------------

// Item_InstanceData

// required uint64 dataInt = 1;
inline bool Item_InstanceData::has_dataint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Item_InstanceData::set_has_dataint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Item_InstanceData::clear_has_dataint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Item_InstanceData::clear_dataint() {
  dataint_ = GOOGLE_ULONGLONG(0);
  clear_has_dataint();
}
inline ::google::protobuf::uint64 Item_InstanceData::dataint() const {
  return dataint_;
}
inline void Item_InstanceData::set_dataint(::google::protobuf::uint64 value) {
  set_has_dataint();
  dataint_ = value;
}

// required uint64 blueprintTarget = 2;
inline bool Item_InstanceData::has_blueprinttarget() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Item_InstanceData::set_has_blueprinttarget() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Item_InstanceData::clear_has_blueprinttarget() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Item_InstanceData::clear_blueprinttarget() {
  blueprinttarget_ = GOOGLE_ULONGLONG(0);
  clear_has_blueprinttarget();
}
inline ::google::protobuf::uint64 Item_InstanceData::blueprinttarget() const {
  return blueprinttarget_;
}
inline void Item_InstanceData::set_blueprinttarget(::google::protobuf::uint64 value) {
  set_has_blueprinttarget();
  blueprinttarget_ = value;
}

// required uint64 blueprintAmount = 3;
inline bool Item_InstanceData::has_blueprintamount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Item_InstanceData::set_has_blueprintamount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Item_InstanceData::clear_has_blueprintamount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Item_InstanceData::clear_blueprintamount() {
  blueprintamount_ = GOOGLE_ULONGLONG(0);
  clear_has_blueprintamount();
}
inline ::google::protobuf::uint64 Item_InstanceData::blueprintamount() const {
  return blueprintamount_;
}
inline void Item_InstanceData::set_blueprintamount(::google::protobuf::uint64 value) {
  set_has_blueprintamount();
  blueprintamount_ = value;
}

// -------------------------------------------------------------------

// Item_ConditionData

// required float condition = 1;
inline bool Item_ConditionData::has_condition() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Item_ConditionData::set_has_condition() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Item_ConditionData::clear_has_condition() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Item_ConditionData::clear_condition() {
  condition_ = 0;
  clear_has_condition();
}
inline float Item_ConditionData::condition() const {
  return condition_;
}
inline void Item_ConditionData::set_condition(float value) {
  set_has_condition();
  condition_ = value;
}

// required float maxCondition = 2;
inline bool Item_ConditionData::has_maxcondition() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Item_ConditionData::set_has_maxcondition() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Item_ConditionData::clear_has_maxcondition() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Item_ConditionData::clear_maxcondition() {
  maxcondition_ = 0;
  clear_has_maxcondition();
}
inline float Item_ConditionData::maxcondition() const {
  return maxcondition_;
}
inline void Item_ConditionData::set_maxcondition(float value) {
  set_has_maxcondition();
  maxcondition_ = value;
}

// -------------------------------------------------------------------

// Item

// required uint32 UID = 1;
inline bool Item::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Item::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Item::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Item::clear_uid() {
  uid_ = 0u;
  clear_has_uid();
}
inline ::google::protobuf::uint32 Item::uid() const {
  return uid_;
}
inline void Item::set_uid(::google::protobuf::uint32 value) {
  set_has_uid();
  uid_ = value;
}

// required uint64 itemid = 2;
inline bool Item::has_itemid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Item::set_has_itemid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Item::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Item::clear_itemid() {
  itemid_ = GOOGLE_ULONGLONG(0);
  clear_has_itemid();
}
inline ::google::protobuf::uint64 Item::itemid() const {
  return itemid_;
}
inline void Item::set_itemid(::google::protobuf::uint64 value) {
  set_has_itemid();
  itemid_ = value;
}

// required uint64 slot = 3;
inline bool Item::has_slot() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Item::set_has_slot() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Item::clear_has_slot() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Item::clear_slot() {
  slot_ = GOOGLE_ULONGLONG(0);
  clear_has_slot();
}
inline ::google::protobuf::uint64 Item::slot() const {
  return slot_;
}
inline void Item::set_slot(::google::protobuf::uint64 value) {
  set_has_slot();
  slot_ = value;
}

// required uint64 amount = 4;
inline bool Item::has_amount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Item::set_has_amount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Item::clear_has_amount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Item::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 Item::amount() const {
  return amount_;
}
inline void Item::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// required uint64 flags = 5;
inline bool Item::has_flags() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Item::set_has_flags() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Item::clear_has_flags() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Item::clear_flags() {
  flags_ = GOOGLE_ULONGLONG(0);
  clear_has_flags();
}
inline ::google::protobuf::uint64 Item::flags() const {
  return flags_;
}
inline void Item::set_flags(::google::protobuf::uint64 value) {
  set_has_flags();
  flags_ = value;
}

// required float removetime = 6;
inline bool Item::has_removetime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Item::set_has_removetime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Item::clear_has_removetime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Item::clear_removetime() {
  removetime_ = 0;
  clear_has_removetime();
}
inline float Item::removetime() const {
  return removetime_;
}
inline void Item::set_removetime(float value) {
  set_has_removetime();
  removetime_ = value;
}

// required float locktime = 7;
inline bool Item::has_locktime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Item::set_has_locktime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Item::clear_has_locktime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Item::clear_locktime() {
  locktime_ = 0;
  clear_has_locktime();
}
inline float Item::locktime() const {
  return locktime_;
}
inline void Item::set_locktime(float value) {
  set_has_locktime();
  locktime_ = value;
}

// required uint32 worldEntity = 8;
inline bool Item::has_worldentity() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Item::set_has_worldentity() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Item::clear_has_worldentity() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Item::clear_worldentity() {
  worldentity_ = 0u;
  clear_has_worldentity();
}
inline ::google::protobuf::uint32 Item::worldentity() const {
  return worldentity_;
}
inline void Item::set_worldentity(::google::protobuf::uint32 value) {
  set_has_worldentity();
  worldentity_ = value;
}

// optional .Item.InstanceData instanceData = 9;
inline bool Item::has_instancedata() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Item::set_has_instancedata() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Item::clear_has_instancedata() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Item::clear_instancedata() {
  if (instancedata_ != NULL) instancedata_->::Item_InstanceData::Clear();
  clear_has_instancedata();
}
inline const ::Item_InstanceData& Item::instancedata() const {
  return instancedata_ != NULL ? *instancedata_ : *default_instance_->instancedata_;
}
inline ::Item_InstanceData* Item::mutable_instancedata() {
  set_has_instancedata();
  if (instancedata_ == NULL) instancedata_ = new ::Item_InstanceData;
  return instancedata_;
}
inline ::Item_InstanceData* Item::release_instancedata() {
  clear_has_instancedata();
  ::Item_InstanceData* temp = instancedata_;
  instancedata_ = NULL;
  return temp;
}
inline void Item::set_allocated_instancedata(::Item_InstanceData* instancedata) {
  delete instancedata_;
  instancedata_ = instancedata;
  if (instancedata) {
    set_has_instancedata();
  } else {
    clear_has_instancedata();
  }
}

// required uint32 heldEntity = 10;
inline bool Item::has_heldentity() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Item::set_has_heldentity() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Item::clear_has_heldentity() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Item::clear_heldentity() {
  heldentity_ = 0u;
  clear_has_heldentity();
}
inline ::google::protobuf::uint32 Item::heldentity() const {
  return heldentity_;
}
inline void Item::set_heldentity(::google::protobuf::uint32 value) {
  set_has_heldentity();
  heldentity_ = value;
}

// optional .Item.ConditionData conditionData = 11;
inline bool Item::has_conditiondata() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Item::set_has_conditiondata() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Item::clear_has_conditiondata() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Item::clear_conditiondata() {
  if (conditiondata_ != NULL) conditiondata_->::Item_ConditionData::Clear();
  clear_has_conditiondata();
}
inline const ::Item_ConditionData& Item::conditiondata() const {
  return conditiondata_ != NULL ? *conditiondata_ : *default_instance_->conditiondata_;
}
inline ::Item_ConditionData* Item::mutable_conditiondata() {
  set_has_conditiondata();
  if (conditiondata_ == NULL) conditiondata_ = new ::Item_ConditionData;
  return conditiondata_;
}
inline ::Item_ConditionData* Item::release_conditiondata() {
  clear_has_conditiondata();
  ::Item_ConditionData* temp = conditiondata_;
  conditiondata_ = NULL;
  return temp;
}
inline void Item::set_allocated_conditiondata(::Item_ConditionData* conditiondata) {
  delete conditiondata_;
  conditiondata_ = conditiondata;
  if (conditiondata) {
    set_has_conditiondata();
  } else {
    clear_has_conditiondata();
  }
}

// optional string name = 14;
inline bool Item::has_name() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Item::set_has_name() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Item::clear_has_name() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Item::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Item::name() const {
  return *name_;
}
inline void Item::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Item::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Item::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Item::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Item::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Item::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string text = 15;
inline bool Item::has_text() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Item::set_has_text() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Item::clear_has_text() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Item::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& Item::text() const {
  return *text_;
}
inline void Item::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Item::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Item::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Item::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* Item::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Item::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 skinid = 16;
inline bool Item::has_skinid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Item::set_has_skinid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Item::clear_has_skinid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Item::clear_skinid() {
  skinid_ = GOOGLE_ULONGLONG(0);
  clear_has_skinid();
}
inline ::google::protobuf::uint64 Item::skinid() const {
  return skinid_;
}
inline void Item::set_skinid(::google::protobuf::uint64 value) {
  set_has_skinid();
  skinid_ = value;
}

// optional .ItemContainer contents = 100;
inline bool Item::has_contents() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Item::set_has_contents() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Item::clear_has_contents() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Item::clear_contents() {
  if (contents_ != NULL) contents_->::ItemContainer::Clear();
  clear_has_contents();
}
inline const ::ItemContainer& Item::contents() const {
  return contents_ != NULL ? *contents_ : *default_instance_->contents_;
}
inline ::ItemContainer* Item::mutable_contents() {
  set_has_contents();
  if (contents_ == NULL) contents_ = new ::ItemContainer;
  return contents_;
}
inline ::ItemContainer* Item::release_contents() {
  clear_has_contents();
  ::ItemContainer* temp = contents_;
  contents_ = NULL;
  return temp;
}
inline void Item::set_allocated_contents(::ItemContainer* contents) {
  delete contents_;
  contents_ = contents;
  if (contents) {
    set_has_contents();
  } else {
    clear_has_contents();
  }
}

// -------------------------------------------------------------------

// ItemContainer

// required uint32 UID = 1;
inline bool ItemContainer::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ItemContainer::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ItemContainer::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ItemContainer::clear_uid() {
  uid_ = 0u;
  clear_has_uid();
}
inline ::google::protobuf::uint32 ItemContainer::uid() const {
  return uid_;
}
inline void ItemContainer::set_uid(::google::protobuf::uint32 value) {
  set_has_uid();
  uid_ = value;
}

// required uint64 slots = 2;
inline bool ItemContainer::has_slots() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ItemContainer::set_has_slots() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ItemContainer::clear_has_slots() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ItemContainer::clear_slots() {
  slots_ = GOOGLE_ULONGLONG(0);
  clear_has_slots();
}
inline ::google::protobuf::uint64 ItemContainer::slots() const {
  return slots_;
}
inline void ItemContainer::set_slots(::google::protobuf::uint64 value) {
  set_has_slots();
  slots_ = value;
}

// required float temperature = 3;
inline bool ItemContainer::has_temperature() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ItemContainer::set_has_temperature() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ItemContainer::clear_has_temperature() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ItemContainer::clear_temperature() {
  temperature_ = 0;
  clear_has_temperature();
}
inline float ItemContainer::temperature() const {
  return temperature_;
}
inline void ItemContainer::set_temperature(float value) {
  set_has_temperature();
  temperature_ = value;
}

// required uint64 flags = 4;
inline bool ItemContainer::has_flags() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ItemContainer::set_has_flags() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ItemContainer::clear_has_flags() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ItemContainer::clear_flags() {
  flags_ = GOOGLE_ULONGLONG(0);
  clear_has_flags();
}
inline ::google::protobuf::uint64 ItemContainer::flags() const {
  return flags_;
}
inline void ItemContainer::set_flags(::google::protobuf::uint64 value) {
  set_has_flags();
  flags_ = value;
}

// required uint64 allowedContents = 5;
inline bool ItemContainer::has_allowedcontents() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ItemContainer::set_has_allowedcontents() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ItemContainer::clear_has_allowedcontents() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ItemContainer::clear_allowedcontents() {
  allowedcontents_ = GOOGLE_ULONGLONG(0);
  clear_has_allowedcontents();
}
inline ::google::protobuf::uint64 ItemContainer::allowedcontents() const {
  return allowedcontents_;
}
inline void ItemContainer::set_allowedcontents(::google::protobuf::uint64 value) {
  set_has_allowedcontents();
  allowedcontents_ = value;
}

// required uint64 maxStackSize = 6;
inline bool ItemContainer::has_maxstacksize() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ItemContainer::set_has_maxstacksize() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ItemContainer::clear_has_maxstacksize() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ItemContainer::clear_maxstacksize() {
  maxstacksize_ = GOOGLE_ULONGLONG(0);
  clear_has_maxstacksize();
}
inline ::google::protobuf::uint64 ItemContainer::maxstacksize() const {
  return maxstacksize_;
}
inline void ItemContainer::set_maxstacksize(::google::protobuf::uint64 value) {
  set_has_maxstacksize();
  maxstacksize_ = value;
}

// required uint64 allowedItem = 7;
inline bool ItemContainer::has_alloweditem() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ItemContainer::set_has_alloweditem() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ItemContainer::clear_has_alloweditem() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ItemContainer::clear_alloweditem() {
  alloweditem_ = GOOGLE_ULONGLONG(0);
  clear_has_alloweditem();
}
inline ::google::protobuf::uint64 ItemContainer::alloweditem() const {
  return alloweditem_;
}
inline void ItemContainer::set_alloweditem(::google::protobuf::uint64 value) {
  set_has_alloweditem();
  alloweditem_ = value;
}

// repeated uint64 availableSlots = 8;
inline int ItemContainer::availableslots_size() const {
  return availableslots_.size();
}
inline void ItemContainer::clear_availableslots() {
  availableslots_.Clear();
}
inline ::google::protobuf::uint64 ItemContainer::availableslots(int index) const {
  return availableslots_.Get(index);
}
inline void ItemContainer::set_availableslots(int index, ::google::protobuf::uint64 value) {
  availableslots_.Set(index, value);
}
inline void ItemContainer::add_availableslots(::google::protobuf::uint64 value) {
  availableslots_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ItemContainer::availableslots() const {
  return availableslots_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ItemContainer::mutable_availableslots() {
  return &availableslots_;
}

// repeated .Item contents = 100;
inline int ItemContainer::contents_size() const {
  return contents_.size();
}
inline void ItemContainer::clear_contents() {
  contents_.Clear();
}
inline const ::Item& ItemContainer::contents(int index) const {
  return contents_.Get(index);
}
inline ::Item* ItemContainer::mutable_contents(int index) {
  return contents_.Mutable(index);
}
inline ::Item* ItemContainer::add_contents() {
  return contents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Item >&
ItemContainer::contents() const {
  return contents_;
}
inline ::google::protobuf::RepeatedPtrField< ::Item >*
ItemContainer::mutable_contents() {
  return &contents_;
}

// -------------------------------------------------------------------

// PlayerInventory

// optional .ItemContainer invMain = 1;
inline bool PlayerInventory::has_invmain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerInventory::set_has_invmain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerInventory::clear_has_invmain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerInventory::clear_invmain() {
  if (invmain_ != NULL) invmain_->::ItemContainer::Clear();
  clear_has_invmain();
}
inline const ::ItemContainer& PlayerInventory::invmain() const {
  return invmain_ != NULL ? *invmain_ : *default_instance_->invmain_;
}
inline ::ItemContainer* PlayerInventory::mutable_invmain() {
  set_has_invmain();
  if (invmain_ == NULL) invmain_ = new ::ItemContainer;
  return invmain_;
}
inline ::ItemContainer* PlayerInventory::release_invmain() {
  clear_has_invmain();
  ::ItemContainer* temp = invmain_;
  invmain_ = NULL;
  return temp;
}
inline void PlayerInventory::set_allocated_invmain(::ItemContainer* invmain) {
  delete invmain_;
  invmain_ = invmain;
  if (invmain) {
    set_has_invmain();
  } else {
    clear_has_invmain();
  }
}

// optional .ItemContainer invBelt = 2;
inline bool PlayerInventory::has_invbelt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerInventory::set_has_invbelt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerInventory::clear_has_invbelt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerInventory::clear_invbelt() {
  if (invbelt_ != NULL) invbelt_->::ItemContainer::Clear();
  clear_has_invbelt();
}
inline const ::ItemContainer& PlayerInventory::invbelt() const {
  return invbelt_ != NULL ? *invbelt_ : *default_instance_->invbelt_;
}
inline ::ItemContainer* PlayerInventory::mutable_invbelt() {
  set_has_invbelt();
  if (invbelt_ == NULL) invbelt_ = new ::ItemContainer;
  return invbelt_;
}
inline ::ItemContainer* PlayerInventory::release_invbelt() {
  clear_has_invbelt();
  ::ItemContainer* temp = invbelt_;
  invbelt_ = NULL;
  return temp;
}
inline void PlayerInventory::set_allocated_invbelt(::ItemContainer* invbelt) {
  delete invbelt_;
  invbelt_ = invbelt;
  if (invbelt) {
    set_has_invbelt();
  } else {
    clear_has_invbelt();
  }
}

// optional .ItemContainer invWear = 4;
inline bool PlayerInventory::has_invwear() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerInventory::set_has_invwear() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerInventory::clear_has_invwear() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerInventory::clear_invwear() {
  if (invwear_ != NULL) invwear_->::ItemContainer::Clear();
  clear_has_invwear();
}
inline const ::ItemContainer& PlayerInventory::invwear() const {
  return invwear_ != NULL ? *invwear_ : *default_instance_->invwear_;
}
inline ::ItemContainer* PlayerInventory::mutable_invwear() {
  set_has_invwear();
  if (invwear_ == NULL) invwear_ = new ::ItemContainer;
  return invwear_;
}
inline ::ItemContainer* PlayerInventory::release_invwear() {
  clear_has_invwear();
  ::ItemContainer* temp = invwear_;
  invwear_ = NULL;
  return temp;
}
inline void PlayerInventory::set_allocated_invwear(::ItemContainer* invwear) {
  delete invwear_;
  invwear_ = invwear;
  if (invwear) {
    set_has_invwear();
  } else {
    clear_has_invwear();
  }
}

// -------------------------------------------------------------------

// PlayerMetabolism

// required float health = 1;
inline bool PlayerMetabolism::has_health() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerMetabolism::set_has_health() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerMetabolism::clear_has_health() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerMetabolism::clear_health() {
  health_ = 0;
  clear_has_health();
}
inline float PlayerMetabolism::health() const {
  return health_;
}
inline void PlayerMetabolism::set_health(float value) {
  set_has_health();
  health_ = value;
}

// required float calories = 2;
inline bool PlayerMetabolism::has_calories() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerMetabolism::set_has_calories() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerMetabolism::clear_has_calories() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerMetabolism::clear_calories() {
  calories_ = 0;
  clear_has_calories();
}
inline float PlayerMetabolism::calories() const {
  return calories_;
}
inline void PlayerMetabolism::set_calories(float value) {
  set_has_calories();
  calories_ = value;
}

// required float hydration = 3;
inline bool PlayerMetabolism::has_hydration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerMetabolism::set_has_hydration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerMetabolism::clear_has_hydration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerMetabolism::clear_hydration() {
  hydration_ = 0;
  clear_has_hydration();
}
inline float PlayerMetabolism::hydration() const {
  return hydration_;
}
inline void PlayerMetabolism::set_hydration(float value) {
  set_has_hydration();
  hydration_ = value;
}

// required float heartrate = 4;
inline bool PlayerMetabolism::has_heartrate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerMetabolism::set_has_heartrate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerMetabolism::clear_has_heartrate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerMetabolism::clear_heartrate() {
  heartrate_ = 0;
  clear_has_heartrate();
}
inline float PlayerMetabolism::heartrate() const {
  return heartrate_;
}
inline void PlayerMetabolism::set_heartrate(float value) {
  set_has_heartrate();
  heartrate_ = value;
}

// required float temperature = 5;
inline bool PlayerMetabolism::has_temperature() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerMetabolism::set_has_temperature() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerMetabolism::clear_has_temperature() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerMetabolism::clear_temperature() {
  temperature_ = 0;
  clear_has_temperature();
}
inline float PlayerMetabolism::temperature() const {
  return temperature_;
}
inline void PlayerMetabolism::set_temperature(float value) {
  set_has_temperature();
  temperature_ = value;
}

// required float poison = 6;
inline bool PlayerMetabolism::has_poison() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlayerMetabolism::set_has_poison() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlayerMetabolism::clear_has_poison() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlayerMetabolism::clear_poison() {
  poison_ = 0;
  clear_has_poison();
}
inline float PlayerMetabolism::poison() const {
  return poison_;
}
inline void PlayerMetabolism::set_poison(float value) {
  set_has_poison();
  poison_ = value;
}

// required float radiation_level = 7;
inline bool PlayerMetabolism::has_radiation_level() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PlayerMetabolism::set_has_radiation_level() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PlayerMetabolism::clear_has_radiation_level() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PlayerMetabolism::clear_radiation_level() {
  radiation_level_ = 0;
  clear_has_radiation_level();
}
inline float PlayerMetabolism::radiation_level() const {
  return radiation_level_;
}
inline void PlayerMetabolism::set_radiation_level(float value) {
  set_has_radiation_level();
  radiation_level_ = value;
}

// required float wetness = 8;
inline bool PlayerMetabolism::has_wetness() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PlayerMetabolism::set_has_wetness() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PlayerMetabolism::clear_has_wetness() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PlayerMetabolism::clear_wetness() {
  wetness_ = 0;
  clear_has_wetness();
}
inline float PlayerMetabolism::wetness() const {
  return wetness_;
}
inline void PlayerMetabolism::set_wetness(float value) {
  set_has_wetness();
  wetness_ = value;
}

// required float dirtyness = 9;
inline bool PlayerMetabolism::has_dirtyness() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PlayerMetabolism::set_has_dirtyness() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PlayerMetabolism::clear_has_dirtyness() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PlayerMetabolism::clear_dirtyness() {
  dirtyness_ = 0;
  clear_has_dirtyness();
}
inline float PlayerMetabolism::dirtyness() const {
  return dirtyness_;
}
inline void PlayerMetabolism::set_dirtyness(float value) {
  set_has_dirtyness();
  dirtyness_ = value;
}

// required float oxygen = 10;
inline bool PlayerMetabolism::has_oxygen() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PlayerMetabolism::set_has_oxygen() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PlayerMetabolism::clear_has_oxygen() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PlayerMetabolism::clear_oxygen() {
  oxygen_ = 0;
  clear_has_oxygen();
}
inline float PlayerMetabolism::oxygen() const {
  return oxygen_;
}
inline void PlayerMetabolism::set_oxygen(float value) {
  set_has_oxygen();
  oxygen_ = value;
}

// required float bleeding = 11;
inline bool PlayerMetabolism::has_bleeding() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PlayerMetabolism::set_has_bleeding() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PlayerMetabolism::clear_has_bleeding() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PlayerMetabolism::clear_bleeding() {
  bleeding_ = 0;
  clear_has_bleeding();
}
inline float PlayerMetabolism::bleeding() const {
  return bleeding_;
}
inline void PlayerMetabolism::set_bleeding(float value) {
  set_has_bleeding();
  bleeding_ = value;
}

// required float radiation_poisoning = 12;
inline bool PlayerMetabolism::has_radiation_poisoning() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PlayerMetabolism::set_has_radiation_poisoning() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PlayerMetabolism::clear_has_radiation_poisoning() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PlayerMetabolism::clear_radiation_poisoning() {
  radiation_poisoning_ = 0;
  clear_has_radiation_poisoning();
}
inline float PlayerMetabolism::radiation_poisoning() const {
  return radiation_poisoning_;
}
inline void PlayerMetabolism::set_radiation_poisoning(float value) {
  set_has_radiation_poisoning();
  radiation_poisoning_ = value;
}

// required float comfort = 13;
inline bool PlayerMetabolism::has_comfort() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PlayerMetabolism::set_has_comfort() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PlayerMetabolism::clear_has_comfort() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PlayerMetabolism::clear_comfort() {
  comfort_ = 0;
  clear_has_comfort();
}
inline float PlayerMetabolism::comfort() const {
  return comfort_;
}
inline void PlayerMetabolism::set_comfort(float value) {
  set_has_comfort();
  comfort_ = value;
}

// required float pending_health = 14;
inline bool PlayerMetabolism::has_pending_health() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PlayerMetabolism::set_has_pending_health() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PlayerMetabolism::clear_has_pending_health() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PlayerMetabolism::clear_pending_health() {
  pending_health_ = 0;
  clear_has_pending_health();
}
inline float PlayerMetabolism::pending_health() const {
  return pending_health_;
}
inline void PlayerMetabolism::set_pending_health(float value) {
  set_has_pending_health();
  pending_health_ = value;
}

// -------------------------------------------------------------------

// ModelState

// required float waterLevel = 4;
inline bool ModelState::has_waterlevel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModelState::set_has_waterlevel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModelState::clear_has_waterlevel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModelState::clear_waterlevel() {
  waterlevel_ = 0;
  clear_has_waterlevel();
}
inline float ModelState::waterlevel() const {
  return waterlevel_;
}
inline void ModelState::set_waterlevel(float value) {
  set_has_waterlevel();
  waterlevel_ = value;
}

// required .Vector3Serialized lookDir = 10;
inline bool ModelState::has_lookdir() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModelState::set_has_lookdir() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModelState::clear_has_lookdir() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModelState::clear_lookdir() {
  if (lookdir_ != NULL) lookdir_->::Vector3Serialized::Clear();
  clear_has_lookdir();
}
inline const ::Vector3Serialized& ModelState::lookdir() const {
  return lookdir_ != NULL ? *lookdir_ : *default_instance_->lookdir_;
}
inline ::Vector3Serialized* ModelState::mutable_lookdir() {
  set_has_lookdir();
  if (lookdir_ == NULL) lookdir_ = new ::Vector3Serialized;
  return lookdir_;
}
inline ::Vector3Serialized* ModelState::release_lookdir() {
  clear_has_lookdir();
  ::Vector3Serialized* temp = lookdir_;
  lookdir_ = NULL;
  return temp;
}
inline void ModelState::set_allocated_lookdir(::Vector3Serialized* lookdir) {
  delete lookdir_;
  lookdir_ = lookdir;
  if (lookdir) {
    set_has_lookdir();
  } else {
    clear_has_lookdir();
  }
}

// required uint64 flags = 11;
inline bool ModelState::has_flags() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModelState::set_has_flags() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModelState::clear_has_flags() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModelState::clear_flags() {
  flags_ = GOOGLE_ULONGLONG(0);
  clear_has_flags();
}
inline ::google::protobuf::uint64 ModelState::flags() const {
  return flags_;
}
inline void ModelState::set_flags(::google::protobuf::uint64 value) {
  set_has_flags();
  flags_ = value;
}

// -------------------------------------------------------------------

// PersistantPlayer

// repeated uint64 unlockedItems = 3;
inline int PersistantPlayer::unlockeditems_size() const {
  return unlockeditems_.size();
}
inline void PersistantPlayer::clear_unlockeditems() {
  unlockeditems_.Clear();
}
inline ::google::protobuf::uint64 PersistantPlayer::unlockeditems(int index) const {
  return unlockeditems_.Get(index);
}
inline void PersistantPlayer::set_unlockeditems(int index, ::google::protobuf::uint64 value) {
  unlockeditems_.Set(index, value);
}
inline void PersistantPlayer::add_unlockeditems(::google::protobuf::uint64 value) {
  unlockeditems_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
PersistantPlayer::unlockeditems() const {
  return unlockeditems_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
PersistantPlayer::mutable_unlockeditems() {
  return &unlockeditems_;
}

// required uint64 protocolVersion = 100;
inline bool PersistantPlayer::has_protocolversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PersistantPlayer::set_has_protocolversion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PersistantPlayer::clear_has_protocolversion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PersistantPlayer::clear_protocolversion() {
  protocolversion_ = GOOGLE_ULONGLONG(0);
  clear_has_protocolversion();
}
inline ::google::protobuf::uint64 PersistantPlayer::protocolversion() const {
  return protocolversion_;
}
inline void PersistantPlayer::set_protocolversion(::google::protobuf::uint64 value) {
  set_has_protocolversion();
  protocolversion_ = value;
}

// -------------------------------------------------------------------

// PlayerLifeStory_DeathInfo

// optional string attackerName = 1;
inline bool PlayerLifeStory_DeathInfo::has_attackername() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerLifeStory_DeathInfo::set_has_attackername() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerLifeStory_DeathInfo::clear_has_attackername() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerLifeStory_DeathInfo::clear_attackername() {
  if (attackername_ != &::google::protobuf::internal::kEmptyString) {
    attackername_->clear();
  }
  clear_has_attackername();
}
inline const ::std::string& PlayerLifeStory_DeathInfo::attackername() const {
  return *attackername_;
}
inline void PlayerLifeStory_DeathInfo::set_attackername(const ::std::string& value) {
  set_has_attackername();
  if (attackername_ == &::google::protobuf::internal::kEmptyString) {
    attackername_ = new ::std::string;
  }
  attackername_->assign(value);
}
inline void PlayerLifeStory_DeathInfo::set_attackername(const char* value) {
  set_has_attackername();
  if (attackername_ == &::google::protobuf::internal::kEmptyString) {
    attackername_ = new ::std::string;
  }
  attackername_->assign(value);
}
inline void PlayerLifeStory_DeathInfo::set_attackername(const char* value, size_t size) {
  set_has_attackername();
  if (attackername_ == &::google::protobuf::internal::kEmptyString) {
    attackername_ = new ::std::string;
  }
  attackername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerLifeStory_DeathInfo::mutable_attackername() {
  set_has_attackername();
  if (attackername_ == &::google::protobuf::internal::kEmptyString) {
    attackername_ = new ::std::string;
  }
  return attackername_;
}
inline ::std::string* PlayerLifeStory_DeathInfo::release_attackername() {
  clear_has_attackername();
  if (attackername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attackername_;
    attackername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerLifeStory_DeathInfo::set_allocated_attackername(::std::string* attackername) {
  if (attackername_ != &::google::protobuf::internal::kEmptyString) {
    delete attackername_;
  }
  if (attackername) {
    set_has_attackername();
    attackername_ = attackername;
  } else {
    clear_has_attackername();
    attackername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 attackerSteamID = 2;
inline bool PlayerLifeStory_DeathInfo::has_attackersteamid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerLifeStory_DeathInfo::set_has_attackersteamid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerLifeStory_DeathInfo::clear_has_attackersteamid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerLifeStory_DeathInfo::clear_attackersteamid() {
  attackersteamid_ = GOOGLE_ULONGLONG(0);
  clear_has_attackersteamid();
}
inline ::google::protobuf::uint64 PlayerLifeStory_DeathInfo::attackersteamid() const {
  return attackersteamid_;
}
inline void PlayerLifeStory_DeathInfo::set_attackersteamid(::google::protobuf::uint64 value) {
  set_has_attackersteamid();
  attackersteamid_ = value;
}

// optional string hitBone = 3;
inline bool PlayerLifeStory_DeathInfo::has_hitbone() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerLifeStory_DeathInfo::set_has_hitbone() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerLifeStory_DeathInfo::clear_has_hitbone() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerLifeStory_DeathInfo::clear_hitbone() {
  if (hitbone_ != &::google::protobuf::internal::kEmptyString) {
    hitbone_->clear();
  }
  clear_has_hitbone();
}
inline const ::std::string& PlayerLifeStory_DeathInfo::hitbone() const {
  return *hitbone_;
}
inline void PlayerLifeStory_DeathInfo::set_hitbone(const ::std::string& value) {
  set_has_hitbone();
  if (hitbone_ == &::google::protobuf::internal::kEmptyString) {
    hitbone_ = new ::std::string;
  }
  hitbone_->assign(value);
}
inline void PlayerLifeStory_DeathInfo::set_hitbone(const char* value) {
  set_has_hitbone();
  if (hitbone_ == &::google::protobuf::internal::kEmptyString) {
    hitbone_ = new ::std::string;
  }
  hitbone_->assign(value);
}
inline void PlayerLifeStory_DeathInfo::set_hitbone(const char* value, size_t size) {
  set_has_hitbone();
  if (hitbone_ == &::google::protobuf::internal::kEmptyString) {
    hitbone_ = new ::std::string;
  }
  hitbone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerLifeStory_DeathInfo::mutable_hitbone() {
  set_has_hitbone();
  if (hitbone_ == &::google::protobuf::internal::kEmptyString) {
    hitbone_ = new ::std::string;
  }
  return hitbone_;
}
inline ::std::string* PlayerLifeStory_DeathInfo::release_hitbone() {
  clear_has_hitbone();
  if (hitbone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hitbone_;
    hitbone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerLifeStory_DeathInfo::set_allocated_hitbone(::std::string* hitbone) {
  if (hitbone_ != &::google::protobuf::internal::kEmptyString) {
    delete hitbone_;
  }
  if (hitbone) {
    set_has_hitbone();
    hitbone_ = hitbone;
  } else {
    clear_has_hitbone();
    hitbone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string inflictorName = 4;
inline bool PlayerLifeStory_DeathInfo::has_inflictorname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerLifeStory_DeathInfo::set_has_inflictorname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerLifeStory_DeathInfo::clear_has_inflictorname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerLifeStory_DeathInfo::clear_inflictorname() {
  if (inflictorname_ != &::google::protobuf::internal::kEmptyString) {
    inflictorname_->clear();
  }
  clear_has_inflictorname();
}
inline const ::std::string& PlayerLifeStory_DeathInfo::inflictorname() const {
  return *inflictorname_;
}
inline void PlayerLifeStory_DeathInfo::set_inflictorname(const ::std::string& value) {
  set_has_inflictorname();
  if (inflictorname_ == &::google::protobuf::internal::kEmptyString) {
    inflictorname_ = new ::std::string;
  }
  inflictorname_->assign(value);
}
inline void PlayerLifeStory_DeathInfo::set_inflictorname(const char* value) {
  set_has_inflictorname();
  if (inflictorname_ == &::google::protobuf::internal::kEmptyString) {
    inflictorname_ = new ::std::string;
  }
  inflictorname_->assign(value);
}
inline void PlayerLifeStory_DeathInfo::set_inflictorname(const char* value, size_t size) {
  set_has_inflictorname();
  if (inflictorname_ == &::google::protobuf::internal::kEmptyString) {
    inflictorname_ = new ::std::string;
  }
  inflictorname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerLifeStory_DeathInfo::mutable_inflictorname() {
  set_has_inflictorname();
  if (inflictorname_ == &::google::protobuf::internal::kEmptyString) {
    inflictorname_ = new ::std::string;
  }
  return inflictorname_;
}
inline ::std::string* PlayerLifeStory_DeathInfo::release_inflictorname() {
  clear_has_inflictorname();
  if (inflictorname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inflictorname_;
    inflictorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerLifeStory_DeathInfo::set_allocated_inflictorname(::std::string* inflictorname) {
  if (inflictorname_ != &::google::protobuf::internal::kEmptyString) {
    delete inflictorname_;
  }
  if (inflictorname) {
    set_has_inflictorname();
    inflictorname_ = inflictorname;
  } else {
    clear_has_inflictorname();
    inflictorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 lastDamageType = 5;
inline bool PlayerLifeStory_DeathInfo::has_lastdamagetype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerLifeStory_DeathInfo::set_has_lastdamagetype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerLifeStory_DeathInfo::clear_has_lastdamagetype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerLifeStory_DeathInfo::clear_lastdamagetype() {
  lastdamagetype_ = GOOGLE_ULONGLONG(0);
  clear_has_lastdamagetype();
}
inline ::google::protobuf::uint64 PlayerLifeStory_DeathInfo::lastdamagetype() const {
  return lastdamagetype_;
}
inline void PlayerLifeStory_DeathInfo::set_lastdamagetype(::google::protobuf::uint64 value) {
  set_has_lastdamagetype();
  lastdamagetype_ = value;
}

// -------------------------------------------------------------------

// PlayerLifeStory

// required float secondsAlive = 100;
inline bool PlayerLifeStory::has_secondsalive() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerLifeStory::set_has_secondsalive() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerLifeStory::clear_has_secondsalive() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerLifeStory::clear_secondsalive() {
  secondsalive_ = 0;
  clear_has_secondsalive();
}
inline float PlayerLifeStory::secondsalive() const {
  return secondsalive_;
}
inline void PlayerLifeStory::set_secondsalive(float value) {
  set_has_secondsalive();
  secondsalive_ = value;
}

// required float metersWalked = 101;
inline bool PlayerLifeStory::has_meterswalked() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerLifeStory::set_has_meterswalked() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerLifeStory::clear_has_meterswalked() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerLifeStory::clear_meterswalked() {
  meterswalked_ = 0;
  clear_has_meterswalked();
}
inline float PlayerLifeStory::meterswalked() const {
  return meterswalked_;
}
inline void PlayerLifeStory::set_meterswalked(float value) {
  set_has_meterswalked();
  meterswalked_ = value;
}

// required float metersRun = 102;
inline bool PlayerLifeStory::has_metersrun() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerLifeStory::set_has_metersrun() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerLifeStory::clear_has_metersrun() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerLifeStory::clear_metersrun() {
  metersrun_ = 0;
  clear_has_metersrun();
}
inline float PlayerLifeStory::metersrun() const {
  return metersrun_;
}
inline void PlayerLifeStory::set_metersrun(float value) {
  set_has_metersrun();
  metersrun_ = value;
}

// required float secondsSleeping = 103;
inline bool PlayerLifeStory::has_secondssleeping() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerLifeStory::set_has_secondssleeping() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerLifeStory::clear_has_secondssleeping() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerLifeStory::clear_secondssleeping() {
  secondssleeping_ = 0;
  clear_has_secondssleeping();
}
inline float PlayerLifeStory::secondssleeping() const {
  return secondssleeping_;
}
inline void PlayerLifeStory::set_secondssleeping(float value) {
  set_has_secondssleeping();
  secondssleeping_ = value;
}

// required uint32 timeBorn = 104;
inline bool PlayerLifeStory::has_timeborn() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerLifeStory::set_has_timeborn() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerLifeStory::clear_has_timeborn() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerLifeStory::clear_timeborn() {
  timeborn_ = 0u;
  clear_has_timeborn();
}
inline ::google::protobuf::uint32 PlayerLifeStory::timeborn() const {
  return timeborn_;
}
inline void PlayerLifeStory::set_timeborn(::google::protobuf::uint32 value) {
  set_has_timeborn();
  timeborn_ = value;
}

// required uint32 timeDead = 105;
inline bool PlayerLifeStory::has_timedead() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlayerLifeStory::set_has_timedead() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlayerLifeStory::clear_has_timedead() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlayerLifeStory::clear_timedead() {
  timedead_ = 0u;
  clear_has_timedead();
}
inline ::google::protobuf::uint32 PlayerLifeStory::timedead() const {
  return timedead_;
}
inline void PlayerLifeStory::set_timedead(::google::protobuf::uint32 value) {
  set_has_timedead();
  timedead_ = value;
}

// optional .PlayerLifeStory.DeathInfo deathInfo = 200;
inline bool PlayerLifeStory::has_deathinfo() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PlayerLifeStory::set_has_deathinfo() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PlayerLifeStory::clear_has_deathinfo() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PlayerLifeStory::clear_deathinfo() {
  if (deathinfo_ != NULL) deathinfo_->::PlayerLifeStory_DeathInfo::Clear();
  clear_has_deathinfo();
}
inline const ::PlayerLifeStory_DeathInfo& PlayerLifeStory::deathinfo() const {
  return deathinfo_ != NULL ? *deathinfo_ : *default_instance_->deathinfo_;
}
inline ::PlayerLifeStory_DeathInfo* PlayerLifeStory::mutable_deathinfo() {
  set_has_deathinfo();
  if (deathinfo_ == NULL) deathinfo_ = new ::PlayerLifeStory_DeathInfo;
  return deathinfo_;
}
inline ::PlayerLifeStory_DeathInfo* PlayerLifeStory::release_deathinfo() {
  clear_has_deathinfo();
  ::PlayerLifeStory_DeathInfo* temp = deathinfo_;
  deathinfo_ = NULL;
  return temp;
}
inline void PlayerLifeStory::set_allocated_deathinfo(::PlayerLifeStory_DeathInfo* deathinfo) {
  delete deathinfo_;
  deathinfo_ = deathinfo;
  if (deathinfo) {
    set_has_deathinfo();
  } else {
    clear_has_deathinfo();
  }
}

// -------------------------------------------------------------------

// BasePlayer

// optional string name = 1;
inline bool BasePlayer::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BasePlayer::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BasePlayer::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BasePlayer::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& BasePlayer::name() const {
  return *name_;
}
inline void BasePlayer::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void BasePlayer::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void BasePlayer::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BasePlayer::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* BasePlayer::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BasePlayer::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 userid = 2;
inline bool BasePlayer::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BasePlayer::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BasePlayer::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BasePlayer::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 BasePlayer::userid() const {
  return userid_;
}
inline void BasePlayer::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// optional .PlayerInventory inventory = 3;
inline bool BasePlayer::has_inventory() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BasePlayer::set_has_inventory() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BasePlayer::clear_has_inventory() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BasePlayer::clear_inventory() {
  if (inventory_ != NULL) inventory_->::PlayerInventory::Clear();
  clear_has_inventory();
}
inline const ::PlayerInventory& BasePlayer::inventory() const {
  return inventory_ != NULL ? *inventory_ : *default_instance_->inventory_;
}
inline ::PlayerInventory* BasePlayer::mutable_inventory() {
  set_has_inventory();
  if (inventory_ == NULL) inventory_ = new ::PlayerInventory;
  return inventory_;
}
inline ::PlayerInventory* BasePlayer::release_inventory() {
  clear_has_inventory();
  ::PlayerInventory* temp = inventory_;
  inventory_ = NULL;
  return temp;
}
inline void BasePlayer::set_allocated_inventory(::PlayerInventory* inventory) {
  delete inventory_;
  inventory_ = inventory;
  if (inventory) {
    set_has_inventory();
  } else {
    clear_has_inventory();
  }
}

// optional .PlayerMetabolism metabolism = 4;
inline bool BasePlayer::has_metabolism() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BasePlayer::set_has_metabolism() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BasePlayer::clear_has_metabolism() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BasePlayer::clear_metabolism() {
  if (metabolism_ != NULL) metabolism_->::PlayerMetabolism::Clear();
  clear_has_metabolism();
}
inline const ::PlayerMetabolism& BasePlayer::metabolism() const {
  return metabolism_ != NULL ? *metabolism_ : *default_instance_->metabolism_;
}
inline ::PlayerMetabolism* BasePlayer::mutable_metabolism() {
  set_has_metabolism();
  if (metabolism_ == NULL) metabolism_ = new ::PlayerMetabolism;
  return metabolism_;
}
inline ::PlayerMetabolism* BasePlayer::release_metabolism() {
  clear_has_metabolism();
  ::PlayerMetabolism* temp = metabolism_;
  metabolism_ = NULL;
  return temp;
}
inline void BasePlayer::set_allocated_metabolism(::PlayerMetabolism* metabolism) {
  delete metabolism_;
  metabolism_ = metabolism;
  if (metabolism) {
    set_has_metabolism();
  } else {
    clear_has_metabolism();
  }
}

// optional .ModelState modelState = 6;
inline bool BasePlayer::has_modelstate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BasePlayer::set_has_modelstate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BasePlayer::clear_has_modelstate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BasePlayer::clear_modelstate() {
  if (modelstate_ != NULL) modelstate_->::ModelState::Clear();
  clear_has_modelstate();
}
inline const ::ModelState& BasePlayer::modelstate() const {
  return modelstate_ != NULL ? *modelstate_ : *default_instance_->modelstate_;
}
inline ::ModelState* BasePlayer::mutable_modelstate() {
  set_has_modelstate();
  if (modelstate_ == NULL) modelstate_ = new ::ModelState;
  return modelstate_;
}
inline ::ModelState* BasePlayer::release_modelstate() {
  clear_has_modelstate();
  ::ModelState* temp = modelstate_;
  modelstate_ = NULL;
  return temp;
}
inline void BasePlayer::set_allocated_modelstate(::ModelState* modelstate) {
  delete modelstate_;
  modelstate_ = modelstate;
  if (modelstate) {
    set_has_modelstate();
  } else {
    clear_has_modelstate();
  }
}

// required uint64 playerFlags = 7;
inline bool BasePlayer::has_playerflags() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BasePlayer::set_has_playerflags() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BasePlayer::clear_has_playerflags() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BasePlayer::clear_playerflags() {
  playerflags_ = GOOGLE_ULONGLONG(0);
  clear_has_playerflags();
}
inline ::google::protobuf::uint64 BasePlayer::playerflags() const {
  return playerflags_;
}
inline void BasePlayer::set_playerflags(::google::protobuf::uint64 value) {
  set_has_playerflags();
  playerflags_ = value;
}

// required uint32 heldEntity = 8;
inline bool BasePlayer::has_heldentity() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BasePlayer::set_has_heldentity() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BasePlayer::clear_has_heldentity() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BasePlayer::clear_heldentity() {
  heldentity_ = 0u;
  clear_has_heldentity();
}
inline ::google::protobuf::uint32 BasePlayer::heldentity() const {
  return heldentity_;
}
inline void BasePlayer::set_heldentity(::google::protobuf::uint32 value) {
  set_has_heldentity();
  heldentity_ = value;
}

// required float health = 9;
inline bool BasePlayer::has_health() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BasePlayer::set_has_health() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BasePlayer::clear_has_health() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BasePlayer::clear_health() {
  health_ = 0;
  clear_has_health();
}
inline float BasePlayer::health() const {
  return health_;
}
inline void BasePlayer::set_health(float value) {
  set_has_health();
  health_ = value;
}

// optional .PersistantPlayer persistantData = 10;
inline bool BasePlayer::has_persistantdata() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BasePlayer::set_has_persistantdata() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BasePlayer::clear_has_persistantdata() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BasePlayer::clear_persistantdata() {
  if (persistantdata_ != NULL) persistantdata_->::PersistantPlayer::Clear();
  clear_has_persistantdata();
}
inline const ::PersistantPlayer& BasePlayer::persistantdata() const {
  return persistantdata_ != NULL ? *persistantdata_ : *default_instance_->persistantdata_;
}
inline ::PersistantPlayer* BasePlayer::mutable_persistantdata() {
  set_has_persistantdata();
  if (persistantdata_ == NULL) persistantdata_ = new ::PersistantPlayer;
  return persistantdata_;
}
inline ::PersistantPlayer* BasePlayer::release_persistantdata() {
  clear_has_persistantdata();
  ::PersistantPlayer* temp = persistantdata_;
  persistantdata_ = NULL;
  return temp;
}
inline void BasePlayer::set_allocated_persistantdata(::PersistantPlayer* persistantdata) {
  delete persistantdata_;
  persistantdata_ = persistantdata;
  if (persistantdata) {
    set_has_persistantdata();
  } else {
    clear_has_persistantdata();
  }
}

// required float skinCol = 15;
inline bool BasePlayer::has_skincol() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BasePlayer::set_has_skincol() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BasePlayer::clear_has_skincol() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BasePlayer::clear_skincol() {
  skincol_ = 0;
  clear_has_skincol();
}
inline float BasePlayer::skincol() const {
  return skincol_;
}
inline void BasePlayer::set_skincol(float value) {
  set_has_skincol();
  skincol_ = value;
}

// required float skinTex = 16;
inline bool BasePlayer::has_skintex() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BasePlayer::set_has_skintex() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BasePlayer::clear_has_skintex() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BasePlayer::clear_skintex() {
  skintex_ = 0;
  clear_has_skintex();
}
inline float BasePlayer::skintex() const {
  return skintex_;
}
inline void BasePlayer::set_skintex(float value) {
  set_has_skintex();
  skintex_ = value;
}

// required float skinMesh = 17;
inline bool BasePlayer::has_skinmesh() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BasePlayer::set_has_skinmesh() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BasePlayer::clear_has_skinmesh() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BasePlayer::clear_skinmesh() {
  skinmesh_ = 0;
  clear_has_skinmesh();
}
inline float BasePlayer::skinmesh() const {
  return skinmesh_;
}
inline void BasePlayer::set_skinmesh(float value) {
  set_has_skinmesh();
  skinmesh_ = value;
}

// optional .PlayerLifeStory currentLife = 20;
inline bool BasePlayer::has_currentlife() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BasePlayer::set_has_currentlife() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BasePlayer::clear_has_currentlife() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BasePlayer::clear_currentlife() {
  if (currentlife_ != NULL) currentlife_->::PlayerLifeStory::Clear();
  clear_has_currentlife();
}
inline const ::PlayerLifeStory& BasePlayer::currentlife() const {
  return currentlife_ != NULL ? *currentlife_ : *default_instance_->currentlife_;
}
inline ::PlayerLifeStory* BasePlayer::mutable_currentlife() {
  set_has_currentlife();
  if (currentlife_ == NULL) currentlife_ = new ::PlayerLifeStory;
  return currentlife_;
}
inline ::PlayerLifeStory* BasePlayer::release_currentlife() {
  clear_has_currentlife();
  ::PlayerLifeStory* temp = currentlife_;
  currentlife_ = NULL;
  return temp;
}
inline void BasePlayer::set_allocated_currentlife(::PlayerLifeStory* currentlife) {
  delete currentlife_;
  currentlife_ = currentlife;
  if (currentlife) {
    set_has_currentlife();
  } else {
    clear_has_currentlife();
  }
}

// optional .PlayerLifeStory previousLife = 21;
inline bool BasePlayer::has_previouslife() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BasePlayer::set_has_previouslife() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BasePlayer::clear_has_previouslife() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BasePlayer::clear_previouslife() {
  if (previouslife_ != NULL) previouslife_->::PlayerLifeStory::Clear();
  clear_has_previouslife();
}
inline const ::PlayerLifeStory& BasePlayer::previouslife() const {
  return previouslife_ != NULL ? *previouslife_ : *default_instance_->previouslife_;
}
inline ::PlayerLifeStory* BasePlayer::mutable_previouslife() {
  set_has_previouslife();
  if (previouslife_ == NULL) previouslife_ = new ::PlayerLifeStory;
  return previouslife_;
}
inline ::PlayerLifeStory* BasePlayer::release_previouslife() {
  clear_has_previouslife();
  ::PlayerLifeStory* temp = previouslife_;
  previouslife_ = NULL;
  return temp;
}
inline void BasePlayer::set_allocated_previouslife(::PlayerLifeStory* previouslife) {
  delete previouslife_;
  previouslife_ = previouslife;
  if (previouslife) {
    set_has_previouslife();
  } else {
    clear_has_previouslife();
  }
}

// -------------------------------------------------------------------

// WorldItem

// optional .Item item = 1;
inline bool WorldItem::has_item() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WorldItem::set_has_item() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WorldItem::clear_has_item() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WorldItem::clear_item() {
  if (item_ != NULL) item_->::Item::Clear();
  clear_has_item();
}
inline const ::Item& WorldItem::item() const {
  return item_ != NULL ? *item_ : *default_instance_->item_;
}
inline ::Item* WorldItem::mutable_item() {
  set_has_item();
  if (item_ == NULL) item_ = new ::Item;
  return item_;
}
inline ::Item* WorldItem::release_item() {
  clear_has_item();
  ::Item* temp = item_;
  item_ = NULL;
  return temp;
}
inline void WorldItem::set_allocated_item(::Item* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
}

// -------------------------------------------------------------------

// BaseResource

// required uint64 stage = 1;
inline bool BaseResource::has_stage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BaseResource::set_has_stage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BaseResource::clear_has_stage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BaseResource::clear_stage() {
  stage_ = GOOGLE_ULONGLONG(0);
  clear_has_stage();
}
inline ::google::protobuf::uint64 BaseResource::stage() const {
  return stage_;
}
inline void BaseResource::set_stage(::google::protobuf::uint64 value) {
  set_has_stage();
  stage_ = value;
}

// required float health = 2;
inline bool BaseResource::has_health() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BaseResource::set_has_health() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BaseResource::clear_has_health() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BaseResource::clear_health() {
  health_ = 0;
  clear_has_health();
}
inline float BaseResource::health() const {
  return health_;
}
inline void BaseResource::set_health(float value) {
  set_has_health();
  health_ = value;
}

// -------------------------------------------------------------------

// BuildingBlock

// required uint64 grade = 2;
inline bool BuildingBlock::has_grade() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuildingBlock::set_has_grade() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuildingBlock::clear_has_grade() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuildingBlock::clear_grade() {
  grade_ = GOOGLE_ULONGLONG(0);
  clear_has_grade();
}
inline ::google::protobuf::uint64 BuildingBlock::grade() const {
  return grade_;
}
inline void BuildingBlock::set_grade(::google::protobuf::uint64 value) {
  set_has_grade();
  grade_ = value;
}

// required bool beingDemolished = 3;
inline bool BuildingBlock::has_beingdemolished() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuildingBlock::set_has_beingdemolished() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuildingBlock::clear_has_beingdemolished() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuildingBlock::clear_beingdemolished() {
  beingdemolished_ = false;
  clear_has_beingdemolished();
}
inline bool BuildingBlock::beingdemolished() const {
  return beingdemolished_;
}
inline void BuildingBlock::set_beingdemolished(bool value) {
  set_has_beingdemolished();
  beingdemolished_ = value;
}

// required float stability = 4;
inline bool BuildingBlock::has_stability() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BuildingBlock::set_has_stability() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BuildingBlock::clear_has_stability() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BuildingBlock::clear_stability() {
  stability_ = 0;
  clear_has_stability();
}
inline float BuildingBlock::stability() const {
  return stability_;
}
inline void BuildingBlock::set_stability(float value) {
  set_has_stability();
  stability_ = value;
}

// required uint32 buildingID = 5;
inline bool BuildingBlock::has_buildingid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BuildingBlock::set_has_buildingid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BuildingBlock::clear_has_buildingid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BuildingBlock::clear_buildingid() {
  buildingid_ = 0u;
  clear_has_buildingid();
}
inline ::google::protobuf::uint32 BuildingBlock::buildingid() const {
  return buildingid_;
}
inline void BuildingBlock::set_buildingid(::google::protobuf::uint32 value) {
  set_has_buildingid();
  buildingid_ = value;
}

// -------------------------------------------------------------------

// Environment

// required uint64 dateTime = 1;
inline bool Environment::has_datetime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Environment::set_has_datetime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Environment::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Environment::clear_datetime() {
  datetime_ = GOOGLE_ULONGLONG(0);
  clear_has_datetime();
}
inline ::google::protobuf::uint64 Environment::datetime() const {
  return datetime_;
}
inline void Environment::set_datetime(::google::protobuf::uint64 value) {
  set_has_datetime();
  datetime_ = value;
}

// required float clouds = 2;
inline bool Environment::has_clouds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Environment::set_has_clouds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Environment::clear_has_clouds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Environment::clear_clouds() {
  clouds_ = 0;
  clear_has_clouds();
}
inline float Environment::clouds() const {
  return clouds_;
}
inline void Environment::set_clouds(float value) {
  set_has_clouds();
  clouds_ = value;
}

// required float fog = 3;
inline bool Environment::has_fog() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Environment::set_has_fog() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Environment::clear_has_fog() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Environment::clear_fog() {
  fog_ = 0;
  clear_has_fog();
}
inline float Environment::fog() const {
  return fog_;
}
inline void Environment::set_fog(float value) {
  set_has_fog();
  fog_ = value;
}

// required float wind = 4;
inline bool Environment::has_wind() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Environment::set_has_wind() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Environment::clear_has_wind() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Environment::clear_wind() {
  wind_ = 0;
  clear_has_wind();
}
inline float Environment::wind() const {
  return wind_;
}
inline void Environment::set_wind(float value) {
  set_has_wind();
  wind_ = value;
}

// required float rain = 5;
inline bool Environment::has_rain() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Environment::set_has_rain() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Environment::clear_has_rain() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Environment::clear_rain() {
  rain_ = 0;
  clear_has_rain();
}
inline float Environment::rain() const {
  return rain_;
}
inline void Environment::set_rain(float value) {
  set_has_rain();
  rain_ = value;
}

// -------------------------------------------------------------------

// Corpse

// required uint32 parentID = 1;
inline bool Corpse::has_parentid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Corpse::set_has_parentid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Corpse::clear_has_parentid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Corpse::clear_parentid() {
  parentid_ = 0u;
  clear_has_parentid();
}
inline ::google::protobuf::uint32 Corpse::parentid() const {
  return parentid_;
}
inline void Corpse::set_parentid(::google::protobuf::uint32 value) {
  set_has_parentid();
  parentid_ = value;
}

// -------------------------------------------------------------------

// ParentInfo

// required uint32 uid = 1;
inline bool ParentInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParentInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParentInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParentInfo::clear_uid() {
  uid_ = 0u;
  clear_has_uid();
}
inline ::google::protobuf::uint32 ParentInfo::uid() const {
  return uid_;
}
inline void ParentInfo::set_uid(::google::protobuf::uint32 value) {
  set_has_uid();
  uid_ = value;
}

// required uint32 bone = 2;
inline bool ParentInfo::has_bone() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParentInfo::set_has_bone() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParentInfo::clear_has_bone() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParentInfo::clear_bone() {
  bone_ = 0u;
  clear_has_bone();
}
inline ::google::protobuf::uint32 ParentInfo::bone() const {
  return bone_;
}
inline void ParentInfo::set_bone(::google::protobuf::uint32 value) {
  set_has_bone();
  bone_ = value;
}

// -------------------------------------------------------------------

// KeyLock

// required uint64 code = 1;
inline bool KeyLock::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyLock::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyLock::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeyLock::clear_code() {
  code_ = GOOGLE_ULONGLONG(0);
  clear_has_code();
}
inline ::google::protobuf::uint64 KeyLock::code() const {
  return code_;
}
inline void KeyLock::set_code(::google::protobuf::uint64 value) {
  set_has_code();
  code_ = value;
}

// -------------------------------------------------------------------

// CodeLock_Private

// optional string code = 1;
inline bool CodeLock_Private::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CodeLock_Private::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CodeLock_Private::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CodeLock_Private::clear_code() {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    code_->clear();
  }
  clear_has_code();
}
inline const ::std::string& CodeLock_Private::code() const {
  return *code_;
}
inline void CodeLock_Private::set_code(const ::std::string& value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void CodeLock_Private::set_code(const char* value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void CodeLock_Private::set_code(const char* value, size_t size) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CodeLock_Private::mutable_code() {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  return code_;
}
inline ::std::string* CodeLock_Private::release_code() {
  clear_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = code_;
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CodeLock_Private::set_allocated_code(::std::string* code) {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    delete code_;
  }
  if (code) {
    set_has_code();
    code_ = code;
  } else {
    clear_has_code();
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated uint64 users = 2;
inline int CodeLock_Private::users_size() const {
  return users_.size();
}
inline void CodeLock_Private::clear_users() {
  users_.Clear();
}
inline ::google::protobuf::uint64 CodeLock_Private::users(int index) const {
  return users_.Get(index);
}
inline void CodeLock_Private::set_users(int index, ::google::protobuf::uint64 value) {
  users_.Set(index, value);
}
inline void CodeLock_Private::add_users(::google::protobuf::uint64 value) {
  users_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
CodeLock_Private::users() const {
  return users_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
CodeLock_Private::mutable_users() {
  return &users_;
}

// repeated uint64 guests = 3;
inline int CodeLock_Private::guests_size() const {
  return guests_.size();
}
inline void CodeLock_Private::clear_guests() {
  guests_.Clear();
}
inline ::google::protobuf::uint64 CodeLock_Private::guests(int index) const {
  return guests_.Get(index);
}
inline void CodeLock_Private::set_guests(int index, ::google::protobuf::uint64 value) {
  guests_.Set(index, value);
}
inline void CodeLock_Private::add_guests(::google::protobuf::uint64 value) {
  guests_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
CodeLock_Private::guests() const {
  return guests_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
CodeLock_Private::mutable_guests() {
  return &guests_;
}

// optional string guestCode = 4;
inline bool CodeLock_Private::has_guestcode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CodeLock_Private::set_has_guestcode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CodeLock_Private::clear_has_guestcode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CodeLock_Private::clear_guestcode() {
  if (guestcode_ != &::google::protobuf::internal::kEmptyString) {
    guestcode_->clear();
  }
  clear_has_guestcode();
}
inline const ::std::string& CodeLock_Private::guestcode() const {
  return *guestcode_;
}
inline void CodeLock_Private::set_guestcode(const ::std::string& value) {
  set_has_guestcode();
  if (guestcode_ == &::google::protobuf::internal::kEmptyString) {
    guestcode_ = new ::std::string;
  }
  guestcode_->assign(value);
}
inline void CodeLock_Private::set_guestcode(const char* value) {
  set_has_guestcode();
  if (guestcode_ == &::google::protobuf::internal::kEmptyString) {
    guestcode_ = new ::std::string;
  }
  guestcode_->assign(value);
}
inline void CodeLock_Private::set_guestcode(const char* value, size_t size) {
  set_has_guestcode();
  if (guestcode_ == &::google::protobuf::internal::kEmptyString) {
    guestcode_ = new ::std::string;
  }
  guestcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CodeLock_Private::mutable_guestcode() {
  set_has_guestcode();
  if (guestcode_ == &::google::protobuf::internal::kEmptyString) {
    guestcode_ = new ::std::string;
  }
  return guestcode_;
}
inline ::std::string* CodeLock_Private::release_guestcode() {
  clear_has_guestcode();
  if (guestcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = guestcode_;
    guestcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CodeLock_Private::set_allocated_guestcode(::std::string* guestcode) {
  if (guestcode_ != &::google::protobuf::internal::kEmptyString) {
    delete guestcode_;
  }
  if (guestcode) {
    set_has_guestcode();
    guestcode_ = guestcode;
  } else {
    clear_has_guestcode();
    guestcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated uint64 guestUsers = 5;
inline int CodeLock_Private::guestusers_size() const {
  return guestusers_.size();
}
inline void CodeLock_Private::clear_guestusers() {
  guestusers_.Clear();
}
inline ::google::protobuf::uint64 CodeLock_Private::guestusers(int index) const {
  return guestusers_.Get(index);
}
inline void CodeLock_Private::set_guestusers(int index, ::google::protobuf::uint64 value) {
  guestusers_.Set(index, value);
}
inline void CodeLock_Private::add_guestusers(::google::protobuf::uint64 value) {
  guestusers_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
CodeLock_Private::guestusers() const {
  return guestusers_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
CodeLock_Private::mutable_guestusers() {
  return &guestusers_;
}

// -------------------------------------------------------------------

// CodeLock

// optional .CodeLock.Private pv = 1;
inline bool CodeLock::has_pv() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CodeLock::set_has_pv() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CodeLock::clear_has_pv() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CodeLock::clear_pv() {
  if (pv_ != NULL) pv_->::CodeLock_Private::Clear();
  clear_has_pv();
}
inline const ::CodeLock_Private& CodeLock::pv() const {
  return pv_ != NULL ? *pv_ : *default_instance_->pv_;
}
inline ::CodeLock_Private* CodeLock::mutable_pv() {
  set_has_pv();
  if (pv_ == NULL) pv_ = new ::CodeLock_Private;
  return pv_;
}
inline ::CodeLock_Private* CodeLock::release_pv() {
  clear_has_pv();
  ::CodeLock_Private* temp = pv_;
  pv_ = NULL;
  return temp;
}
inline void CodeLock::set_allocated_pv(::CodeLock_Private* pv) {
  delete pv_;
  pv_ = pv;
  if (pv) {
    set_has_pv();
  } else {
    clear_has_pv();
  }
}

// required bool hasCode = 2;
inline bool CodeLock::has_hascode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CodeLock::set_has_hascode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CodeLock::clear_has_hascode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CodeLock::clear_hascode() {
  hascode_ = false;
  clear_has_hascode();
}
inline bool CodeLock::hascode() const {
  return hascode_;
}
inline void CodeLock::set_hascode(bool value) {
  set_has_hascode();
  hascode_ = value;
}

// required bool hasGuestCode = 3;
inline bool CodeLock::has_hasguestcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CodeLock::set_has_hasguestcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CodeLock::clear_has_hasguestcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CodeLock::clear_hasguestcode() {
  hasguestcode_ = false;
  clear_has_hasguestcode();
}
inline bool CodeLock::hasguestcode() const {
  return hasguestcode_;
}
inline void CodeLock::set_hasguestcode(bool value) {
  set_has_hasguestcode();
  hasguestcode_ = value;
}

// -------------------------------------------------------------------

// EntitySlots

// required uint32 slotLock = 1;
inline bool EntitySlots::has_slotlock() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EntitySlots::set_has_slotlock() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EntitySlots::clear_has_slotlock() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EntitySlots::clear_slotlock() {
  slotlock_ = 0u;
  clear_has_slotlock();
}
inline ::google::protobuf::uint32 EntitySlots::slotlock() const {
  return slotlock_;
}
inline void EntitySlots::set_slotlock(::google::protobuf::uint32 value) {
  set_has_slotlock();
  slotlock_ = value;
}

// required uint32 slotFireMod = 2;
inline bool EntitySlots::has_slotfiremod() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EntitySlots::set_has_slotfiremod() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EntitySlots::clear_has_slotfiremod() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EntitySlots::clear_slotfiremod() {
  slotfiremod_ = 0u;
  clear_has_slotfiremod();
}
inline ::google::protobuf::uint32 EntitySlots::slotfiremod() const {
  return slotfiremod_;
}
inline void EntitySlots::set_slotfiremod(::google::protobuf::uint32 value) {
  set_has_slotfiremod();
  slotfiremod_ = value;
}

// required uint32 slotUpperModification = 3;
inline bool EntitySlots::has_slotuppermodification() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EntitySlots::set_has_slotuppermodification() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EntitySlots::clear_has_slotuppermodification() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EntitySlots::clear_slotuppermodification() {
  slotuppermodification_ = 0u;
  clear_has_slotuppermodification();
}
inline ::google::protobuf::uint32 EntitySlots::slotuppermodification() const {
  return slotuppermodification_;
}
inline void EntitySlots::set_slotuppermodification(::google::protobuf::uint32 value) {
  set_has_slotuppermodification();
  slotuppermodification_ = value;
}

// -------------------------------------------------------------------

// PlayerNameID

// required string username = 1;
inline bool PlayerNameID::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerNameID::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerNameID::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerNameID::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& PlayerNameID::username() const {
  return *username_;
}
inline void PlayerNameID::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void PlayerNameID::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void PlayerNameID::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerNameID::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* PlayerNameID::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerNameID::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 userid = 2;
inline bool PlayerNameID::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerNameID::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerNameID::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerNameID::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 PlayerNameID::userid() const {
  return userid_;
}
inline void PlayerNameID::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// -------------------------------------------------------------------

// BuildingPrivilege

// repeated .PlayerNameID users = 1;
inline int BuildingPrivilege::users_size() const {
  return users_.size();
}
inline void BuildingPrivilege::clear_users() {
  users_.Clear();
}
inline const ::PlayerNameID& BuildingPrivilege::users(int index) const {
  return users_.Get(index);
}
inline ::PlayerNameID* BuildingPrivilege::mutable_users(int index) {
  return users_.Mutable(index);
}
inline ::PlayerNameID* BuildingPrivilege::add_users() {
  return users_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerNameID >&
BuildingPrivilege::users() const {
  return users_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerNameID >*
BuildingPrivilege::mutable_users() {
  return &users_;
}

// -------------------------------------------------------------------

// StorageBox

// optional .ItemContainer contents = 1;
inline bool StorageBox::has_contents() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StorageBox::set_has_contents() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StorageBox::clear_has_contents() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StorageBox::clear_contents() {
  if (contents_ != NULL) contents_->::ItemContainer::Clear();
  clear_has_contents();
}
inline const ::ItemContainer& StorageBox::contents() const {
  return contents_ != NULL ? *contents_ : *default_instance_->contents_;
}
inline ::ItemContainer* StorageBox::mutable_contents() {
  set_has_contents();
  if (contents_ == NULL) contents_ = new ::ItemContainer;
  return contents_;
}
inline ::ItemContainer* StorageBox::release_contents() {
  clear_has_contents();
  ::ItemContainer* temp = contents_;
  contents_ = NULL;
  return temp;
}
inline void StorageBox::set_allocated_contents(::ItemContainer* contents) {
  delete contents_;
  contents_ = contents;
  if (contents) {
    set_has_contents();
  } else {
    clear_has_contents();
  }
}

// -------------------------------------------------------------------

// HeldEntity

// required uint32 itemUID = 1;
inline bool HeldEntity::has_itemuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeldEntity::set_has_itemuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeldEntity::clear_has_itemuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeldEntity::clear_itemuid() {
  itemuid_ = 0u;
  clear_has_itemuid();
}
inline ::google::protobuf::uint32 HeldEntity::itemuid() const {
  return itemuid_;
}
inline void HeldEntity::set_itemuid(::google::protobuf::uint32 value) {
  set_has_itemuid();
  itemuid_ = value;
}

// -------------------------------------------------------------------

// Magazine

// required uint64 capacity = 1;
inline bool Magazine::has_capacity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Magazine::set_has_capacity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Magazine::clear_has_capacity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Magazine::clear_capacity() {
  capacity_ = GOOGLE_ULONGLONG(0);
  clear_has_capacity();
}
inline ::google::protobuf::uint64 Magazine::capacity() const {
  return capacity_;
}
inline void Magazine::set_capacity(::google::protobuf::uint64 value) {
  set_has_capacity();
  capacity_ = value;
}

// required uint64 contents = 2;
inline bool Magazine::has_contents() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Magazine::set_has_contents() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Magazine::clear_has_contents() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Magazine::clear_contents() {
  contents_ = GOOGLE_ULONGLONG(0);
  clear_has_contents();
}
inline ::google::protobuf::uint64 Magazine::contents() const {
  return contents_;
}
inline void Magazine::set_contents(::google::protobuf::uint64 value) {
  set_has_contents();
  contents_ = value;
}

// required uint64 ammoType = 3;
inline bool Magazine::has_ammotype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Magazine::set_has_ammotype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Magazine::clear_has_ammotype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Magazine::clear_ammotype() {
  ammotype_ = GOOGLE_ULONGLONG(0);
  clear_has_ammotype();
}
inline ::google::protobuf::uint64 Magazine::ammotype() const {
  return ammotype_;
}
inline void Magazine::set_ammotype(::google::protobuf::uint64 value) {
  set_has_ammotype();
  ammotype_ = value;
}

// -------------------------------------------------------------------

// BaseProjectile

// optional .Magazine primaryMagazine = 1;
inline bool BaseProjectile::has_primarymagazine() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BaseProjectile::set_has_primarymagazine() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BaseProjectile::clear_has_primarymagazine() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BaseProjectile::clear_primarymagazine() {
  if (primarymagazine_ != NULL) primarymagazine_->::Magazine::Clear();
  clear_has_primarymagazine();
}
inline const ::Magazine& BaseProjectile::primarymagazine() const {
  return primarymagazine_ != NULL ? *primarymagazine_ : *default_instance_->primarymagazine_;
}
inline ::Magazine* BaseProjectile::mutable_primarymagazine() {
  set_has_primarymagazine();
  if (primarymagazine_ == NULL) primarymagazine_ = new ::Magazine;
  return primarymagazine_;
}
inline ::Magazine* BaseProjectile::release_primarymagazine() {
  clear_has_primarymagazine();
  ::Magazine* temp = primarymagazine_;
  primarymagazine_ = NULL;
  return temp;
}
inline void BaseProjectile::set_allocated_primarymagazine(::Magazine* primarymagazine) {
  delete primarymagazine_;
  primarymagazine_ = primarymagazine;
  if (primarymagazine) {
    set_has_primarymagazine();
  } else {
    clear_has_primarymagazine();
  }
}

// -------------------------------------------------------------------

// BaseNPC

// required uint64 flags = 2;
inline bool BaseNPC::has_flags() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BaseNPC::set_has_flags() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BaseNPC::clear_has_flags() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BaseNPC::clear_flags() {
  flags_ = GOOGLE_ULONGLONG(0);
  clear_has_flags();
}
inline ::google::protobuf::uint64 BaseNPC::flags() const {
  return flags_;
}
inline void BaseNPC::set_flags(::google::protobuf::uint64 value) {
  set_has_flags();
  flags_ = value;
}

// -------------------------------------------------------------------

// Loot

// optional .ItemContainer contents = 1;
inline bool Loot::has_contents() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Loot::set_has_contents() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Loot::clear_has_contents() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Loot::clear_contents() {
  if (contents_ != NULL) contents_->::ItemContainer::Clear();
  clear_has_contents();
}
inline const ::ItemContainer& Loot::contents() const {
  return contents_ != NULL ? *contents_ : *default_instance_->contents_;
}
inline ::ItemContainer* Loot::mutable_contents() {
  set_has_contents();
  if (contents_ == NULL) contents_ = new ::ItemContainer;
  return contents_;
}
inline ::ItemContainer* Loot::release_contents() {
  clear_has_contents();
  ::ItemContainer* temp = contents_;
  contents_ = NULL;
  return temp;
}
inline void Loot::set_allocated_contents(::ItemContainer* contents) {
  delete contents_;
  contents_ = contents;
  if (contents) {
    set_has_contents();
  } else {
    clear_has_contents();
  }
}

// -------------------------------------------------------------------

// GenericSpawner_SpawnedEnt

// required uint32 uid = 1;
inline bool GenericSpawner_SpawnedEnt::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GenericSpawner_SpawnedEnt::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GenericSpawner_SpawnedEnt::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GenericSpawner_SpawnedEnt::clear_uid() {
  uid_ = 0u;
  clear_has_uid();
}
inline ::google::protobuf::uint32 GenericSpawner_SpawnedEnt::uid() const {
  return uid_;
}
inline void GenericSpawner_SpawnedEnt::set_uid(::google::protobuf::uint32 value) {
  set_has_uid();
  uid_ = value;
}

// required uint32 spawnPointIndex = 2;
inline bool GenericSpawner_SpawnedEnt::has_spawnpointindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GenericSpawner_SpawnedEnt::set_has_spawnpointindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GenericSpawner_SpawnedEnt::clear_has_spawnpointindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GenericSpawner_SpawnedEnt::clear_spawnpointindex() {
  spawnpointindex_ = 0u;
  clear_has_spawnpointindex();
}
inline ::google::protobuf::uint32 GenericSpawner_SpawnedEnt::spawnpointindex() const {
  return spawnpointindex_;
}
inline void GenericSpawner_SpawnedEnt::set_spawnpointindex(::google::protobuf::uint32 value) {
  set_has_spawnpointindex();
  spawnpointindex_ = value;
}

// required bool mobile = 3;
inline bool GenericSpawner_SpawnedEnt::has_mobile() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GenericSpawner_SpawnedEnt::set_has_mobile() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GenericSpawner_SpawnedEnt::clear_has_mobile() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GenericSpawner_SpawnedEnt::clear_mobile() {
  mobile_ = false;
  clear_has_mobile();
}
inline bool GenericSpawner_SpawnedEnt::mobile() const {
  return mobile_;
}
inline void GenericSpawner_SpawnedEnt::set_mobile(bool value) {
  set_has_mobile();
  mobile_ = value;
}

// -------------------------------------------------------------------

// GenericSpawner

// repeated .GenericSpawner.SpawnedEnt ents = 1;
inline int GenericSpawner::ents_size() const {
  return ents_.size();
}
inline void GenericSpawner::clear_ents() {
  ents_.Clear();
}
inline const ::GenericSpawner_SpawnedEnt& GenericSpawner::ents(int index) const {
  return ents_.Get(index);
}
inline ::GenericSpawner_SpawnedEnt* GenericSpawner::mutable_ents(int index) {
  return ents_.Mutable(index);
}
inline ::GenericSpawner_SpawnedEnt* GenericSpawner::add_ents() {
  return ents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GenericSpawner_SpawnedEnt >&
GenericSpawner::ents() const {
  return ents_;
}
inline ::google::protobuf::RepeatedPtrField< ::GenericSpawner_SpawnedEnt >*
GenericSpawner::mutable_ents() {
  return &ents_;
}

// -------------------------------------------------------------------

// SleepingBag_Private

// required uint64 deployerID = 1;
inline bool SleepingBag_Private::has_deployerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SleepingBag_Private::set_has_deployerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SleepingBag_Private::clear_has_deployerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SleepingBag_Private::clear_deployerid() {
  deployerid_ = GOOGLE_ULONGLONG(0);
  clear_has_deployerid();
}
inline ::google::protobuf::uint64 SleepingBag_Private::deployerid() const {
  return deployerid_;
}
inline void SleepingBag_Private::set_deployerid(::google::protobuf::uint64 value) {
  set_has_deployerid();
  deployerid_ = value;
}

// optional string deployerName = 2;
inline bool SleepingBag_Private::has_deployername() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SleepingBag_Private::set_has_deployername() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SleepingBag_Private::clear_has_deployername() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SleepingBag_Private::clear_deployername() {
  if (deployername_ != &::google::protobuf::internal::kEmptyString) {
    deployername_->clear();
  }
  clear_has_deployername();
}
inline const ::std::string& SleepingBag_Private::deployername() const {
  return *deployername_;
}
inline void SleepingBag_Private::set_deployername(const ::std::string& value) {
  set_has_deployername();
  if (deployername_ == &::google::protobuf::internal::kEmptyString) {
    deployername_ = new ::std::string;
  }
  deployername_->assign(value);
}
inline void SleepingBag_Private::set_deployername(const char* value) {
  set_has_deployername();
  if (deployername_ == &::google::protobuf::internal::kEmptyString) {
    deployername_ = new ::std::string;
  }
  deployername_->assign(value);
}
inline void SleepingBag_Private::set_deployername(const char* value, size_t size) {
  set_has_deployername();
  if (deployername_ == &::google::protobuf::internal::kEmptyString) {
    deployername_ = new ::std::string;
  }
  deployername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SleepingBag_Private::mutable_deployername() {
  set_has_deployername();
  if (deployername_ == &::google::protobuf::internal::kEmptyString) {
    deployername_ = new ::std::string;
  }
  return deployername_;
}
inline ::std::string* SleepingBag_Private::release_deployername() {
  clear_has_deployername();
  if (deployername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deployername_;
    deployername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SleepingBag_Private::set_allocated_deployername(::std::string* deployername) {
  if (deployername_ != &::google::protobuf::internal::kEmptyString) {
    delete deployername_;
  }
  if (deployername) {
    set_has_deployername();
    deployername_ = deployername;
  } else {
    clear_has_deployername();
    deployername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SleepingBag

// optional string name = 1;
inline bool SleepingBag::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SleepingBag::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SleepingBag::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SleepingBag::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SleepingBag::name() const {
  return *name_;
}
inline void SleepingBag::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SleepingBag::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SleepingBag::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SleepingBag::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SleepingBag::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SleepingBag::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SleepingBag.Private privateData = 2;
inline bool SleepingBag::has_privatedata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SleepingBag::set_has_privatedata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SleepingBag::clear_has_privatedata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SleepingBag::clear_privatedata() {
  if (privatedata_ != NULL) privatedata_->::SleepingBag_Private::Clear();
  clear_has_privatedata();
}
inline const ::SleepingBag_Private& SleepingBag::privatedata() const {
  return privatedata_ != NULL ? *privatedata_ : *default_instance_->privatedata_;
}
inline ::SleepingBag_Private* SleepingBag::mutable_privatedata() {
  set_has_privatedata();
  if (privatedata_ == NULL) privatedata_ = new ::SleepingBag_Private;
  return privatedata_;
}
inline ::SleepingBag_Private* SleepingBag::release_privatedata() {
  clear_has_privatedata();
  ::SleepingBag_Private* temp = privatedata_;
  privatedata_ = NULL;
  return temp;
}
inline void SleepingBag::set_allocated_privatedata(::SleepingBag_Private* privatedata) {
  delete privatedata_;
  privatedata_ = privatedata;
  if (privatedata) {
    set_has_privatedata();
  } else {
    clear_has_privatedata();
  }
}

// required uint64 deployerID = 3;
inline bool SleepingBag::has_deployerid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SleepingBag::set_has_deployerid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SleepingBag::clear_has_deployerid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SleepingBag::clear_deployerid() {
  deployerid_ = GOOGLE_ULONGLONG(0);
  clear_has_deployerid();
}
inline ::google::protobuf::uint64 SleepingBag::deployerid() const {
  return deployerid_;
}
inline void SleepingBag::set_deployerid(::google::protobuf::uint64 value) {
  set_has_deployerid();
  deployerid_ = value;
}

// -------------------------------------------------------------------

// LootableCorpse_Private

// repeated .ItemContainer container = 1;
inline int LootableCorpse_Private::container_size() const {
  return container_.size();
}
inline void LootableCorpse_Private::clear_container() {
  container_.Clear();
}
inline const ::ItemContainer& LootableCorpse_Private::container(int index) const {
  return container_.Get(index);
}
inline ::ItemContainer* LootableCorpse_Private::mutable_container(int index) {
  return container_.Mutable(index);
}
inline ::ItemContainer* LootableCorpse_Private::add_container() {
  return container_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ItemContainer >&
LootableCorpse_Private::container() const {
  return container_;
}
inline ::google::protobuf::RepeatedPtrField< ::ItemContainer >*
LootableCorpse_Private::mutable_container() {
  return &container_;
}

// -------------------------------------------------------------------

// LootableCorpse

// optional .LootableCorpse.Private privateData = 1;
inline bool LootableCorpse::has_privatedata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LootableCorpse::set_has_privatedata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LootableCorpse::clear_has_privatedata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LootableCorpse::clear_privatedata() {
  if (privatedata_ != NULL) privatedata_->::LootableCorpse_Private::Clear();
  clear_has_privatedata();
}
inline const ::LootableCorpse_Private& LootableCorpse::privatedata() const {
  return privatedata_ != NULL ? *privatedata_ : *default_instance_->privatedata_;
}
inline ::LootableCorpse_Private* LootableCorpse::mutable_privatedata() {
  set_has_privatedata();
  if (privatedata_ == NULL) privatedata_ = new ::LootableCorpse_Private;
  return privatedata_;
}
inline ::LootableCorpse_Private* LootableCorpse::release_privatedata() {
  clear_has_privatedata();
  ::LootableCorpse_Private* temp = privatedata_;
  privatedata_ = NULL;
  return temp;
}
inline void LootableCorpse::set_allocated_privatedata(::LootableCorpse_Private* privatedata) {
  delete privatedata_;
  privatedata_ = privatedata;
  if (privatedata) {
    set_has_privatedata();
  } else {
    clear_has_privatedata();
  }
}

// required uint64 playerID = 2;
inline bool LootableCorpse::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LootableCorpse::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LootableCorpse::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LootableCorpse::clear_playerid() {
  playerid_ = GOOGLE_ULONGLONG(0);
  clear_has_playerid();
}
inline ::google::protobuf::uint64 LootableCorpse::playerid() const {
  return playerid_;
}
inline void LootableCorpse::set_playerid(::google::protobuf::uint64 value) {
  set_has_playerid();
  playerid_ = value;
}

// optional string playerName = 3;
inline bool LootableCorpse::has_playername() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LootableCorpse::set_has_playername() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LootableCorpse::clear_has_playername() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LootableCorpse::clear_playername() {
  if (playername_ != &::google::protobuf::internal::kEmptyString) {
    playername_->clear();
  }
  clear_has_playername();
}
inline const ::std::string& LootableCorpse::playername() const {
  return *playername_;
}
inline void LootableCorpse::set_playername(const ::std::string& value) {
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    playername_ = new ::std::string;
  }
  playername_->assign(value);
}
inline void LootableCorpse::set_playername(const char* value) {
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    playername_ = new ::std::string;
  }
  playername_->assign(value);
}
inline void LootableCorpse::set_playername(const char* value, size_t size) {
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    playername_ = new ::std::string;
  }
  playername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LootableCorpse::mutable_playername() {
  set_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    playername_ = new ::std::string;
  }
  return playername_;
}
inline ::std::string* LootableCorpse::release_playername() {
  clear_has_playername();
  if (playername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playername_;
    playername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LootableCorpse::set_allocated_playername(::std::string* playername) {
  if (playername_ != &::google::protobuf::internal::kEmptyString) {
    delete playername_;
  }
  if (playername) {
    set_has_playername();
    playername_ = playername;
  } else {
    clear_has_playername();
    playername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Sign

// required uint32 imageid = 3;
inline bool Sign::has_imageid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Sign::set_has_imageid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Sign::clear_has_imageid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Sign::clear_imageid() {
  imageid_ = 0u;
  clear_has_imageid();
}
inline ::google::protobuf::uint32 Sign::imageid() const {
  return imageid_;
}
inline void Sign::set_imageid(::google::protobuf::uint32 value) {
  set_has_imageid();
  imageid_ = value;
}

// -------------------------------------------------------------------

// BaseCombat

// required uint64 state = 1;
inline bool BaseCombat::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BaseCombat::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BaseCombat::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BaseCombat::clear_state() {
  state_ = GOOGLE_ULONGLONG(0);
  clear_has_state();
}
inline ::google::protobuf::uint64 BaseCombat::state() const {
  return state_;
}
inline void BaseCombat::set_state(::google::protobuf::uint64 value) {
  set_has_state();
  state_ = value;
}

// required float health = 2;
inline bool BaseCombat::has_health() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BaseCombat::set_has_health() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BaseCombat::clear_has_health() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BaseCombat::clear_health() {
  health_ = 0;
  clear_has_health();
}
inline float BaseCombat::health() const {
  return health_;
}
inline void BaseCombat::set_health(float value) {
  set_has_health();
  health_ = value;
}

// -------------------------------------------------------------------

// MapEntity

// repeated uint32 fogImages = 1;
inline int MapEntity::fogimages_size() const {
  return fogimages_.size();
}
inline void MapEntity::clear_fogimages() {
  fogimages_.Clear();
}
inline ::google::protobuf::uint32 MapEntity::fogimages(int index) const {
  return fogimages_.Get(index);
}
inline void MapEntity::set_fogimages(int index, ::google::protobuf::uint32 value) {
  fogimages_.Set(index, value);
}
inline void MapEntity::add_fogimages(::google::protobuf::uint32 value) {
  fogimages_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MapEntity::fogimages() const {
  return fogimages_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MapEntity::mutable_fogimages() {
  return &fogimages_;
}

// repeated uint32 paintImages = 2;
inline int MapEntity::paintimages_size() const {
  return paintimages_.size();
}
inline void MapEntity::clear_paintimages() {
  paintimages_.Clear();
}
inline ::google::protobuf::uint32 MapEntity::paintimages(int index) const {
  return paintimages_.Get(index);
}
inline void MapEntity::set_paintimages(int index, ::google::protobuf::uint32 value) {
  paintimages_.Set(index, value);
}
inline void MapEntity::add_paintimages(::google::protobuf::uint32 value) {
  paintimages_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MapEntity::paintimages() const {
  return paintimages_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MapEntity::mutable_paintimages() {
  return &paintimages_;
}

// -------------------------------------------------------------------

// ResearchTable

// required float researchTimeLeft = 1;
inline bool ResearchTable::has_researchtimeleft() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResearchTable::set_has_researchtimeleft() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResearchTable::clear_has_researchtimeleft() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResearchTable::clear_researchtimeleft() {
  researchtimeleft_ = 0;
  clear_has_researchtimeleft();
}
inline float ResearchTable::researchtimeleft() const {
  return researchtimeleft_;
}
inline void ResearchTable::set_researchtimeleft(float value) {
  set_has_researchtimeleft();
  researchtimeleft_ = value;
}

// -------------------------------------------------------------------

// DudExplosive

// required float fuseTimeLeft = 1;
inline bool DudExplosive::has_fusetimeleft() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DudExplosive::set_has_fusetimeleft() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DudExplosive::clear_has_fusetimeleft() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DudExplosive::clear_fusetimeleft() {
  fusetimeleft_ = 0;
  clear_has_fusetimeleft();
}
inline float DudExplosive::fusetimeleft() const {
  return fusetimeleft_;
}
inline void DudExplosive::set_fusetimeleft(float value) {
  set_has_fusetimeleft();
  fusetimeleft_ = value;
}

// -------------------------------------------------------------------

// ResourceExtractor

// optional .ItemContainer fuelContents = 1;
inline bool ResourceExtractor::has_fuelcontents() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceExtractor::set_has_fuelcontents() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceExtractor::clear_has_fuelcontents() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceExtractor::clear_fuelcontents() {
  if (fuelcontents_ != NULL) fuelcontents_->::ItemContainer::Clear();
  clear_has_fuelcontents();
}
inline const ::ItemContainer& ResourceExtractor::fuelcontents() const {
  return fuelcontents_ != NULL ? *fuelcontents_ : *default_instance_->fuelcontents_;
}
inline ::ItemContainer* ResourceExtractor::mutable_fuelcontents() {
  set_has_fuelcontents();
  if (fuelcontents_ == NULL) fuelcontents_ = new ::ItemContainer;
  return fuelcontents_;
}
inline ::ItemContainer* ResourceExtractor::release_fuelcontents() {
  clear_has_fuelcontents();
  ::ItemContainer* temp = fuelcontents_;
  fuelcontents_ = NULL;
  return temp;
}
inline void ResourceExtractor::set_allocated_fuelcontents(::ItemContainer* fuelcontents) {
  delete fuelcontents_;
  fuelcontents_ = fuelcontents;
  if (fuelcontents) {
    set_has_fuelcontents();
  } else {
    clear_has_fuelcontents();
  }
}

// optional .ItemContainer outputContents = 2;
inline bool ResourceExtractor::has_outputcontents() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResourceExtractor::set_has_outputcontents() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResourceExtractor::clear_has_outputcontents() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResourceExtractor::clear_outputcontents() {
  if (outputcontents_ != NULL) outputcontents_->::ItemContainer::Clear();
  clear_has_outputcontents();
}
inline const ::ItemContainer& ResourceExtractor::outputcontents() const {
  return outputcontents_ != NULL ? *outputcontents_ : *default_instance_->outputcontents_;
}
inline ::ItemContainer* ResourceExtractor::mutable_outputcontents() {
  set_has_outputcontents();
  if (outputcontents_ == NULL) outputcontents_ = new ::ItemContainer;
  return outputcontents_;
}
inline ::ItemContainer* ResourceExtractor::release_outputcontents() {
  clear_has_outputcontents();
  ::ItemContainer* temp = outputcontents_;
  outputcontents_ = NULL;
  return temp;
}
inline void ResourceExtractor::set_allocated_outputcontents(::ItemContainer* outputcontents) {
  delete outputcontents_;
  outputcontents_ = outputcontents;
  if (outputcontents) {
    set_has_outputcontents();
  } else {
    clear_has_outputcontents();
  }
}

// -------------------------------------------------------------------

// MiningQuarry

// optional .ResourceExtractor extractor = 1;
inline bool MiningQuarry::has_extractor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MiningQuarry::set_has_extractor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MiningQuarry::clear_has_extractor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MiningQuarry::clear_extractor() {
  if (extractor_ != NULL) extractor_->::ResourceExtractor::Clear();
  clear_has_extractor();
}
inline const ::ResourceExtractor& MiningQuarry::extractor() const {
  return extractor_ != NULL ? *extractor_ : *default_instance_->extractor_;
}
inline ::ResourceExtractor* MiningQuarry::mutable_extractor() {
  set_has_extractor();
  if (extractor_ == NULL) extractor_ = new ::ResourceExtractor;
  return extractor_;
}
inline ::ResourceExtractor* MiningQuarry::release_extractor() {
  clear_has_extractor();
  ::ResourceExtractor* temp = extractor_;
  extractor_ = NULL;
  return temp;
}
inline void MiningQuarry::set_allocated_extractor(::ResourceExtractor* extractor) {
  delete extractor_;
  extractor_ = extractor;
  if (extractor) {
    set_has_extractor();
  } else {
    clear_has_extractor();
  }
}

// -------------------------------------------------------------------

// PlantEntity

// required uint64 state = 1;
inline bool PlantEntity::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlantEntity::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlantEntity::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlantEntity::clear_state() {
  state_ = GOOGLE_ULONGLONG(0);
  clear_has_state();
}
inline ::google::protobuf::uint64 PlantEntity::state() const {
  return state_;
}
inline void PlantEntity::set_state(::google::protobuf::uint64 value) {
  set_has_state();
  state_ = value;
}

// required float age = 2;
inline bool PlantEntity::has_age() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlantEntity::set_has_age() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlantEntity::clear_has_age() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlantEntity::clear_age() {
  age_ = 0;
  clear_has_age();
}
inline float PlantEntity::age() const {
  return age_;
}
inline void PlantEntity::set_age(float value) {
  set_has_age();
  age_ = value;
}

// required uint64 genetics = 3;
inline bool PlantEntity::has_genetics() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlantEntity::set_has_genetics() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlantEntity::clear_has_genetics() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlantEntity::clear_genetics() {
  genetics_ = GOOGLE_ULONGLONG(0);
  clear_has_genetics();
}
inline ::google::protobuf::uint64 PlantEntity::genetics() const {
  return genetics_;
}
inline void PlantEntity::set_genetics(::google::protobuf::uint64 value) {
  set_has_genetics();
  genetics_ = value;
}

// required uint64 water = 4;
inline bool PlantEntity::has_water() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlantEntity::set_has_water() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlantEntity::clear_has_water() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlantEntity::clear_water() {
  water_ = GOOGLE_ULONGLONG(0);
  clear_has_water();
}
inline ::google::protobuf::uint64 PlantEntity::water() const {
  return water_;
}
inline void PlantEntity::set_water(::google::protobuf::uint64 value) {
  set_has_water();
  water_ = value;
}

// required float healthy = 5;
inline bool PlantEntity::has_healthy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlantEntity::set_has_healthy() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlantEntity::clear_has_healthy() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlantEntity::clear_healthy() {
  healthy_ = 0;
  clear_has_healthy();
}
inline float PlantEntity::healthy() const {
  return healthy_;
}
inline void PlantEntity::set_healthy(float value) {
  set_has_healthy();
  healthy_ = value;
}

// -------------------------------------------------------------------

// Helicopter

// required .Vector3Serialized tiltRot = 1;
inline bool Helicopter::has_tiltrot() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Helicopter::set_has_tiltrot() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Helicopter::clear_has_tiltrot() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Helicopter::clear_tiltrot() {
  if (tiltrot_ != NULL) tiltrot_->::Vector3Serialized::Clear();
  clear_has_tiltrot();
}
inline const ::Vector3Serialized& Helicopter::tiltrot() const {
  return tiltrot_ != NULL ? *tiltrot_ : *default_instance_->tiltrot_;
}
inline ::Vector3Serialized* Helicopter::mutable_tiltrot() {
  set_has_tiltrot();
  if (tiltrot_ == NULL) tiltrot_ = new ::Vector3Serialized;
  return tiltrot_;
}
inline ::Vector3Serialized* Helicopter::release_tiltrot() {
  clear_has_tiltrot();
  ::Vector3Serialized* temp = tiltrot_;
  tiltrot_ = NULL;
  return temp;
}
inline void Helicopter::set_allocated_tiltrot(::Vector3Serialized* tiltrot) {
  delete tiltrot_;
  tiltrot_ = tiltrot;
  if (tiltrot) {
    set_has_tiltrot();
  } else {
    clear_has_tiltrot();
  }
}

// required .Vector3Serialized leftGun = 2;
inline bool Helicopter::has_leftgun() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Helicopter::set_has_leftgun() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Helicopter::clear_has_leftgun() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Helicopter::clear_leftgun() {
  if (leftgun_ != NULL) leftgun_->::Vector3Serialized::Clear();
  clear_has_leftgun();
}
inline const ::Vector3Serialized& Helicopter::leftgun() const {
  return leftgun_ != NULL ? *leftgun_ : *default_instance_->leftgun_;
}
inline ::Vector3Serialized* Helicopter::mutable_leftgun() {
  set_has_leftgun();
  if (leftgun_ == NULL) leftgun_ = new ::Vector3Serialized;
  return leftgun_;
}
inline ::Vector3Serialized* Helicopter::release_leftgun() {
  clear_has_leftgun();
  ::Vector3Serialized* temp = leftgun_;
  leftgun_ = NULL;
  return temp;
}
inline void Helicopter::set_allocated_leftgun(::Vector3Serialized* leftgun) {
  delete leftgun_;
  leftgun_ = leftgun;
  if (leftgun) {
    set_has_leftgun();
  } else {
    clear_has_leftgun();
  }
}

// required .Vector3Serialized rightGun = 3;
inline bool Helicopter::has_rightgun() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Helicopter::set_has_rightgun() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Helicopter::clear_has_rightgun() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Helicopter::clear_rightgun() {
  if (rightgun_ != NULL) rightgun_->::Vector3Serialized::Clear();
  clear_has_rightgun();
}
inline const ::Vector3Serialized& Helicopter::rightgun() const {
  return rightgun_ != NULL ? *rightgun_ : *default_instance_->rightgun_;
}
inline ::Vector3Serialized* Helicopter::mutable_rightgun() {
  set_has_rightgun();
  if (rightgun_ == NULL) rightgun_ = new ::Vector3Serialized;
  return rightgun_;
}
inline ::Vector3Serialized* Helicopter::release_rightgun() {
  clear_has_rightgun();
  ::Vector3Serialized* temp = rightgun_;
  rightgun_ = NULL;
  return temp;
}
inline void Helicopter::set_allocated_rightgun(::Vector3Serialized* rightgun) {
  delete rightgun_;
  rightgun_ = rightgun;
  if (rightgun) {
    set_has_rightgun();
  } else {
    clear_has_rightgun();
  }
}

// required .Vector3Serialized spotlightVec = 4;
inline bool Helicopter::has_spotlightvec() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Helicopter::set_has_spotlightvec() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Helicopter::clear_has_spotlightvec() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Helicopter::clear_spotlightvec() {
  if (spotlightvec_ != NULL) spotlightvec_->::Vector3Serialized::Clear();
  clear_has_spotlightvec();
}
inline const ::Vector3Serialized& Helicopter::spotlightvec() const {
  return spotlightvec_ != NULL ? *spotlightvec_ : *default_instance_->spotlightvec_;
}
inline ::Vector3Serialized* Helicopter::mutable_spotlightvec() {
  set_has_spotlightvec();
  if (spotlightvec_ == NULL) spotlightvec_ = new ::Vector3Serialized;
  return spotlightvec_;
}
inline ::Vector3Serialized* Helicopter::release_spotlightvec() {
  clear_has_spotlightvec();
  ::Vector3Serialized* temp = spotlightvec_;
  spotlightvec_ = NULL;
  return temp;
}
inline void Helicopter::set_allocated_spotlightvec(::Vector3Serialized* spotlightvec) {
  delete spotlightvec_;
  spotlightvec_ = spotlightvec;
  if (spotlightvec) {
    set_has_spotlightvec();
  } else {
    clear_has_spotlightvec();
  }
}

// repeated float weakspothealths = 5;
inline int Helicopter::weakspothealths_size() const {
  return weakspothealths_.size();
}
inline void Helicopter::clear_weakspothealths() {
  weakspothealths_.Clear();
}
inline float Helicopter::weakspothealths(int index) const {
  return weakspothealths_.Get(index);
}
inline void Helicopter::set_weakspothealths(int index, float value) {
  weakspothealths_.Set(index, value);
}
inline void Helicopter::add_weakspothealths(float value) {
  weakspothealths_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
Helicopter::weakspothealths() const {
  return weakspothealths_;
}
inline ::google::protobuf::RepeatedField< float >*
Helicopter::mutable_weakspothealths() {
  return &weakspothealths_;
}

// -------------------------------------------------------------------

// Landmine

// required uint64 triggeredID = 1;
inline bool Landmine::has_triggeredid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Landmine::set_has_triggeredid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Landmine::clear_has_triggeredid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Landmine::clear_triggeredid() {
  triggeredid_ = GOOGLE_ULONGLONG(0);
  clear_has_triggeredid();
}
inline ::google::protobuf::uint64 Landmine::triggeredid() const {
  return triggeredid_;
}
inline void Landmine::set_triggeredid(::google::protobuf::uint64 value) {
  set_has_triggeredid();
  triggeredid_ = value;
}

// -------------------------------------------------------------------

// AutoTurret

// required .Vector3Serialized aimPos = 1;
inline bool AutoTurret::has_aimpos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AutoTurret::set_has_aimpos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AutoTurret::clear_has_aimpos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AutoTurret::clear_aimpos() {
  if (aimpos_ != NULL) aimpos_->::Vector3Serialized::Clear();
  clear_has_aimpos();
}
inline const ::Vector3Serialized& AutoTurret::aimpos() const {
  return aimpos_ != NULL ? *aimpos_ : *default_instance_->aimpos_;
}
inline ::Vector3Serialized* AutoTurret::mutable_aimpos() {
  set_has_aimpos();
  if (aimpos_ == NULL) aimpos_ = new ::Vector3Serialized;
  return aimpos_;
}
inline ::Vector3Serialized* AutoTurret::release_aimpos() {
  clear_has_aimpos();
  ::Vector3Serialized* temp = aimpos_;
  aimpos_ = NULL;
  return temp;
}
inline void AutoTurret::set_allocated_aimpos(::Vector3Serialized* aimpos) {
  delete aimpos_;
  aimpos_ = aimpos;
  if (aimpos) {
    set_has_aimpos();
  } else {
    clear_has_aimpos();
  }
}

// required .Vector3Serialized aimDir = 2;
inline bool AutoTurret::has_aimdir() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AutoTurret::set_has_aimdir() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AutoTurret::clear_has_aimdir() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AutoTurret::clear_aimdir() {
  if (aimdir_ != NULL) aimdir_->::Vector3Serialized::Clear();
  clear_has_aimdir();
}
inline const ::Vector3Serialized& AutoTurret::aimdir() const {
  return aimdir_ != NULL ? *aimdir_ : *default_instance_->aimdir_;
}
inline ::Vector3Serialized* AutoTurret::mutable_aimdir() {
  set_has_aimdir();
  if (aimdir_ == NULL) aimdir_ = new ::Vector3Serialized;
  return aimdir_;
}
inline ::Vector3Serialized* AutoTurret::release_aimdir() {
  clear_has_aimdir();
  ::Vector3Serialized* temp = aimdir_;
  aimdir_ = NULL;
  return temp;
}
inline void AutoTurret::set_allocated_aimdir(::Vector3Serialized* aimdir) {
  delete aimdir_;
  aimdir_ = aimdir;
  if (aimdir) {
    set_has_aimdir();
  } else {
    clear_has_aimdir();
  }
}

// required uint32 targetID = 3;
inline bool AutoTurret::has_targetid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AutoTurret::set_has_targetid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AutoTurret::clear_has_targetid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AutoTurret::clear_targetid() {
  targetid_ = 0u;
  clear_has_targetid();
}
inline ::google::protobuf::uint32 AutoTurret::targetid() const {
  return targetid_;
}
inline void AutoTurret::set_targetid(::google::protobuf::uint32 value) {
  set_has_targetid();
  targetid_ = value;
}

// repeated .PlayerNameID users = 4;
inline int AutoTurret::users_size() const {
  return users_.size();
}
inline void AutoTurret::clear_users() {
  users_.Clear();
}
inline const ::PlayerNameID& AutoTurret::users(int index) const {
  return users_.Get(index);
}
inline ::PlayerNameID* AutoTurret::mutable_users(int index) {
  return users_.Mutable(index);
}
inline ::PlayerNameID* AutoTurret::add_users() {
  return users_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerNameID >&
AutoTurret::users() const {
  return users_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerNameID >*
AutoTurret::mutable_users() {
  return &users_;
}

// -------------------------------------------------------------------

// SphereEntity

// required float radius = 1;
inline bool SphereEntity::has_radius() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SphereEntity::set_has_radius() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SphereEntity::clear_has_radius() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SphereEntity::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline float SphereEntity::radius() const {
  return radius_;
}
inline void SphereEntity::set_radius(float value) {
  set_has_radius();
  radius_ = value;
}

// -------------------------------------------------------------------

// StabilityEntity

// required float stability = 1;
inline bool StabilityEntity::has_stability() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StabilityEntity::set_has_stability() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StabilityEntity::clear_has_stability() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StabilityEntity::clear_stability() {
  stability_ = 0;
  clear_has_stability();
}
inline float StabilityEntity::stability() const {
  return stability_;
}
inline void StabilityEntity::set_stability(float value) {
  set_has_stability();
  stability_ = value;
}

// required uint64 distanceFromGround = 2;
inline bool StabilityEntity::has_distancefromground() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StabilityEntity::set_has_distancefromground() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StabilityEntity::clear_has_distancefromground() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StabilityEntity::clear_distancefromground() {
  distancefromground_ = GOOGLE_ULONGLONG(0);
  clear_has_distancefromground();
}
inline ::google::protobuf::uint64 StabilityEntity::distancefromground() const {
  return distancefromground_;
}
inline void StabilityEntity::set_distancefromground(::google::protobuf::uint64 value) {
  set_has_distancefromground();
  distancefromground_ = value;
}

// -------------------------------------------------------------------

// OwnerInfo

// required uint64 steamid = 1;
inline bool OwnerInfo::has_steamid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OwnerInfo::set_has_steamid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OwnerInfo::clear_has_steamid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OwnerInfo::clear_steamid() {
  steamid_ = GOOGLE_ULONGLONG(0);
  clear_has_steamid();
}
inline ::google::protobuf::uint64 OwnerInfo::steamid() const {
  return steamid_;
}
inline void OwnerInfo::set_steamid(::google::protobuf::uint64 value) {
  set_has_steamid();
  steamid_ = value;
}

// -------------------------------------------------------------------

// DecayEntity

// required float decayTimer = 1;
inline bool DecayEntity::has_decaytimer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DecayEntity::set_has_decaytimer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DecayEntity::clear_has_decaytimer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DecayEntity::clear_decaytimer() {
  decaytimer_ = 0;
  clear_has_decaytimer();
}
inline float DecayEntity::decaytimer() const {
  return decaytimer_;
}
inline void DecayEntity::set_decaytimer(float value) {
  set_has_decaytimer();
  decaytimer_ = value;
}

// -------------------------------------------------------------------

// Spawnable

// required uint32 population = 1;
inline bool Spawnable::has_population() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Spawnable::set_has_population() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Spawnable::clear_has_population() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Spawnable::clear_population() {
  population_ = 0u;
  clear_has_population();
}
inline ::google::protobuf::uint32 Spawnable::population() const {
  return population_;
}
inline void Spawnable::set_population(::google::protobuf::uint32 value) {
  set_has_population();
  population_ = value;
}

// -------------------------------------------------------------------

// ServerGib

// optional string gibName = 1;
inline bool ServerGib::has_gibname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerGib::set_has_gibname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerGib::clear_has_gibname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerGib::clear_gibname() {
  if (gibname_ != &::google::protobuf::internal::kEmptyString) {
    gibname_->clear();
  }
  clear_has_gibname();
}
inline const ::std::string& ServerGib::gibname() const {
  return *gibname_;
}
inline void ServerGib::set_gibname(const ::std::string& value) {
  set_has_gibname();
  if (gibname_ == &::google::protobuf::internal::kEmptyString) {
    gibname_ = new ::std::string;
  }
  gibname_->assign(value);
}
inline void ServerGib::set_gibname(const char* value) {
  set_has_gibname();
  if (gibname_ == &::google::protobuf::internal::kEmptyString) {
    gibname_ = new ::std::string;
  }
  gibname_->assign(value);
}
inline void ServerGib::set_gibname(const char* value, size_t size) {
  set_has_gibname();
  if (gibname_ == &::google::protobuf::internal::kEmptyString) {
    gibname_ = new ::std::string;
  }
  gibname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerGib::mutable_gibname() {
  set_has_gibname();
  if (gibname_ == &::google::protobuf::internal::kEmptyString) {
    gibname_ = new ::std::string;
  }
  return gibname_;
}
inline ::std::string* ServerGib::release_gibname() {
  clear_has_gibname();
  if (gibname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gibname_;
    gibname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerGib::set_allocated_gibname(::std::string* gibname) {
  if (gibname_ != &::google::protobuf::internal::kEmptyString) {
    delete gibname_;
  }
  if (gibname) {
    set_has_gibname();
    gibname_ = gibname;
  } else {
    clear_has_gibname();
    gibname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// VendingMachine_SellOrder

// required uint64 itemToSellID = 1;
inline bool VendingMachine_SellOrder::has_itemtosellid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VendingMachine_SellOrder::set_has_itemtosellid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VendingMachine_SellOrder::clear_has_itemtosellid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VendingMachine_SellOrder::clear_itemtosellid() {
  itemtosellid_ = GOOGLE_ULONGLONG(0);
  clear_has_itemtosellid();
}
inline ::google::protobuf::uint64 VendingMachine_SellOrder::itemtosellid() const {
  return itemtosellid_;
}
inline void VendingMachine_SellOrder::set_itemtosellid(::google::protobuf::uint64 value) {
  set_has_itemtosellid();
  itemtosellid_ = value;
}

// required uint64 itemToSellAmount = 2;
inline bool VendingMachine_SellOrder::has_itemtosellamount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VendingMachine_SellOrder::set_has_itemtosellamount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VendingMachine_SellOrder::clear_has_itemtosellamount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VendingMachine_SellOrder::clear_itemtosellamount() {
  itemtosellamount_ = GOOGLE_ULONGLONG(0);
  clear_has_itemtosellamount();
}
inline ::google::protobuf::uint64 VendingMachine_SellOrder::itemtosellamount() const {
  return itemtosellamount_;
}
inline void VendingMachine_SellOrder::set_itemtosellamount(::google::protobuf::uint64 value) {
  set_has_itemtosellamount();
  itemtosellamount_ = value;
}

// required uint64 currencyID = 3;
inline bool VendingMachine_SellOrder::has_currencyid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VendingMachine_SellOrder::set_has_currencyid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VendingMachine_SellOrder::clear_has_currencyid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VendingMachine_SellOrder::clear_currencyid() {
  currencyid_ = GOOGLE_ULONGLONG(0);
  clear_has_currencyid();
}
inline ::google::protobuf::uint64 VendingMachine_SellOrder::currencyid() const {
  return currencyid_;
}
inline void VendingMachine_SellOrder::set_currencyid(::google::protobuf::uint64 value) {
  set_has_currencyid();
  currencyid_ = value;
}

// required uint64 currencyAmountPerItem = 4;
inline bool VendingMachine_SellOrder::has_currencyamountperitem() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VendingMachine_SellOrder::set_has_currencyamountperitem() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VendingMachine_SellOrder::clear_has_currencyamountperitem() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VendingMachine_SellOrder::clear_currencyamountperitem() {
  currencyamountperitem_ = GOOGLE_ULONGLONG(0);
  clear_has_currencyamountperitem();
}
inline ::google::protobuf::uint64 VendingMachine_SellOrder::currencyamountperitem() const {
  return currencyamountperitem_;
}
inline void VendingMachine_SellOrder::set_currencyamountperitem(::google::protobuf::uint64 value) {
  set_has_currencyamountperitem();
  currencyamountperitem_ = value;
}

// required uint64 inStock = 5;
inline bool VendingMachine_SellOrder::has_instock() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VendingMachine_SellOrder::set_has_instock() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VendingMachine_SellOrder::clear_has_instock() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VendingMachine_SellOrder::clear_instock() {
  instock_ = GOOGLE_ULONGLONG(0);
  clear_has_instock();
}
inline ::google::protobuf::uint64 VendingMachine_SellOrder::instock() const {
  return instock_;
}
inline void VendingMachine_SellOrder::set_instock(::google::protobuf::uint64 value) {
  set_has_instock();
  instock_ = value;
}

// -------------------------------------------------------------------

// VendingMachine_SellOrderContainer

// repeated .VendingMachine.SellOrder sellOrders = 1;
inline int VendingMachine_SellOrderContainer::sellorders_size() const {
  return sellorders_.size();
}
inline void VendingMachine_SellOrderContainer::clear_sellorders() {
  sellorders_.Clear();
}
inline const ::VendingMachine_SellOrder& VendingMachine_SellOrderContainer::sellorders(int index) const {
  return sellorders_.Get(index);
}
inline ::VendingMachine_SellOrder* VendingMachine_SellOrderContainer::mutable_sellorders(int index) {
  return sellorders_.Mutable(index);
}
inline ::VendingMachine_SellOrder* VendingMachine_SellOrderContainer::add_sellorders() {
  return sellorders_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::VendingMachine_SellOrder >&
VendingMachine_SellOrderContainer::sellorders() const {
  return sellorders_;
}
inline ::google::protobuf::RepeatedPtrField< ::VendingMachine_SellOrder >*
VendingMachine_SellOrderContainer::mutable_sellorders() {
  return &sellorders_;
}

// -------------------------------------------------------------------

// VendingMachine

// optional .VendingMachine.SellOrderContainer sellOrderContainer = 1;
inline bool VendingMachine::has_sellordercontainer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VendingMachine::set_has_sellordercontainer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VendingMachine::clear_has_sellordercontainer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VendingMachine::clear_sellordercontainer() {
  if (sellordercontainer_ != NULL) sellordercontainer_->::VendingMachine_SellOrderContainer::Clear();
  clear_has_sellordercontainer();
}
inline const ::VendingMachine_SellOrderContainer& VendingMachine::sellordercontainer() const {
  return sellordercontainer_ != NULL ? *sellordercontainer_ : *default_instance_->sellordercontainer_;
}
inline ::VendingMachine_SellOrderContainer* VendingMachine::mutable_sellordercontainer() {
  set_has_sellordercontainer();
  if (sellordercontainer_ == NULL) sellordercontainer_ = new ::VendingMachine_SellOrderContainer;
  return sellordercontainer_;
}
inline ::VendingMachine_SellOrderContainer* VendingMachine::release_sellordercontainer() {
  clear_has_sellordercontainer();
  ::VendingMachine_SellOrderContainer* temp = sellordercontainer_;
  sellordercontainer_ = NULL;
  return temp;
}
inline void VendingMachine::set_allocated_sellordercontainer(::VendingMachine_SellOrderContainer* sellordercontainer) {
  delete sellordercontainer_;
  sellordercontainer_ = sellordercontainer;
  if (sellordercontainer) {
    set_has_sellordercontainer();
  } else {
    clear_has_sellordercontainer();
  }
}

// optional string shopName = 2;
inline bool VendingMachine::has_shopname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VendingMachine::set_has_shopname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VendingMachine::clear_has_shopname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VendingMachine::clear_shopname() {
  if (shopname_ != &::google::protobuf::internal::kEmptyString) {
    shopname_->clear();
  }
  clear_has_shopname();
}
inline const ::std::string& VendingMachine::shopname() const {
  return *shopname_;
}
inline void VendingMachine::set_shopname(const ::std::string& value) {
  set_has_shopname();
  if (shopname_ == &::google::protobuf::internal::kEmptyString) {
    shopname_ = new ::std::string;
  }
  shopname_->assign(value);
}
inline void VendingMachine::set_shopname(const char* value) {
  set_has_shopname();
  if (shopname_ == &::google::protobuf::internal::kEmptyString) {
    shopname_ = new ::std::string;
  }
  shopname_->assign(value);
}
inline void VendingMachine::set_shopname(const char* value, size_t size) {
  set_has_shopname();
  if (shopname_ == &::google::protobuf::internal::kEmptyString) {
    shopname_ = new ::std::string;
  }
  shopname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VendingMachine::mutable_shopname() {
  set_has_shopname();
  if (shopname_ == &::google::protobuf::internal::kEmptyString) {
    shopname_ = new ::std::string;
  }
  return shopname_;
}
inline ::std::string* VendingMachine::release_shopname() {
  clear_has_shopname();
  if (shopname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = shopname_;
    shopname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VendingMachine::set_allocated_shopname(::std::string* shopname) {
  if (shopname_ != &::google::protobuf::internal::kEmptyString) {
    delete shopname_;
  }
  if (shopname) {
    set_has_shopname();
    shopname_ = shopname;
  } else {
    clear_has_shopname();
    shopname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SpinnerWheel

// required .Vector3Serialized spin = 1;
inline bool SpinnerWheel::has_spin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpinnerWheel::set_has_spin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpinnerWheel::clear_has_spin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpinnerWheel::clear_spin() {
  if (spin_ != NULL) spin_->::Vector3Serialized::Clear();
  clear_has_spin();
}
inline const ::Vector3Serialized& SpinnerWheel::spin() const {
  return spin_ != NULL ? *spin_ : *default_instance_->spin_;
}
inline ::Vector3Serialized* SpinnerWheel::mutable_spin() {
  set_has_spin();
  if (spin_ == NULL) spin_ = new ::Vector3Serialized;
  return spin_;
}
inline ::Vector3Serialized* SpinnerWheel::release_spin() {
  clear_has_spin();
  ::Vector3Serialized* temp = spin_;
  spin_ = NULL;
  return temp;
}
inline void SpinnerWheel::set_allocated_spin(::Vector3Serialized* spin) {
  delete spin_;
  spin_ = spin;
  if (spin) {
    set_has_spin();
  } else {
    clear_has_spin();
  }
}

// -------------------------------------------------------------------

// Entity

// optional .BaseNetworkable baseNetworkable = 1;
inline bool Entity::has_basenetworkable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Entity::set_has_basenetworkable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Entity::clear_has_basenetworkable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Entity::clear_basenetworkable() {
  if (basenetworkable_ != NULL) basenetworkable_->::BaseNetworkable::Clear();
  clear_has_basenetworkable();
}
inline const ::BaseNetworkable& Entity::basenetworkable() const {
  return basenetworkable_ != NULL ? *basenetworkable_ : *default_instance_->basenetworkable_;
}
inline ::BaseNetworkable* Entity::mutable_basenetworkable() {
  set_has_basenetworkable();
  if (basenetworkable_ == NULL) basenetworkable_ = new ::BaseNetworkable;
  return basenetworkable_;
}
inline ::BaseNetworkable* Entity::release_basenetworkable() {
  clear_has_basenetworkable();
  ::BaseNetworkable* temp = basenetworkable_;
  basenetworkable_ = NULL;
  return temp;
}
inline void Entity::set_allocated_basenetworkable(::BaseNetworkable* basenetworkable) {
  delete basenetworkable_;
  basenetworkable_ = basenetworkable;
  if (basenetworkable) {
    set_has_basenetworkable();
  } else {
    clear_has_basenetworkable();
  }
}

// optional .BaseEntity baseEntity = 2;
inline bool Entity::has_baseentity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Entity::set_has_baseentity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Entity::clear_has_baseentity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Entity::clear_baseentity() {
  if (baseentity_ != NULL) baseentity_->::BaseEntity::Clear();
  clear_has_baseentity();
}
inline const ::BaseEntity& Entity::baseentity() const {
  return baseentity_ != NULL ? *baseentity_ : *default_instance_->baseentity_;
}
inline ::BaseEntity* Entity::mutable_baseentity() {
  set_has_baseentity();
  if (baseentity_ == NULL) baseentity_ = new ::BaseEntity;
  return baseentity_;
}
inline ::BaseEntity* Entity::release_baseentity() {
  clear_has_baseentity();
  ::BaseEntity* temp = baseentity_;
  baseentity_ = NULL;
  return temp;
}
inline void Entity::set_allocated_baseentity(::BaseEntity* baseentity) {
  delete baseentity_;
  baseentity_ = baseentity;
  if (baseentity) {
    set_has_baseentity();
  } else {
    clear_has_baseentity();
  }
}

// optional .BasePlayer basePlayer = 3;
inline bool Entity::has_baseplayer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Entity::set_has_baseplayer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Entity::clear_has_baseplayer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Entity::clear_baseplayer() {
  if (baseplayer_ != NULL) baseplayer_->::BasePlayer::Clear();
  clear_has_baseplayer();
}
inline const ::BasePlayer& Entity::baseplayer() const {
  return baseplayer_ != NULL ? *baseplayer_ : *default_instance_->baseplayer_;
}
inline ::BasePlayer* Entity::mutable_baseplayer() {
  set_has_baseplayer();
  if (baseplayer_ == NULL) baseplayer_ = new ::BasePlayer;
  return baseplayer_;
}
inline ::BasePlayer* Entity::release_baseplayer() {
  clear_has_baseplayer();
  ::BasePlayer* temp = baseplayer_;
  baseplayer_ = NULL;
  return temp;
}
inline void Entity::set_allocated_baseplayer(::BasePlayer* baseplayer) {
  delete baseplayer_;
  baseplayer_ = baseplayer;
  if (baseplayer) {
    set_has_baseplayer();
  } else {
    clear_has_baseplayer();
  }
}

// optional .WorldItem worldItem = 4;
inline bool Entity::has_worlditem() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Entity::set_has_worlditem() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Entity::clear_has_worlditem() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Entity::clear_worlditem() {
  if (worlditem_ != NULL) worlditem_->::WorldItem::Clear();
  clear_has_worlditem();
}
inline const ::WorldItem& Entity::worlditem() const {
  return worlditem_ != NULL ? *worlditem_ : *default_instance_->worlditem_;
}
inline ::WorldItem* Entity::mutable_worlditem() {
  set_has_worlditem();
  if (worlditem_ == NULL) worlditem_ = new ::WorldItem;
  return worlditem_;
}
inline ::WorldItem* Entity::release_worlditem() {
  clear_has_worlditem();
  ::WorldItem* temp = worlditem_;
  worlditem_ = NULL;
  return temp;
}
inline void Entity::set_allocated_worlditem(::WorldItem* worlditem) {
  delete worlditem_;
  worlditem_ = worlditem;
  if (worlditem) {
    set_has_worlditem();
  } else {
    clear_has_worlditem();
  }
}

// optional .BaseResource resource = 5;
inline bool Entity::has_resource() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Entity::set_has_resource() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Entity::clear_has_resource() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Entity::clear_resource() {
  if (resource_ != NULL) resource_->::BaseResource::Clear();
  clear_has_resource();
}
inline const ::BaseResource& Entity::resource() const {
  return resource_ != NULL ? *resource_ : *default_instance_->resource_;
}
inline ::BaseResource* Entity::mutable_resource() {
  set_has_resource();
  if (resource_ == NULL) resource_ = new ::BaseResource;
  return resource_;
}
inline ::BaseResource* Entity::release_resource() {
  clear_has_resource();
  ::BaseResource* temp = resource_;
  resource_ = NULL;
  return temp;
}
inline void Entity::set_allocated_resource(::BaseResource* resource) {
  delete resource_;
  resource_ = resource;
  if (resource) {
    set_has_resource();
  } else {
    clear_has_resource();
  }
}

// optional .BuildingBlock buildingBlock = 6;
inline bool Entity::has_buildingblock() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Entity::set_has_buildingblock() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Entity::clear_has_buildingblock() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Entity::clear_buildingblock() {
  if (buildingblock_ != NULL) buildingblock_->::BuildingBlock::Clear();
  clear_has_buildingblock();
}
inline const ::BuildingBlock& Entity::buildingblock() const {
  return buildingblock_ != NULL ? *buildingblock_ : *default_instance_->buildingblock_;
}
inline ::BuildingBlock* Entity::mutable_buildingblock() {
  set_has_buildingblock();
  if (buildingblock_ == NULL) buildingblock_ = new ::BuildingBlock;
  return buildingblock_;
}
inline ::BuildingBlock* Entity::release_buildingblock() {
  clear_has_buildingblock();
  ::BuildingBlock* temp = buildingblock_;
  buildingblock_ = NULL;
  return temp;
}
inline void Entity::set_allocated_buildingblock(::BuildingBlock* buildingblock) {
  delete buildingblock_;
  buildingblock_ = buildingblock;
  if (buildingblock) {
    set_has_buildingblock();
  } else {
    clear_has_buildingblock();
  }
}

// optional .Environment environment = 7;
inline bool Entity::has_environment() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Entity::set_has_environment() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Entity::clear_has_environment() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Entity::clear_environment() {
  if (environment_ != NULL) environment_->::Environment::Clear();
  clear_has_environment();
}
inline const ::Environment& Entity::environment() const {
  return environment_ != NULL ? *environment_ : *default_instance_->environment_;
}
inline ::Environment* Entity::mutable_environment() {
  set_has_environment();
  if (environment_ == NULL) environment_ = new ::Environment;
  return environment_;
}
inline ::Environment* Entity::release_environment() {
  clear_has_environment();
  ::Environment* temp = environment_;
  environment_ = NULL;
  return temp;
}
inline void Entity::set_allocated_environment(::Environment* environment) {
  delete environment_;
  environment_ = environment;
  if (environment) {
    set_has_environment();
  } else {
    clear_has_environment();
  }
}

// optional .Corpse corpse = 8;
inline bool Entity::has_corpse() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Entity::set_has_corpse() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Entity::clear_has_corpse() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Entity::clear_corpse() {
  if (corpse_ != NULL) corpse_->::Corpse::Clear();
  clear_has_corpse();
}
inline const ::Corpse& Entity::corpse() const {
  return corpse_ != NULL ? *corpse_ : *default_instance_->corpse_;
}
inline ::Corpse* Entity::mutable_corpse() {
  set_has_corpse();
  if (corpse_ == NULL) corpse_ = new ::Corpse;
  return corpse_;
}
inline ::Corpse* Entity::release_corpse() {
  clear_has_corpse();
  ::Corpse* temp = corpse_;
  corpse_ = NULL;
  return temp;
}
inline void Entity::set_allocated_corpse(::Corpse* corpse) {
  delete corpse_;
  corpse_ = corpse;
  if (corpse) {
    set_has_corpse();
  } else {
    clear_has_corpse();
  }
}

// optional .ParentInfo parent = 10;
inline bool Entity::has_parent() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Entity::set_has_parent() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Entity::clear_has_parent() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Entity::clear_parent() {
  if (parent_ != NULL) parent_->::ParentInfo::Clear();
  clear_has_parent();
}
inline const ::ParentInfo& Entity::parent() const {
  return parent_ != NULL ? *parent_ : *default_instance_->parent_;
}
inline ::ParentInfo* Entity::mutable_parent() {
  set_has_parent();
  if (parent_ == NULL) parent_ = new ::ParentInfo;
  return parent_;
}
inline ::ParentInfo* Entity::release_parent() {
  clear_has_parent();
  ::ParentInfo* temp = parent_;
  parent_ = NULL;
  return temp;
}
inline void Entity::set_allocated_parent(::ParentInfo* parent) {
  delete parent_;
  parent_ = parent;
  if (parent) {
    set_has_parent();
  } else {
    clear_has_parent();
  }
}

// optional .KeyLock keyLock = 11;
inline bool Entity::has_keylock() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Entity::set_has_keylock() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Entity::clear_has_keylock() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Entity::clear_keylock() {
  if (keylock_ != NULL) keylock_->::KeyLock::Clear();
  clear_has_keylock();
}
inline const ::KeyLock& Entity::keylock() const {
  return keylock_ != NULL ? *keylock_ : *default_instance_->keylock_;
}
inline ::KeyLock* Entity::mutable_keylock() {
  set_has_keylock();
  if (keylock_ == NULL) keylock_ = new ::KeyLock;
  return keylock_;
}
inline ::KeyLock* Entity::release_keylock() {
  clear_has_keylock();
  ::KeyLock* temp = keylock_;
  keylock_ = NULL;
  return temp;
}
inline void Entity::set_allocated_keylock(::KeyLock* keylock) {
  delete keylock_;
  keylock_ = keylock;
  if (keylock) {
    set_has_keylock();
  } else {
    clear_has_keylock();
  }
}

// optional .CodeLock codeLock = 12;
inline bool Entity::has_codelock() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Entity::set_has_codelock() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Entity::clear_has_codelock() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Entity::clear_codelock() {
  if (codelock_ != NULL) codelock_->::CodeLock::Clear();
  clear_has_codelock();
}
inline const ::CodeLock& Entity::codelock() const {
  return codelock_ != NULL ? *codelock_ : *default_instance_->codelock_;
}
inline ::CodeLock* Entity::mutable_codelock() {
  set_has_codelock();
  if (codelock_ == NULL) codelock_ = new ::CodeLock;
  return codelock_;
}
inline ::CodeLock* Entity::release_codelock() {
  clear_has_codelock();
  ::CodeLock* temp = codelock_;
  codelock_ = NULL;
  return temp;
}
inline void Entity::set_allocated_codelock(::CodeLock* codelock) {
  delete codelock_;
  codelock_ = codelock;
  if (codelock) {
    set_has_codelock();
  } else {
    clear_has_codelock();
  }
}

// optional .EntitySlots entitySlots = 13;
inline bool Entity::has_entityslots() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Entity::set_has_entityslots() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Entity::clear_has_entityslots() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Entity::clear_entityslots() {
  if (entityslots_ != NULL) entityslots_->::EntitySlots::Clear();
  clear_has_entityslots();
}
inline const ::EntitySlots& Entity::entityslots() const {
  return entityslots_ != NULL ? *entityslots_ : *default_instance_->entityslots_;
}
inline ::EntitySlots* Entity::mutable_entityslots() {
  set_has_entityslots();
  if (entityslots_ == NULL) entityslots_ = new ::EntitySlots;
  return entityslots_;
}
inline ::EntitySlots* Entity::release_entityslots() {
  clear_has_entityslots();
  ::EntitySlots* temp = entityslots_;
  entityslots_ = NULL;
  return temp;
}
inline void Entity::set_allocated_entityslots(::EntitySlots* entityslots) {
  delete entityslots_;
  entityslots_ = entityslots;
  if (entityslots) {
    set_has_entityslots();
  } else {
    clear_has_entityslots();
  }
}

// optional .BuildingPrivilege buildingPrivilege = 14;
inline bool Entity::has_buildingprivilege() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Entity::set_has_buildingprivilege() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Entity::clear_has_buildingprivilege() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Entity::clear_buildingprivilege() {
  if (buildingprivilege_ != NULL) buildingprivilege_->::BuildingPrivilege::Clear();
  clear_has_buildingprivilege();
}
inline const ::BuildingPrivilege& Entity::buildingprivilege() const {
  return buildingprivilege_ != NULL ? *buildingprivilege_ : *default_instance_->buildingprivilege_;
}
inline ::BuildingPrivilege* Entity::mutable_buildingprivilege() {
  set_has_buildingprivilege();
  if (buildingprivilege_ == NULL) buildingprivilege_ = new ::BuildingPrivilege;
  return buildingprivilege_;
}
inline ::BuildingPrivilege* Entity::release_buildingprivilege() {
  clear_has_buildingprivilege();
  ::BuildingPrivilege* temp = buildingprivilege_;
  buildingprivilege_ = NULL;
  return temp;
}
inline void Entity::set_allocated_buildingprivilege(::BuildingPrivilege* buildingprivilege) {
  delete buildingprivilege_;
  buildingprivilege_ = buildingprivilege;
  if (buildingprivilege) {
    set_has_buildingprivilege();
  } else {
    clear_has_buildingprivilege();
  }
}

// optional .StorageBox storageBox = 15;
inline bool Entity::has_storagebox() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Entity::set_has_storagebox() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Entity::clear_has_storagebox() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Entity::clear_storagebox() {
  if (storagebox_ != NULL) storagebox_->::StorageBox::Clear();
  clear_has_storagebox();
}
inline const ::StorageBox& Entity::storagebox() const {
  return storagebox_ != NULL ? *storagebox_ : *default_instance_->storagebox_;
}
inline ::StorageBox* Entity::mutable_storagebox() {
  set_has_storagebox();
  if (storagebox_ == NULL) storagebox_ = new ::StorageBox;
  return storagebox_;
}
inline ::StorageBox* Entity::release_storagebox() {
  clear_has_storagebox();
  ::StorageBox* temp = storagebox_;
  storagebox_ = NULL;
  return temp;
}
inline void Entity::set_allocated_storagebox(::StorageBox* storagebox) {
  delete storagebox_;
  storagebox_ = storagebox;
  if (storagebox) {
    set_has_storagebox();
  } else {
    clear_has_storagebox();
  }
}

// optional .HeldEntity heldEntity = 16;
inline bool Entity::has_heldentity() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Entity::set_has_heldentity() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Entity::clear_has_heldentity() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Entity::clear_heldentity() {
  if (heldentity_ != NULL) heldentity_->::HeldEntity::Clear();
  clear_has_heldentity();
}
inline const ::HeldEntity& Entity::heldentity() const {
  return heldentity_ != NULL ? *heldentity_ : *default_instance_->heldentity_;
}
inline ::HeldEntity* Entity::mutable_heldentity() {
  set_has_heldentity();
  if (heldentity_ == NULL) heldentity_ = new ::HeldEntity;
  return heldentity_;
}
inline ::HeldEntity* Entity::release_heldentity() {
  clear_has_heldentity();
  ::HeldEntity* temp = heldentity_;
  heldentity_ = NULL;
  return temp;
}
inline void Entity::set_allocated_heldentity(::HeldEntity* heldentity) {
  delete heldentity_;
  heldentity_ = heldentity;
  if (heldentity) {
    set_has_heldentity();
  } else {
    clear_has_heldentity();
  }
}

// optional .BaseProjectile baseProjectile = 17;
inline bool Entity::has_baseprojectile() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Entity::set_has_baseprojectile() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Entity::clear_has_baseprojectile() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Entity::clear_baseprojectile() {
  if (baseprojectile_ != NULL) baseprojectile_->::BaseProjectile::Clear();
  clear_has_baseprojectile();
}
inline const ::BaseProjectile& Entity::baseprojectile() const {
  return baseprojectile_ != NULL ? *baseprojectile_ : *default_instance_->baseprojectile_;
}
inline ::BaseProjectile* Entity::mutable_baseprojectile() {
  set_has_baseprojectile();
  if (baseprojectile_ == NULL) baseprojectile_ = new ::BaseProjectile;
  return baseprojectile_;
}
inline ::BaseProjectile* Entity::release_baseprojectile() {
  clear_has_baseprojectile();
  ::BaseProjectile* temp = baseprojectile_;
  baseprojectile_ = NULL;
  return temp;
}
inline void Entity::set_allocated_baseprojectile(::BaseProjectile* baseprojectile) {
  delete baseprojectile_;
  baseprojectile_ = baseprojectile;
  if (baseprojectile) {
    set_has_baseprojectile();
  } else {
    clear_has_baseprojectile();
  }
}

// optional .BaseNPC baseNPC = 18;
inline bool Entity::has_basenpc() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Entity::set_has_basenpc() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Entity::clear_has_basenpc() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Entity::clear_basenpc() {
  if (basenpc_ != NULL) basenpc_->::BaseNPC::Clear();
  clear_has_basenpc();
}
inline const ::BaseNPC& Entity::basenpc() const {
  return basenpc_ != NULL ? *basenpc_ : *default_instance_->basenpc_;
}
inline ::BaseNPC* Entity::mutable_basenpc() {
  set_has_basenpc();
  if (basenpc_ == NULL) basenpc_ = new ::BaseNPC;
  return basenpc_;
}
inline ::BaseNPC* Entity::release_basenpc() {
  clear_has_basenpc();
  ::BaseNPC* temp = basenpc_;
  basenpc_ = NULL;
  return temp;
}
inline void Entity::set_allocated_basenpc(::BaseNPC* basenpc) {
  delete basenpc_;
  basenpc_ = basenpc;
  if (basenpc) {
    set_has_basenpc();
  } else {
    clear_has_basenpc();
  }
}

// optional .Loot loot = 19;
inline bool Entity::has_loot() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Entity::set_has_loot() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Entity::clear_has_loot() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Entity::clear_loot() {
  if (loot_ != NULL) loot_->::Loot::Clear();
  clear_has_loot();
}
inline const ::Loot& Entity::loot() const {
  return loot_ != NULL ? *loot_ : *default_instance_->loot_;
}
inline ::Loot* Entity::mutable_loot() {
  set_has_loot();
  if (loot_ == NULL) loot_ = new ::Loot;
  return loot_;
}
inline ::Loot* Entity::release_loot() {
  clear_has_loot();
  ::Loot* temp = loot_;
  loot_ = NULL;
  return temp;
}
inline void Entity::set_allocated_loot(::Loot* loot) {
  delete loot_;
  loot_ = loot;
  if (loot) {
    set_has_loot();
  } else {
    clear_has_loot();
  }
}

// optional .GenericSpawner genericSpawner = 20;
inline bool Entity::has_genericspawner() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Entity::set_has_genericspawner() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Entity::clear_has_genericspawner() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Entity::clear_genericspawner() {
  if (genericspawner_ != NULL) genericspawner_->::GenericSpawner::Clear();
  clear_has_genericspawner();
}
inline const ::GenericSpawner& Entity::genericspawner() const {
  return genericspawner_ != NULL ? *genericspawner_ : *default_instance_->genericspawner_;
}
inline ::GenericSpawner* Entity::mutable_genericspawner() {
  set_has_genericspawner();
  if (genericspawner_ == NULL) genericspawner_ = new ::GenericSpawner;
  return genericspawner_;
}
inline ::GenericSpawner* Entity::release_genericspawner() {
  clear_has_genericspawner();
  ::GenericSpawner* temp = genericspawner_;
  genericspawner_ = NULL;
  return temp;
}
inline void Entity::set_allocated_genericspawner(::GenericSpawner* genericspawner) {
  delete genericspawner_;
  genericspawner_ = genericspawner;
  if (genericspawner) {
    set_has_genericspawner();
  } else {
    clear_has_genericspawner();
  }
}

// optional .SleepingBag sleepingBag = 21;
inline bool Entity::has_sleepingbag() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Entity::set_has_sleepingbag() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Entity::clear_has_sleepingbag() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Entity::clear_sleepingbag() {
  if (sleepingbag_ != NULL) sleepingbag_->::SleepingBag::Clear();
  clear_has_sleepingbag();
}
inline const ::SleepingBag& Entity::sleepingbag() const {
  return sleepingbag_ != NULL ? *sleepingbag_ : *default_instance_->sleepingbag_;
}
inline ::SleepingBag* Entity::mutable_sleepingbag() {
  set_has_sleepingbag();
  if (sleepingbag_ == NULL) sleepingbag_ = new ::SleepingBag;
  return sleepingbag_;
}
inline ::SleepingBag* Entity::release_sleepingbag() {
  clear_has_sleepingbag();
  ::SleepingBag* temp = sleepingbag_;
  sleepingbag_ = NULL;
  return temp;
}
inline void Entity::set_allocated_sleepingbag(::SleepingBag* sleepingbag) {
  delete sleepingbag_;
  sleepingbag_ = sleepingbag;
  if (sleepingbag) {
    set_has_sleepingbag();
  } else {
    clear_has_sleepingbag();
  }
}

// optional .LootableCorpse lootableCorpse = 22;
inline bool Entity::has_lootablecorpse() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Entity::set_has_lootablecorpse() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Entity::clear_has_lootablecorpse() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Entity::clear_lootablecorpse() {
  if (lootablecorpse_ != NULL) lootablecorpse_->::LootableCorpse::Clear();
  clear_has_lootablecorpse();
}
inline const ::LootableCorpse& Entity::lootablecorpse() const {
  return lootablecorpse_ != NULL ? *lootablecorpse_ : *default_instance_->lootablecorpse_;
}
inline ::LootableCorpse* Entity::mutable_lootablecorpse() {
  set_has_lootablecorpse();
  if (lootablecorpse_ == NULL) lootablecorpse_ = new ::LootableCorpse;
  return lootablecorpse_;
}
inline ::LootableCorpse* Entity::release_lootablecorpse() {
  clear_has_lootablecorpse();
  ::LootableCorpse* temp = lootablecorpse_;
  lootablecorpse_ = NULL;
  return temp;
}
inline void Entity::set_allocated_lootablecorpse(::LootableCorpse* lootablecorpse) {
  delete lootablecorpse_;
  lootablecorpse_ = lootablecorpse;
  if (lootablecorpse) {
    set_has_lootablecorpse();
  } else {
    clear_has_lootablecorpse();
  }
}

// optional .Sign sign = 23;
inline bool Entity::has_sign() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Entity::set_has_sign() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Entity::clear_has_sign() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Entity::clear_sign() {
  if (sign_ != NULL) sign_->::Sign::Clear();
  clear_has_sign();
}
inline const ::Sign& Entity::sign() const {
  return sign_ != NULL ? *sign_ : *default_instance_->sign_;
}
inline ::Sign* Entity::mutable_sign() {
  set_has_sign();
  if (sign_ == NULL) sign_ = new ::Sign;
  return sign_;
}
inline ::Sign* Entity::release_sign() {
  clear_has_sign();
  ::Sign* temp = sign_;
  sign_ = NULL;
  return temp;
}
inline void Entity::set_allocated_sign(::Sign* sign) {
  delete sign_;
  sign_ = sign;
  if (sign) {
    set_has_sign();
  } else {
    clear_has_sign();
  }
}

// optional .BaseCombat baseCombat = 24;
inline bool Entity::has_basecombat() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Entity::set_has_basecombat() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Entity::clear_has_basecombat() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Entity::clear_basecombat() {
  if (basecombat_ != NULL) basecombat_->::BaseCombat::Clear();
  clear_has_basecombat();
}
inline const ::BaseCombat& Entity::basecombat() const {
  return basecombat_ != NULL ? *basecombat_ : *default_instance_->basecombat_;
}
inline ::BaseCombat* Entity::mutable_basecombat() {
  set_has_basecombat();
  if (basecombat_ == NULL) basecombat_ = new ::BaseCombat;
  return basecombat_;
}
inline ::BaseCombat* Entity::release_basecombat() {
  clear_has_basecombat();
  ::BaseCombat* temp = basecombat_;
  basecombat_ = NULL;
  return temp;
}
inline void Entity::set_allocated_basecombat(::BaseCombat* basecombat) {
  delete basecombat_;
  basecombat_ = basecombat;
  if (basecombat) {
    set_has_basecombat();
  } else {
    clear_has_basecombat();
  }
}

// optional .MapEntity mapEntity = 25;
inline bool Entity::has_mapentity() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Entity::set_has_mapentity() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Entity::clear_has_mapentity() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Entity::clear_mapentity() {
  if (mapentity_ != NULL) mapentity_->::MapEntity::Clear();
  clear_has_mapentity();
}
inline const ::MapEntity& Entity::mapentity() const {
  return mapentity_ != NULL ? *mapentity_ : *default_instance_->mapentity_;
}
inline ::MapEntity* Entity::mutable_mapentity() {
  set_has_mapentity();
  if (mapentity_ == NULL) mapentity_ = new ::MapEntity;
  return mapentity_;
}
inline ::MapEntity* Entity::release_mapentity() {
  clear_has_mapentity();
  ::MapEntity* temp = mapentity_;
  mapentity_ = NULL;
  return temp;
}
inline void Entity::set_allocated_mapentity(::MapEntity* mapentity) {
  delete mapentity_;
  mapentity_ = mapentity;
  if (mapentity) {
    set_has_mapentity();
  } else {
    clear_has_mapentity();
  }
}

// optional .ResearchTable researchTable = 26;
inline bool Entity::has_researchtable() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Entity::set_has_researchtable() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Entity::clear_has_researchtable() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Entity::clear_researchtable() {
  if (researchtable_ != NULL) researchtable_->::ResearchTable::Clear();
  clear_has_researchtable();
}
inline const ::ResearchTable& Entity::researchtable() const {
  return researchtable_ != NULL ? *researchtable_ : *default_instance_->researchtable_;
}
inline ::ResearchTable* Entity::mutable_researchtable() {
  set_has_researchtable();
  if (researchtable_ == NULL) researchtable_ = new ::ResearchTable;
  return researchtable_;
}
inline ::ResearchTable* Entity::release_researchtable() {
  clear_has_researchtable();
  ::ResearchTable* temp = researchtable_;
  researchtable_ = NULL;
  return temp;
}
inline void Entity::set_allocated_researchtable(::ResearchTable* researchtable) {
  delete researchtable_;
  researchtable_ = researchtable;
  if (researchtable) {
    set_has_researchtable();
  } else {
    clear_has_researchtable();
  }
}

// optional .DudExplosive dudExplosive = 27;
inline bool Entity::has_dudexplosive() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Entity::set_has_dudexplosive() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Entity::clear_has_dudexplosive() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Entity::clear_dudexplosive() {
  if (dudexplosive_ != NULL) dudexplosive_->::DudExplosive::Clear();
  clear_has_dudexplosive();
}
inline const ::DudExplosive& Entity::dudexplosive() const {
  return dudexplosive_ != NULL ? *dudexplosive_ : *default_instance_->dudexplosive_;
}
inline ::DudExplosive* Entity::mutable_dudexplosive() {
  set_has_dudexplosive();
  if (dudexplosive_ == NULL) dudexplosive_ = new ::DudExplosive;
  return dudexplosive_;
}
inline ::DudExplosive* Entity::release_dudexplosive() {
  clear_has_dudexplosive();
  ::DudExplosive* temp = dudexplosive_;
  dudexplosive_ = NULL;
  return temp;
}
inline void Entity::set_allocated_dudexplosive(::DudExplosive* dudexplosive) {
  delete dudexplosive_;
  dudexplosive_ = dudexplosive;
  if (dudexplosive) {
    set_has_dudexplosive();
  } else {
    clear_has_dudexplosive();
  }
}

// optional .MiningQuarry miningQuarry = 28;
inline bool Entity::has_miningquarry() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Entity::set_has_miningquarry() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Entity::clear_has_miningquarry() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Entity::clear_miningquarry() {
  if (miningquarry_ != NULL) miningquarry_->::MiningQuarry::Clear();
  clear_has_miningquarry();
}
inline const ::MiningQuarry& Entity::miningquarry() const {
  return miningquarry_ != NULL ? *miningquarry_ : *default_instance_->miningquarry_;
}
inline ::MiningQuarry* Entity::mutable_miningquarry() {
  set_has_miningquarry();
  if (miningquarry_ == NULL) miningquarry_ = new ::MiningQuarry;
  return miningquarry_;
}
inline ::MiningQuarry* Entity::release_miningquarry() {
  clear_has_miningquarry();
  ::MiningQuarry* temp = miningquarry_;
  miningquarry_ = NULL;
  return temp;
}
inline void Entity::set_allocated_miningquarry(::MiningQuarry* miningquarry) {
  delete miningquarry_;
  miningquarry_ = miningquarry;
  if (miningquarry) {
    set_has_miningquarry();
  } else {
    clear_has_miningquarry();
  }
}

// optional .PlantEntity plantEntity = 29;
inline bool Entity::has_plantentity() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Entity::set_has_plantentity() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Entity::clear_has_plantentity() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Entity::clear_plantentity() {
  if (plantentity_ != NULL) plantentity_->::PlantEntity::Clear();
  clear_has_plantentity();
}
inline const ::PlantEntity& Entity::plantentity() const {
  return plantentity_ != NULL ? *plantentity_ : *default_instance_->plantentity_;
}
inline ::PlantEntity* Entity::mutable_plantentity() {
  set_has_plantentity();
  if (plantentity_ == NULL) plantentity_ = new ::PlantEntity;
  return plantentity_;
}
inline ::PlantEntity* Entity::release_plantentity() {
  clear_has_plantentity();
  ::PlantEntity* temp = plantentity_;
  plantentity_ = NULL;
  return temp;
}
inline void Entity::set_allocated_plantentity(::PlantEntity* plantentity) {
  delete plantentity_;
  plantentity_ = plantentity;
  if (plantentity) {
    set_has_plantentity();
  } else {
    clear_has_plantentity();
  }
}

// optional .Helicopter helicopter = 30;
inline bool Entity::has_helicopter() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Entity::set_has_helicopter() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Entity::clear_has_helicopter() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Entity::clear_helicopter() {
  if (helicopter_ != NULL) helicopter_->::Helicopter::Clear();
  clear_has_helicopter();
}
inline const ::Helicopter& Entity::helicopter() const {
  return helicopter_ != NULL ? *helicopter_ : *default_instance_->helicopter_;
}
inline ::Helicopter* Entity::mutable_helicopter() {
  set_has_helicopter();
  if (helicopter_ == NULL) helicopter_ = new ::Helicopter;
  return helicopter_;
}
inline ::Helicopter* Entity::release_helicopter() {
  clear_has_helicopter();
  ::Helicopter* temp = helicopter_;
  helicopter_ = NULL;
  return temp;
}
inline void Entity::set_allocated_helicopter(::Helicopter* helicopter) {
  delete helicopter_;
  helicopter_ = helicopter;
  if (helicopter) {
    set_has_helicopter();
  } else {
    clear_has_helicopter();
  }
}

// optional .Landmine landmine = 31;
inline bool Entity::has_landmine() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Entity::set_has_landmine() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Entity::clear_has_landmine() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Entity::clear_landmine() {
  if (landmine_ != NULL) landmine_->::Landmine::Clear();
  clear_has_landmine();
}
inline const ::Landmine& Entity::landmine() const {
  return landmine_ != NULL ? *landmine_ : *default_instance_->landmine_;
}
inline ::Landmine* Entity::mutable_landmine() {
  set_has_landmine();
  if (landmine_ == NULL) landmine_ = new ::Landmine;
  return landmine_;
}
inline ::Landmine* Entity::release_landmine() {
  clear_has_landmine();
  ::Landmine* temp = landmine_;
  landmine_ = NULL;
  return temp;
}
inline void Entity::set_allocated_landmine(::Landmine* landmine) {
  delete landmine_;
  landmine_ = landmine;
  if (landmine) {
    set_has_landmine();
  } else {
    clear_has_landmine();
  }
}

// optional .AutoTurret autoturret = 32;
inline bool Entity::has_autoturret() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void Entity::set_has_autoturret() {
  _has_bits_[0] |= 0x40000000u;
}
inline void Entity::clear_has_autoturret() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void Entity::clear_autoturret() {
  if (autoturret_ != NULL) autoturret_->::AutoTurret::Clear();
  clear_has_autoturret();
}
inline const ::AutoTurret& Entity::autoturret() const {
  return autoturret_ != NULL ? *autoturret_ : *default_instance_->autoturret_;
}
inline ::AutoTurret* Entity::mutable_autoturret() {
  set_has_autoturret();
  if (autoturret_ == NULL) autoturret_ = new ::AutoTurret;
  return autoturret_;
}
inline ::AutoTurret* Entity::release_autoturret() {
  clear_has_autoturret();
  ::AutoTurret* temp = autoturret_;
  autoturret_ = NULL;
  return temp;
}
inline void Entity::set_allocated_autoturret(::AutoTurret* autoturret) {
  delete autoturret_;
  autoturret_ = autoturret;
  if (autoturret) {
    set_has_autoturret();
  } else {
    clear_has_autoturret();
  }
}

// optional .SphereEntity sphereEntity = 33;
inline bool Entity::has_sphereentity() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void Entity::set_has_sphereentity() {
  _has_bits_[0] |= 0x80000000u;
}
inline void Entity::clear_has_sphereentity() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void Entity::clear_sphereentity() {
  if (sphereentity_ != NULL) sphereentity_->::SphereEntity::Clear();
  clear_has_sphereentity();
}
inline const ::SphereEntity& Entity::sphereentity() const {
  return sphereentity_ != NULL ? *sphereentity_ : *default_instance_->sphereentity_;
}
inline ::SphereEntity* Entity::mutable_sphereentity() {
  set_has_sphereentity();
  if (sphereentity_ == NULL) sphereentity_ = new ::SphereEntity;
  return sphereentity_;
}
inline ::SphereEntity* Entity::release_sphereentity() {
  clear_has_sphereentity();
  ::SphereEntity* temp = sphereentity_;
  sphereentity_ = NULL;
  return temp;
}
inline void Entity::set_allocated_sphereentity(::SphereEntity* sphereentity) {
  delete sphereentity_;
  sphereentity_ = sphereentity;
  if (sphereentity) {
    set_has_sphereentity();
  } else {
    clear_has_sphereentity();
  }
}

// optional .StabilityEntity stabilityEntity = 34;
inline bool Entity::has_stabilityentity() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void Entity::set_has_stabilityentity() {
  _has_bits_[1] |= 0x00000001u;
}
inline void Entity::clear_has_stabilityentity() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void Entity::clear_stabilityentity() {
  if (stabilityentity_ != NULL) stabilityentity_->::StabilityEntity::Clear();
  clear_has_stabilityentity();
}
inline const ::StabilityEntity& Entity::stabilityentity() const {
  return stabilityentity_ != NULL ? *stabilityentity_ : *default_instance_->stabilityentity_;
}
inline ::StabilityEntity* Entity::mutable_stabilityentity() {
  set_has_stabilityentity();
  if (stabilityentity_ == NULL) stabilityentity_ = new ::StabilityEntity;
  return stabilityentity_;
}
inline ::StabilityEntity* Entity::release_stabilityentity() {
  clear_has_stabilityentity();
  ::StabilityEntity* temp = stabilityentity_;
  stabilityentity_ = NULL;
  return temp;
}
inline void Entity::set_allocated_stabilityentity(::StabilityEntity* stabilityentity) {
  delete stabilityentity_;
  stabilityentity_ = stabilityentity;
  if (stabilityentity) {
    set_has_stabilityentity();
  } else {
    clear_has_stabilityentity();
  }
}

// optional .OwnerInfo ownerInfo = 35;
inline bool Entity::has_ownerinfo() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void Entity::set_has_ownerinfo() {
  _has_bits_[1] |= 0x00000002u;
}
inline void Entity::clear_has_ownerinfo() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void Entity::clear_ownerinfo() {
  if (ownerinfo_ != NULL) ownerinfo_->::OwnerInfo::Clear();
  clear_has_ownerinfo();
}
inline const ::OwnerInfo& Entity::ownerinfo() const {
  return ownerinfo_ != NULL ? *ownerinfo_ : *default_instance_->ownerinfo_;
}
inline ::OwnerInfo* Entity::mutable_ownerinfo() {
  set_has_ownerinfo();
  if (ownerinfo_ == NULL) ownerinfo_ = new ::OwnerInfo;
  return ownerinfo_;
}
inline ::OwnerInfo* Entity::release_ownerinfo() {
  clear_has_ownerinfo();
  ::OwnerInfo* temp = ownerinfo_;
  ownerinfo_ = NULL;
  return temp;
}
inline void Entity::set_allocated_ownerinfo(::OwnerInfo* ownerinfo) {
  delete ownerinfo_;
  ownerinfo_ = ownerinfo;
  if (ownerinfo) {
    set_has_ownerinfo();
  } else {
    clear_has_ownerinfo();
  }
}

// optional .DecayEntity decayEntity = 36;
inline bool Entity::has_decayentity() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void Entity::set_has_decayentity() {
  _has_bits_[1] |= 0x00000004u;
}
inline void Entity::clear_has_decayentity() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void Entity::clear_decayentity() {
  if (decayentity_ != NULL) decayentity_->::DecayEntity::Clear();
  clear_has_decayentity();
}
inline const ::DecayEntity& Entity::decayentity() const {
  return decayentity_ != NULL ? *decayentity_ : *default_instance_->decayentity_;
}
inline ::DecayEntity* Entity::mutable_decayentity() {
  set_has_decayentity();
  if (decayentity_ == NULL) decayentity_ = new ::DecayEntity;
  return decayentity_;
}
inline ::DecayEntity* Entity::release_decayentity() {
  clear_has_decayentity();
  ::DecayEntity* temp = decayentity_;
  decayentity_ = NULL;
  return temp;
}
inline void Entity::set_allocated_decayentity(::DecayEntity* decayentity) {
  delete decayentity_;
  decayentity_ = decayentity;
  if (decayentity) {
    set_has_decayentity();
  } else {
    clear_has_decayentity();
  }
}

// optional .Spawnable spawnable = 37;
inline bool Entity::has_spawnable() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void Entity::set_has_spawnable() {
  _has_bits_[1] |= 0x00000008u;
}
inline void Entity::clear_has_spawnable() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void Entity::clear_spawnable() {
  if (spawnable_ != NULL) spawnable_->::Spawnable::Clear();
  clear_has_spawnable();
}
inline const ::Spawnable& Entity::spawnable() const {
  return spawnable_ != NULL ? *spawnable_ : *default_instance_->spawnable_;
}
inline ::Spawnable* Entity::mutable_spawnable() {
  set_has_spawnable();
  if (spawnable_ == NULL) spawnable_ = new ::Spawnable;
  return spawnable_;
}
inline ::Spawnable* Entity::release_spawnable() {
  clear_has_spawnable();
  ::Spawnable* temp = spawnable_;
  spawnable_ = NULL;
  return temp;
}
inline void Entity::set_allocated_spawnable(::Spawnable* spawnable) {
  delete spawnable_;
  spawnable_ = spawnable;
  if (spawnable) {
    set_has_spawnable();
  } else {
    clear_has_spawnable();
  }
}

// optional .ServerGib servergib = 38;
inline bool Entity::has_servergib() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void Entity::set_has_servergib() {
  _has_bits_[1] |= 0x00000010u;
}
inline void Entity::clear_has_servergib() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void Entity::clear_servergib() {
  if (servergib_ != NULL) servergib_->::ServerGib::Clear();
  clear_has_servergib();
}
inline const ::ServerGib& Entity::servergib() const {
  return servergib_ != NULL ? *servergib_ : *default_instance_->servergib_;
}
inline ::ServerGib* Entity::mutable_servergib() {
  set_has_servergib();
  if (servergib_ == NULL) servergib_ = new ::ServerGib;
  return servergib_;
}
inline ::ServerGib* Entity::release_servergib() {
  clear_has_servergib();
  ::ServerGib* temp = servergib_;
  servergib_ = NULL;
  return temp;
}
inline void Entity::set_allocated_servergib(::ServerGib* servergib) {
  delete servergib_;
  servergib_ = servergib;
  if (servergib) {
    set_has_servergib();
  } else {
    clear_has_servergib();
  }
}

// optional .VendingMachine vendingMachine = 39;
inline bool Entity::has_vendingmachine() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void Entity::set_has_vendingmachine() {
  _has_bits_[1] |= 0x00000020u;
}
inline void Entity::clear_has_vendingmachine() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void Entity::clear_vendingmachine() {
  if (vendingmachine_ != NULL) vendingmachine_->::VendingMachine::Clear();
  clear_has_vendingmachine();
}
inline const ::VendingMachine& Entity::vendingmachine() const {
  return vendingmachine_ != NULL ? *vendingmachine_ : *default_instance_->vendingmachine_;
}
inline ::VendingMachine* Entity::mutable_vendingmachine() {
  set_has_vendingmachine();
  if (vendingmachine_ == NULL) vendingmachine_ = new ::VendingMachine;
  return vendingmachine_;
}
inline ::VendingMachine* Entity::release_vendingmachine() {
  clear_has_vendingmachine();
  ::VendingMachine* temp = vendingmachine_;
  vendingmachine_ = NULL;
  return temp;
}
inline void Entity::set_allocated_vendingmachine(::VendingMachine* vendingmachine) {
  delete vendingmachine_;
  vendingmachine_ = vendingmachine;
  if (vendingmachine) {
    set_has_vendingmachine();
  } else {
    clear_has_vendingmachine();
  }
}

// optional .SpinnerWheel spinnerWheel = 40;
inline bool Entity::has_spinnerwheel() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void Entity::set_has_spinnerwheel() {
  _has_bits_[1] |= 0x00000040u;
}
inline void Entity::clear_has_spinnerwheel() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void Entity::clear_spinnerwheel() {
  if (spinnerwheel_ != NULL) spinnerwheel_->::SpinnerWheel::Clear();
  clear_has_spinnerwheel();
}
inline const ::SpinnerWheel& Entity::spinnerwheel() const {
  return spinnerwheel_ != NULL ? *spinnerwheel_ : *default_instance_->spinnerwheel_;
}
inline ::SpinnerWheel* Entity::mutable_spinnerwheel() {
  set_has_spinnerwheel();
  if (spinnerwheel_ == NULL) spinnerwheel_ = new ::SpinnerWheel;
  return spinnerwheel_;
}
inline ::SpinnerWheel* Entity::release_spinnerwheel() {
  clear_has_spinnerwheel();
  ::SpinnerWheel* temp = spinnerwheel_;
  spinnerwheel_ = NULL;
  return temp;
}
inline void Entity::set_allocated_spinnerwheel(::SpinnerWheel* spinnerwheel) {
  delete spinnerwheel_;
  spinnerwheel_ = spinnerwheel;
  if (spinnerwheel) {
    set_has_spinnerwheel();
  } else {
    clear_has_spinnerwheel();
  }
}

// required bool createdThisFrame = 100;
inline bool Entity::has_createdthisframe() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void Entity::set_has_createdthisframe() {
  _has_bits_[1] |= 0x00000080u;
}
inline void Entity::clear_has_createdthisframe() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void Entity::clear_createdthisframe() {
  createdthisframe_ = false;
  clear_has_createdthisframe();
}
inline bool Entity::createdthisframe() const {
  return createdthisframe_;
}
inline void Entity::set_createdthisframe(bool value) {
  set_has_createdthisframe();
  createdthisframe_ = value;
}

// -------------------------------------------------------------------

// Approval

// required string level = 2;
inline bool Approval::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Approval::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Approval::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Approval::clear_level() {
  if (level_ != &::google::protobuf::internal::kEmptyString) {
    level_->clear();
  }
  clear_has_level();
}
inline const ::std::string& Approval::level() const {
  return *level_;
}
inline void Approval::set_level(const ::std::string& value) {
  set_has_level();
  if (level_ == &::google::protobuf::internal::kEmptyString) {
    level_ = new ::std::string;
  }
  level_->assign(value);
}
inline void Approval::set_level(const char* value) {
  set_has_level();
  if (level_ == &::google::protobuf::internal::kEmptyString) {
    level_ = new ::std::string;
  }
  level_->assign(value);
}
inline void Approval::set_level(const char* value, size_t size) {
  set_has_level();
  if (level_ == &::google::protobuf::internal::kEmptyString) {
    level_ = new ::std::string;
  }
  level_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Approval::mutable_level() {
  set_has_level();
  if (level_ == &::google::protobuf::internal::kEmptyString) {
    level_ = new ::std::string;
  }
  return level_;
}
inline ::std::string* Approval::release_level() {
  clear_has_level();
  if (level_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = level_;
    level_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Approval::set_allocated_level(::std::string* level) {
  if (level_ != &::google::protobuf::internal::kEmptyString) {
    delete level_;
  }
  if (level) {
    set_has_level();
    level_ = level;
  } else {
    clear_has_level();
    level_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string hostname = 3;
inline bool Approval::has_hostname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Approval::set_has_hostname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Approval::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Approval::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& Approval::hostname() const {
  return *hostname_;
}
inline void Approval::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void Approval::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void Approval::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Approval::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* Approval::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Approval::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bool modded = 4;
inline bool Approval::has_modded() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Approval::set_has_modded() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Approval::clear_has_modded() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Approval::clear_modded() {
  modded_ = false;
  clear_has_modded();
}
inline bool Approval::modded() const {
  return modded_;
}
inline void Approval::set_modded(bool value) {
  set_has_modded();
  modded_ = value;
}

// required bool official = 5;
inline bool Approval::has_official() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Approval::set_has_official() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Approval::clear_has_official() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Approval::clear_official() {
  official_ = false;
  clear_has_official();
}
inline bool Approval::official() const {
  return official_;
}
inline void Approval::set_official(bool value) {
  set_has_official();
  official_ = value;
}

// required uint64 steamid = 6;
inline bool Approval::has_steamid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Approval::set_has_steamid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Approval::clear_has_steamid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Approval::clear_steamid() {
  steamid_ = GOOGLE_ULONGLONG(0);
  clear_has_steamid();
}
inline ::google::protobuf::uint64 Approval::steamid() const {
  return steamid_;
}
inline void Approval::set_steamid(::google::protobuf::uint64 value) {
  set_has_steamid();
  steamid_ = value;
}

// required uint32 ipaddress = 7;
inline bool Approval::has_ipaddress() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Approval::set_has_ipaddress() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Approval::clear_has_ipaddress() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Approval::clear_ipaddress() {
  ipaddress_ = 0u;
  clear_has_ipaddress();
}
inline ::google::protobuf::uint32 Approval::ipaddress() const {
  return ipaddress_;
}
inline void Approval::set_ipaddress(::google::protobuf::uint32 value) {
  set_has_ipaddress();
  ipaddress_ = value;
}

// required uint64 port = 8;
inline bool Approval::has_port() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Approval::set_has_port() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Approval::clear_has_port() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Approval::clear_port() {
  port_ = GOOGLE_ULONGLONG(0);
  clear_has_port();
}
inline ::google::protobuf::uint64 Approval::port() const {
  return port_;
}
inline void Approval::set_port(::google::protobuf::uint64 value) {
  set_has_port();
  port_ = value;
}

// required uint32 levelSeed = 9;
inline bool Approval::has_levelseed() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Approval::set_has_levelseed() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Approval::clear_has_levelseed() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Approval::clear_levelseed() {
  levelseed_ = 0u;
  clear_has_levelseed();
}
inline ::google::protobuf::uint32 Approval::levelseed() const {
  return levelseed_;
}
inline void Approval::set_levelseed(::google::protobuf::uint32 value) {
  set_has_levelseed();
  levelseed_ = value;
}

// required uint32 levelSize = 10;
inline bool Approval::has_levelsize() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Approval::set_has_levelsize() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Approval::clear_has_levelsize() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Approval::clear_levelsize() {
  levelsize_ = 0u;
  clear_has_levelsize();
}
inline ::google::protobuf::uint32 Approval::levelsize() const {
  return levelsize_;
}
inline void Approval::set_levelsize(::google::protobuf::uint32 value) {
  set_has_levelsize();
  levelsize_ = value;
}

// optional string checksum = 11;
inline bool Approval::has_checksum() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Approval::set_has_checksum() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Approval::clear_has_checksum() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Approval::clear_checksum() {
  if (checksum_ != &::google::protobuf::internal::kEmptyString) {
    checksum_->clear();
  }
  clear_has_checksum();
}
inline const ::std::string& Approval::checksum() const {
  return *checksum_;
}
inline void Approval::set_checksum(const ::std::string& value) {
  set_has_checksum();
  if (checksum_ == &::google::protobuf::internal::kEmptyString) {
    checksum_ = new ::std::string;
  }
  checksum_->assign(value);
}
inline void Approval::set_checksum(const char* value) {
  set_has_checksum();
  if (checksum_ == &::google::protobuf::internal::kEmptyString) {
    checksum_ = new ::std::string;
  }
  checksum_->assign(value);
}
inline void Approval::set_checksum(const char* value, size_t size) {
  set_has_checksum();
  if (checksum_ == &::google::protobuf::internal::kEmptyString) {
    checksum_ = new ::std::string;
  }
  checksum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Approval::mutable_checksum() {
  set_has_checksum();
  if (checksum_ == &::google::protobuf::internal::kEmptyString) {
    checksum_ = new ::std::string;
  }
  return checksum_;
}
inline ::std::string* Approval::release_checksum() {
  clear_has_checksum();
  if (checksum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = checksum_;
    checksum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Approval::set_allocated_checksum(::std::string* checksum) {
  if (checksum_ != &::google::protobuf::internal::kEmptyString) {
    delete checksum_;
  }
  if (checksum) {
    set_has_checksum();
    checksum_ = checksum;
  } else {
    clear_has_checksum();
    checksum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Attack

// required .Vector3Serialized pointStart = 1;
inline bool Attack::has_pointstart() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Attack::set_has_pointstart() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Attack::clear_has_pointstart() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Attack::clear_pointstart() {
  if (pointstart_ != NULL) pointstart_->::Vector3Serialized::Clear();
  clear_has_pointstart();
}
inline const ::Vector3Serialized& Attack::pointstart() const {
  return pointstart_ != NULL ? *pointstart_ : *default_instance_->pointstart_;
}
inline ::Vector3Serialized* Attack::mutable_pointstart() {
  set_has_pointstart();
  if (pointstart_ == NULL) pointstart_ = new ::Vector3Serialized;
  return pointstart_;
}
inline ::Vector3Serialized* Attack::release_pointstart() {
  clear_has_pointstart();
  ::Vector3Serialized* temp = pointstart_;
  pointstart_ = NULL;
  return temp;
}
inline void Attack::set_allocated_pointstart(::Vector3Serialized* pointstart) {
  delete pointstart_;
  pointstart_ = pointstart;
  if (pointstart) {
    set_has_pointstart();
  } else {
    clear_has_pointstart();
  }
}

// required .Vector3Serialized pointEnd = 2;
inline bool Attack::has_pointend() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Attack::set_has_pointend() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Attack::clear_has_pointend() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Attack::clear_pointend() {
  if (pointend_ != NULL) pointend_->::Vector3Serialized::Clear();
  clear_has_pointend();
}
inline const ::Vector3Serialized& Attack::pointend() const {
  return pointend_ != NULL ? *pointend_ : *default_instance_->pointend_;
}
inline ::Vector3Serialized* Attack::mutable_pointend() {
  set_has_pointend();
  if (pointend_ == NULL) pointend_ = new ::Vector3Serialized;
  return pointend_;
}
inline ::Vector3Serialized* Attack::release_pointend() {
  clear_has_pointend();
  ::Vector3Serialized* temp = pointend_;
  pointend_ = NULL;
  return temp;
}
inline void Attack::set_allocated_pointend(::Vector3Serialized* pointend) {
  delete pointend_;
  pointend_ = pointend;
  if (pointend) {
    set_has_pointend();
  } else {
    clear_has_pointend();
  }
}

// required uint32 hitID = 3;
inline bool Attack::has_hitid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Attack::set_has_hitid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Attack::clear_has_hitid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Attack::clear_hitid() {
  hitid_ = 0u;
  clear_has_hitid();
}
inline ::google::protobuf::uint32 Attack::hitid() const {
  return hitid_;
}
inline void Attack::set_hitid(::google::protobuf::uint32 value) {
  set_has_hitid();
  hitid_ = value;
}

// required uint32 hitBone = 4;
inline bool Attack::has_hitbone() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Attack::set_has_hitbone() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Attack::clear_has_hitbone() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Attack::clear_hitbone() {
  hitbone_ = 0u;
  clear_has_hitbone();
}
inline ::google::protobuf::uint32 Attack::hitbone() const {
  return hitbone_;
}
inline void Attack::set_hitbone(::google::protobuf::uint32 value) {
  set_has_hitbone();
  hitbone_ = value;
}

// required .Vector3Serialized hitNormalLocal = 5;
inline bool Attack::has_hitnormallocal() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Attack::set_has_hitnormallocal() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Attack::clear_has_hitnormallocal() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Attack::clear_hitnormallocal() {
  if (hitnormallocal_ != NULL) hitnormallocal_->::Vector3Serialized::Clear();
  clear_has_hitnormallocal();
}
inline const ::Vector3Serialized& Attack::hitnormallocal() const {
  return hitnormallocal_ != NULL ? *hitnormallocal_ : *default_instance_->hitnormallocal_;
}
inline ::Vector3Serialized* Attack::mutable_hitnormallocal() {
  set_has_hitnormallocal();
  if (hitnormallocal_ == NULL) hitnormallocal_ = new ::Vector3Serialized;
  return hitnormallocal_;
}
inline ::Vector3Serialized* Attack::release_hitnormallocal() {
  clear_has_hitnormallocal();
  ::Vector3Serialized* temp = hitnormallocal_;
  hitnormallocal_ = NULL;
  return temp;
}
inline void Attack::set_allocated_hitnormallocal(::Vector3Serialized* hitnormallocal) {
  delete hitnormallocal_;
  hitnormallocal_ = hitnormallocal;
  if (hitnormallocal) {
    set_has_hitnormallocal();
  } else {
    clear_has_hitnormallocal();
  }
}

// required .Vector3Serialized hitPositionLocal = 6;
inline bool Attack::has_hitpositionlocal() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Attack::set_has_hitpositionlocal() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Attack::clear_has_hitpositionlocal() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Attack::clear_hitpositionlocal() {
  if (hitpositionlocal_ != NULL) hitpositionlocal_->::Vector3Serialized::Clear();
  clear_has_hitpositionlocal();
}
inline const ::Vector3Serialized& Attack::hitpositionlocal() const {
  return hitpositionlocal_ != NULL ? *hitpositionlocal_ : *default_instance_->hitpositionlocal_;
}
inline ::Vector3Serialized* Attack::mutable_hitpositionlocal() {
  set_has_hitpositionlocal();
  if (hitpositionlocal_ == NULL) hitpositionlocal_ = new ::Vector3Serialized;
  return hitpositionlocal_;
}
inline ::Vector3Serialized* Attack::release_hitpositionlocal() {
  clear_has_hitpositionlocal();
  ::Vector3Serialized* temp = hitpositionlocal_;
  hitpositionlocal_ = NULL;
  return temp;
}
inline void Attack::set_allocated_hitpositionlocal(::Vector3Serialized* hitpositionlocal) {
  delete hitpositionlocal_;
  hitpositionlocal_ = hitpositionlocal;
  if (hitpositionlocal) {
    set_has_hitpositionlocal();
  } else {
    clear_has_hitpositionlocal();
  }
}

// required .Vector3Serialized hitNormalWorld = 7;
inline bool Attack::has_hitnormalworld() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Attack::set_has_hitnormalworld() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Attack::clear_has_hitnormalworld() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Attack::clear_hitnormalworld() {
  if (hitnormalworld_ != NULL) hitnormalworld_->::Vector3Serialized::Clear();
  clear_has_hitnormalworld();
}
inline const ::Vector3Serialized& Attack::hitnormalworld() const {
  return hitnormalworld_ != NULL ? *hitnormalworld_ : *default_instance_->hitnormalworld_;
}
inline ::Vector3Serialized* Attack::mutable_hitnormalworld() {
  set_has_hitnormalworld();
  if (hitnormalworld_ == NULL) hitnormalworld_ = new ::Vector3Serialized;
  return hitnormalworld_;
}
inline ::Vector3Serialized* Attack::release_hitnormalworld() {
  clear_has_hitnormalworld();
  ::Vector3Serialized* temp = hitnormalworld_;
  hitnormalworld_ = NULL;
  return temp;
}
inline void Attack::set_allocated_hitnormalworld(::Vector3Serialized* hitnormalworld) {
  delete hitnormalworld_;
  hitnormalworld_ = hitnormalworld;
  if (hitnormalworld) {
    set_has_hitnormalworld();
  } else {
    clear_has_hitnormalworld();
  }
}

// required .Vector3Serialized hitPositionWorld = 8;
inline bool Attack::has_hitpositionworld() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Attack::set_has_hitpositionworld() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Attack::clear_has_hitpositionworld() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Attack::clear_hitpositionworld() {
  if (hitpositionworld_ != NULL) hitpositionworld_->::Vector3Serialized::Clear();
  clear_has_hitpositionworld();
}
inline const ::Vector3Serialized& Attack::hitpositionworld() const {
  return hitpositionworld_ != NULL ? *hitpositionworld_ : *default_instance_->hitpositionworld_;
}
inline ::Vector3Serialized* Attack::mutable_hitpositionworld() {
  set_has_hitpositionworld();
  if (hitpositionworld_ == NULL) hitpositionworld_ = new ::Vector3Serialized;
  return hitpositionworld_;
}
inline ::Vector3Serialized* Attack::release_hitpositionworld() {
  clear_has_hitpositionworld();
  ::Vector3Serialized* temp = hitpositionworld_;
  hitpositionworld_ = NULL;
  return temp;
}
inline void Attack::set_allocated_hitpositionworld(::Vector3Serialized* hitpositionworld) {
  delete hitpositionworld_;
  hitpositionworld_ = hitpositionworld;
  if (hitpositionworld) {
    set_has_hitpositionworld();
  } else {
    clear_has_hitpositionworld();
  }
}

// required uint32 hitPartID = 9;
inline bool Attack::has_hitpartid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Attack::set_has_hitpartid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Attack::clear_has_hitpartid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Attack::clear_hitpartid() {
  hitpartid_ = 0u;
  clear_has_hitpartid();
}
inline ::google::protobuf::uint32 Attack::hitpartid() const {
  return hitpartid_;
}
inline void Attack::set_hitpartid(::google::protobuf::uint32 value) {
  set_has_hitpartid();
  hitpartid_ = value;
}

// required uint32 hitMaterialID = 10;
inline bool Attack::has_hitmaterialid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Attack::set_has_hitmaterialid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Attack::clear_has_hitmaterialid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Attack::clear_hitmaterialid() {
  hitmaterialid_ = 0u;
  clear_has_hitmaterialid();
}
inline ::google::protobuf::uint32 Attack::hitmaterialid() const {
  return hitmaterialid_;
}
inline void Attack::set_hitmaterialid(::google::protobuf::uint32 value) {
  set_has_hitmaterialid();
  hitmaterialid_ = value;
}

// required uint32 hitItem = 11;
inline bool Attack::has_hititem() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Attack::set_has_hititem() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Attack::clear_has_hititem() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Attack::clear_hititem() {
  hititem_ = 0u;
  clear_has_hititem();
}
inline ::google::protobuf::uint32 Attack::hititem() const {
  return hititem_;
}
inline void Attack::set_hititem(::google::protobuf::uint32 value) {
  set_has_hititem();
  hititem_ = value;
}

// -------------------------------------------------------------------

// ClientReady_ClientInfo

// required string name = 1;
inline bool ClientReady_ClientInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientReady_ClientInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientReady_ClientInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientReady_ClientInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ClientReady_ClientInfo::name() const {
  return *name_;
}
inline void ClientReady_ClientInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClientReady_ClientInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClientReady_ClientInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientReady_ClientInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ClientReady_ClientInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientReady_ClientInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string value = 2;
inline bool ClientReady_ClientInfo::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientReady_ClientInfo::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientReady_ClientInfo::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientReady_ClientInfo::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& ClientReady_ClientInfo::value() const {
  return *value_;
}
inline void ClientReady_ClientInfo::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ClientReady_ClientInfo::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ClientReady_ClientInfo::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientReady_ClientInfo::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* ClientReady_ClientInfo::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientReady_ClientInfo::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClientReady

// repeated .ClientReady.ClientInfo clientInfo = 1;
inline int ClientReady::clientinfo_size() const {
  return clientinfo_.size();
}
inline void ClientReady::clear_clientinfo() {
  clientinfo_.Clear();
}
inline const ::ClientReady_ClientInfo& ClientReady::clientinfo(int index) const {
  return clientinfo_.Get(index);
}
inline ::ClientReady_ClientInfo* ClientReady::mutable_clientinfo(int index) {
  return clientinfo_.Mutable(index);
}
inline ::ClientReady_ClientInfo* ClientReady::add_clientinfo() {
  return clientinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ClientReady_ClientInfo >&
ClientReady::clientinfo() const {
  return clientinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::ClientReady_ClientInfo >*
ClientReady::mutable_clientinfo() {
  return &clientinfo_;
}

// -------------------------------------------------------------------

// CreateBuilding

// required uint32 entity = 1;
inline bool CreateBuilding::has_entity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateBuilding::set_has_entity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateBuilding::clear_has_entity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateBuilding::clear_entity() {
  entity_ = 0u;
  clear_has_entity();
}
inline ::google::protobuf::uint32 CreateBuilding::entity() const {
  return entity_;
}
inline void CreateBuilding::set_entity(::google::protobuf::uint32 value) {
  set_has_entity();
  entity_ = value;
}

// required uint32 socket = 2;
inline bool CreateBuilding::has_socket() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateBuilding::set_has_socket() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateBuilding::clear_has_socket() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateBuilding::clear_socket() {
  socket_ = 0u;
  clear_has_socket();
}
inline ::google::protobuf::uint32 CreateBuilding::socket() const {
  return socket_;
}
inline void CreateBuilding::set_socket(::google::protobuf::uint32 value) {
  set_has_socket();
  socket_ = value;
}

// required bool onterrain = 3;
inline bool CreateBuilding::has_onterrain() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateBuilding::set_has_onterrain() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateBuilding::clear_has_onterrain() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateBuilding::clear_onterrain() {
  onterrain_ = false;
  clear_has_onterrain();
}
inline bool CreateBuilding::onterrain() const {
  return onterrain_;
}
inline void CreateBuilding::set_onterrain(bool value) {
  set_has_onterrain();
  onterrain_ = value;
}

// required .Vector3Serialized position = 4;
inline bool CreateBuilding::has_position() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreateBuilding::set_has_position() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreateBuilding::clear_has_position() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreateBuilding::clear_position() {
  if (position_ != NULL) position_->::Vector3Serialized::Clear();
  clear_has_position();
}
inline const ::Vector3Serialized& CreateBuilding::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::Vector3Serialized* CreateBuilding::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::Vector3Serialized;
  return position_;
}
inline ::Vector3Serialized* CreateBuilding::release_position() {
  clear_has_position();
  ::Vector3Serialized* temp = position_;
  position_ = NULL;
  return temp;
}
inline void CreateBuilding::set_allocated_position(::Vector3Serialized* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
}

// required .Vector3Serialized normal = 5;
inline bool CreateBuilding::has_normal() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CreateBuilding::set_has_normal() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CreateBuilding::clear_has_normal() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CreateBuilding::clear_normal() {
  if (normal_ != NULL) normal_->::Vector3Serialized::Clear();
  clear_has_normal();
}
inline const ::Vector3Serialized& CreateBuilding::normal() const {
  return normal_ != NULL ? *normal_ : *default_instance_->normal_;
}
inline ::Vector3Serialized* CreateBuilding::mutable_normal() {
  set_has_normal();
  if (normal_ == NULL) normal_ = new ::Vector3Serialized;
  return normal_;
}
inline ::Vector3Serialized* CreateBuilding::release_normal() {
  clear_has_normal();
  ::Vector3Serialized* temp = normal_;
  normal_ = NULL;
  return temp;
}
inline void CreateBuilding::set_allocated_normal(::Vector3Serialized* normal) {
  delete normal_;
  normal_ = normal;
  if (normal) {
    set_has_normal();
  } else {
    clear_has_normal();
  }
}

// required .RaySerialized ray = 6;
inline bool CreateBuilding::has_ray() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CreateBuilding::set_has_ray() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CreateBuilding::clear_has_ray() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CreateBuilding::clear_ray() {
  if (ray_ != NULL) ray_->::RaySerialized::Clear();
  clear_has_ray();
}
inline const ::RaySerialized& CreateBuilding::ray() const {
  return ray_ != NULL ? *ray_ : *default_instance_->ray_;
}
inline ::RaySerialized* CreateBuilding::mutable_ray() {
  set_has_ray();
  if (ray_ == NULL) ray_ = new ::RaySerialized;
  return ray_;
}
inline ::RaySerialized* CreateBuilding::release_ray() {
  clear_has_ray();
  ::RaySerialized* temp = ray_;
  ray_ = NULL;
  return temp;
}
inline void CreateBuilding::set_allocated_ray(::RaySerialized* ray) {
  delete ray_;
  ray_ = ray;
  if (ray) {
    set_has_ray();
  } else {
    clear_has_ray();
  }
}

// required uint32 blockID = 7;
inline bool CreateBuilding::has_blockid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CreateBuilding::set_has_blockid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CreateBuilding::clear_has_blockid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CreateBuilding::clear_blockid() {
  blockid_ = 0u;
  clear_has_blockid();
}
inline ::google::protobuf::uint32 CreateBuilding::blockid() const {
  return blockid_;
}
inline void CreateBuilding::set_blockid(::google::protobuf::uint32 value) {
  set_has_blockid();
  blockid_ = value;
}

// required .Vector3Serialized rotation = 8;
inline bool CreateBuilding::has_rotation() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CreateBuilding::set_has_rotation() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CreateBuilding::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CreateBuilding::clear_rotation() {
  if (rotation_ != NULL) rotation_->::Vector3Serialized::Clear();
  clear_has_rotation();
}
inline const ::Vector3Serialized& CreateBuilding::rotation() const {
  return rotation_ != NULL ? *rotation_ : *default_instance_->rotation_;
}
inline ::Vector3Serialized* CreateBuilding::mutable_rotation() {
  set_has_rotation();
  if (rotation_ == NULL) rotation_ = new ::Vector3Serialized;
  return rotation_;
}
inline ::Vector3Serialized* CreateBuilding::release_rotation() {
  clear_has_rotation();
  ::Vector3Serialized* temp = rotation_;
  rotation_ = NULL;
  return temp;
}
inline void CreateBuilding::set_allocated_rotation(::Vector3Serialized* rotation) {
  delete rotation_;
  rotation_ = rotation;
  if (rotation) {
    set_has_rotation();
  } else {
    clear_has_rotation();
  }
}

// -------------------------------------------------------------------

// EntityList

// repeated .Entity entity = 1;
inline int EntityList::entity_size() const {
  return entity_.size();
}
inline void EntityList::clear_entity() {
  entity_.Clear();
}
inline const ::Entity& EntityList::entity(int index) const {
  return entity_.Get(index);
}
inline ::Entity* EntityList::mutable_entity(int index) {
  return entity_.Mutable(index);
}
inline ::Entity* EntityList::add_entity() {
  return entity_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Entity >&
EntityList::entity() const {
  return entity_;
}
inline ::google::protobuf::RepeatedPtrField< ::Entity >*
EntityList::mutable_entity() {
  return &entity_;
}

// -------------------------------------------------------------------

// ModuleMessage

// required uint32 itemid = 1;
inline bool ModuleMessage::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModuleMessage::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModuleMessage::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModuleMessage::clear_itemid() {
  itemid_ = 0u;
  clear_has_itemid();
}
inline ::google::protobuf::uint32 ModuleMessage::itemid() const {
  return itemid_;
}
inline void ModuleMessage::set_itemid(::google::protobuf::uint32 value) {
  set_has_itemid();
  itemid_ = value;
}

// required uint64 moduleid = 2;
inline bool ModuleMessage::has_moduleid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModuleMessage::set_has_moduleid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModuleMessage::clear_has_moduleid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModuleMessage::clear_moduleid() {
  moduleid_ = GOOGLE_ULONGLONG(0);
  clear_has_moduleid();
}
inline ::google::protobuf::uint64 ModuleMessage::moduleid() const {
  return moduleid_;
}
inline void ModuleMessage::set_moduleid(::google::protobuf::uint64 value) {
  set_has_moduleid();
  moduleid_ = value;
}

// required uint64 type = 3;
inline bool ModuleMessage::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModuleMessage::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModuleMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModuleMessage::clear_type() {
  type_ = GOOGLE_ULONGLONG(0);
  clear_has_type();
}
inline ::google::protobuf::uint64 ModuleMessage::type() const {
  return type_;
}
inline void ModuleMessage::set_type(::google::protobuf::uint64 value) {
  set_has_type();
  type_ = value;
}

// optional bytes data = 4;
inline bool ModuleMessage::has_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ModuleMessage::set_has_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ModuleMessage::clear_has_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ModuleMessage::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& ModuleMessage::data() const {
  return *data_;
}
inline void ModuleMessage::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ModuleMessage::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ModuleMessage::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModuleMessage::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* ModuleMessage::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ModuleMessage::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PlayerAttack

// required .Attack attack = 1;
inline bool PlayerAttack::has_attack() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerAttack::set_has_attack() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerAttack::clear_has_attack() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerAttack::clear_attack() {
  if (attack_ != NULL) attack_->::Attack::Clear();
  clear_has_attack();
}
inline const ::Attack& PlayerAttack::attack() const {
  return attack_ != NULL ? *attack_ : *default_instance_->attack_;
}
inline ::Attack* PlayerAttack::mutable_attack() {
  set_has_attack();
  if (attack_ == NULL) attack_ = new ::Attack;
  return attack_;
}
inline ::Attack* PlayerAttack::release_attack() {
  clear_has_attack();
  ::Attack* temp = attack_;
  attack_ = NULL;
  return temp;
}
inline void PlayerAttack::set_allocated_attack(::Attack* attack) {
  delete attack_;
  attack_ = attack;
  if (attack) {
    set_has_attack();
  } else {
    clear_has_attack();
  }
}

// required uint64 projectileID = 2;
inline bool PlayerAttack::has_projectileid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerAttack::set_has_projectileid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerAttack::clear_has_projectileid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerAttack::clear_projectileid() {
  projectileid_ = GOOGLE_ULONGLONG(0);
  clear_has_projectileid();
}
inline ::google::protobuf::uint64 PlayerAttack::projectileid() const {
  return projectileid_;
}
inline void PlayerAttack::set_projectileid(::google::protobuf::uint64 value) {
  set_has_projectileid();
  projectileid_ = value;
}

// -------------------------------------------------------------------

// PlayerProjectileAttack

// required .PlayerAttack playerAttack = 1;
inline bool PlayerProjectileAttack::has_playerattack() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerProjectileAttack::set_has_playerattack() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerProjectileAttack::clear_has_playerattack() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerProjectileAttack::clear_playerattack() {
  if (playerattack_ != NULL) playerattack_->::PlayerAttack::Clear();
  clear_has_playerattack();
}
inline const ::PlayerAttack& PlayerProjectileAttack::playerattack() const {
  return playerattack_ != NULL ? *playerattack_ : *default_instance_->playerattack_;
}
inline ::PlayerAttack* PlayerProjectileAttack::mutable_playerattack() {
  set_has_playerattack();
  if (playerattack_ == NULL) playerattack_ = new ::PlayerAttack;
  return playerattack_;
}
inline ::PlayerAttack* PlayerProjectileAttack::release_playerattack() {
  clear_has_playerattack();
  ::PlayerAttack* temp = playerattack_;
  playerattack_ = NULL;
  return temp;
}
inline void PlayerProjectileAttack::set_allocated_playerattack(::PlayerAttack* playerattack) {
  delete playerattack_;
  playerattack_ = playerattack;
  if (playerattack) {
    set_has_playerattack();
  } else {
    clear_has_playerattack();
  }
}

// required .Vector3Serialized hitVelocity = 2;
inline bool PlayerProjectileAttack::has_hitvelocity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerProjectileAttack::set_has_hitvelocity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerProjectileAttack::clear_has_hitvelocity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerProjectileAttack::clear_hitvelocity() {
  if (hitvelocity_ != NULL) hitvelocity_->::Vector3Serialized::Clear();
  clear_has_hitvelocity();
}
inline const ::Vector3Serialized& PlayerProjectileAttack::hitvelocity() const {
  return hitvelocity_ != NULL ? *hitvelocity_ : *default_instance_->hitvelocity_;
}
inline ::Vector3Serialized* PlayerProjectileAttack::mutable_hitvelocity() {
  set_has_hitvelocity();
  if (hitvelocity_ == NULL) hitvelocity_ = new ::Vector3Serialized;
  return hitvelocity_;
}
inline ::Vector3Serialized* PlayerProjectileAttack::release_hitvelocity() {
  clear_has_hitvelocity();
  ::Vector3Serialized* temp = hitvelocity_;
  hitvelocity_ = NULL;
  return temp;
}
inline void PlayerProjectileAttack::set_allocated_hitvelocity(::Vector3Serialized* hitvelocity) {
  delete hitvelocity_;
  hitvelocity_ = hitvelocity;
  if (hitvelocity) {
    set_has_hitvelocity();
  } else {
    clear_has_hitvelocity();
  }
}

// required float hitDistance = 3;
inline bool PlayerProjectileAttack::has_hitdistance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerProjectileAttack::set_has_hitdistance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerProjectileAttack::clear_has_hitdistance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerProjectileAttack::clear_hitdistance() {
  hitdistance_ = 0;
  clear_has_hitdistance();
}
inline float PlayerProjectileAttack::hitdistance() const {
  return hitdistance_;
}
inline void PlayerProjectileAttack::set_hitdistance(float value) {
  set_has_hitdistance();
  hitdistance_ = value;
}

// -------------------------------------------------------------------

// PlayerProjectileRicochet

// required uint64 projectileID = 1;
inline bool PlayerProjectileRicochet::has_projectileid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerProjectileRicochet::set_has_projectileid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerProjectileRicochet::clear_has_projectileid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerProjectileRicochet::clear_projectileid() {
  projectileid_ = GOOGLE_ULONGLONG(0);
  clear_has_projectileid();
}
inline ::google::protobuf::uint64 PlayerProjectileRicochet::projectileid() const {
  return projectileid_;
}
inline void PlayerProjectileRicochet::set_projectileid(::google::protobuf::uint64 value) {
  set_has_projectileid();
  projectileid_ = value;
}

// required .Vector3Serialized hitPosition = 2;
inline bool PlayerProjectileRicochet::has_hitposition() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerProjectileRicochet::set_has_hitposition() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerProjectileRicochet::clear_has_hitposition() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerProjectileRicochet::clear_hitposition() {
  if (hitposition_ != NULL) hitposition_->::Vector3Serialized::Clear();
  clear_has_hitposition();
}
inline const ::Vector3Serialized& PlayerProjectileRicochet::hitposition() const {
  return hitposition_ != NULL ? *hitposition_ : *default_instance_->hitposition_;
}
inline ::Vector3Serialized* PlayerProjectileRicochet::mutable_hitposition() {
  set_has_hitposition();
  if (hitposition_ == NULL) hitposition_ = new ::Vector3Serialized;
  return hitposition_;
}
inline ::Vector3Serialized* PlayerProjectileRicochet::release_hitposition() {
  clear_has_hitposition();
  ::Vector3Serialized* temp = hitposition_;
  hitposition_ = NULL;
  return temp;
}
inline void PlayerProjectileRicochet::set_allocated_hitposition(::Vector3Serialized* hitposition) {
  delete hitposition_;
  hitposition_ = hitposition;
  if (hitposition) {
    set_has_hitposition();
  } else {
    clear_has_hitposition();
  }
}

// required .Vector3Serialized inVelocity = 3;
inline bool PlayerProjectileRicochet::has_invelocity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerProjectileRicochet::set_has_invelocity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerProjectileRicochet::clear_has_invelocity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerProjectileRicochet::clear_invelocity() {
  if (invelocity_ != NULL) invelocity_->::Vector3Serialized::Clear();
  clear_has_invelocity();
}
inline const ::Vector3Serialized& PlayerProjectileRicochet::invelocity() const {
  return invelocity_ != NULL ? *invelocity_ : *default_instance_->invelocity_;
}
inline ::Vector3Serialized* PlayerProjectileRicochet::mutable_invelocity() {
  set_has_invelocity();
  if (invelocity_ == NULL) invelocity_ = new ::Vector3Serialized;
  return invelocity_;
}
inline ::Vector3Serialized* PlayerProjectileRicochet::release_invelocity() {
  clear_has_invelocity();
  ::Vector3Serialized* temp = invelocity_;
  invelocity_ = NULL;
  return temp;
}
inline void PlayerProjectileRicochet::set_allocated_invelocity(::Vector3Serialized* invelocity) {
  delete invelocity_;
  invelocity_ = invelocity;
  if (invelocity) {
    set_has_invelocity();
  } else {
    clear_has_invelocity();
  }
}

// required .Vector3Serialized outVelocity = 4;
inline bool PlayerProjectileRicochet::has_outvelocity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerProjectileRicochet::set_has_outvelocity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerProjectileRicochet::clear_has_outvelocity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerProjectileRicochet::clear_outvelocity() {
  if (outvelocity_ != NULL) outvelocity_->::Vector3Serialized::Clear();
  clear_has_outvelocity();
}
inline const ::Vector3Serialized& PlayerProjectileRicochet::outvelocity() const {
  return outvelocity_ != NULL ? *outvelocity_ : *default_instance_->outvelocity_;
}
inline ::Vector3Serialized* PlayerProjectileRicochet::mutable_outvelocity() {
  set_has_outvelocity();
  if (outvelocity_ == NULL) outvelocity_ = new ::Vector3Serialized;
  return outvelocity_;
}
inline ::Vector3Serialized* PlayerProjectileRicochet::release_outvelocity() {
  clear_has_outvelocity();
  ::Vector3Serialized* temp = outvelocity_;
  outvelocity_ = NULL;
  return temp;
}
inline void PlayerProjectileRicochet::set_allocated_outvelocity(::Vector3Serialized* outvelocity) {
  delete outvelocity_;
  outvelocity_ = outvelocity;
  if (outvelocity) {
    set_has_outvelocity();
  } else {
    clear_has_outvelocity();
  }
}

// -------------------------------------------------------------------

// PlayerProjectileUpdate

// required uint64 projectileID = 1;
inline bool PlayerProjectileUpdate::has_projectileid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerProjectileUpdate::set_has_projectileid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerProjectileUpdate::clear_has_projectileid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerProjectileUpdate::clear_projectileid() {
  projectileid_ = GOOGLE_ULONGLONG(0);
  clear_has_projectileid();
}
inline ::google::protobuf::uint64 PlayerProjectileUpdate::projectileid() const {
  return projectileid_;
}
inline void PlayerProjectileUpdate::set_projectileid(::google::protobuf::uint64 value) {
  set_has_projectileid();
  projectileid_ = value;
}

// required .Vector3Serialized curPosition = 2;
inline bool PlayerProjectileUpdate::has_curposition() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerProjectileUpdate::set_has_curposition() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerProjectileUpdate::clear_has_curposition() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerProjectileUpdate::clear_curposition() {
  if (curposition_ != NULL) curposition_->::Vector3Serialized::Clear();
  clear_has_curposition();
}
inline const ::Vector3Serialized& PlayerProjectileUpdate::curposition() const {
  return curposition_ != NULL ? *curposition_ : *default_instance_->curposition_;
}
inline ::Vector3Serialized* PlayerProjectileUpdate::mutable_curposition() {
  set_has_curposition();
  if (curposition_ == NULL) curposition_ = new ::Vector3Serialized;
  return curposition_;
}
inline ::Vector3Serialized* PlayerProjectileUpdate::release_curposition() {
  clear_has_curposition();
  ::Vector3Serialized* temp = curposition_;
  curposition_ = NULL;
  return temp;
}
inline void PlayerProjectileUpdate::set_allocated_curposition(::Vector3Serialized* curposition) {
  delete curposition_;
  curposition_ = curposition;
  if (curposition) {
    set_has_curposition();
  } else {
    clear_has_curposition();
  }
}

// -------------------------------------------------------------------

// PlayerUpdateLoot

// required uint32 itemID = 1;
inline bool PlayerUpdateLoot::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerUpdateLoot::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerUpdateLoot::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerUpdateLoot::clear_itemid() {
  itemid_ = 0u;
  clear_has_itemid();
}
inline ::google::protobuf::uint32 PlayerUpdateLoot::itemid() const {
  return itemid_;
}
inline void PlayerUpdateLoot::set_itemid(::google::protobuf::uint32 value) {
  set_has_itemid();
  itemid_ = value;
}

// required uint32 entityID = 2;
inline bool PlayerUpdateLoot::has_entityid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerUpdateLoot::set_has_entityid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerUpdateLoot::clear_has_entityid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerUpdateLoot::clear_entityid() {
  entityid_ = 0u;
  clear_has_entityid();
}
inline ::google::protobuf::uint32 PlayerUpdateLoot::entityid() const {
  return entityid_;
}
inline void PlayerUpdateLoot::set_entityid(::google::protobuf::uint32 value) {
  set_has_entityid();
  entityid_ = value;
}

// repeated .ItemContainer containers = 3;
inline int PlayerUpdateLoot::containers_size() const {
  return containers_.size();
}
inline void PlayerUpdateLoot::clear_containers() {
  containers_.Clear();
}
inline const ::ItemContainer& PlayerUpdateLoot::containers(int index) const {
  return containers_.Get(index);
}
inline ::ItemContainer* PlayerUpdateLoot::mutable_containers(int index) {
  return containers_.Mutable(index);
}
inline ::ItemContainer* PlayerUpdateLoot::add_containers() {
  return containers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ItemContainer >&
PlayerUpdateLoot::containers() const {
  return containers_;
}
inline ::google::protobuf::RepeatedPtrField< ::ItemContainer >*
PlayerUpdateLoot::mutable_containers() {
  return &containers_;
}

// -------------------------------------------------------------------

// ProjectileShoot_Projectile

// required uint64 projectileID = 1;
inline bool ProjectileShoot_Projectile::has_projectileid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProjectileShoot_Projectile::set_has_projectileid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProjectileShoot_Projectile::clear_has_projectileid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProjectileShoot_Projectile::clear_projectileid() {
  projectileid_ = GOOGLE_ULONGLONG(0);
  clear_has_projectileid();
}
inline ::google::protobuf::uint64 ProjectileShoot_Projectile::projectileid() const {
  return projectileid_;
}
inline void ProjectileShoot_Projectile::set_projectileid(::google::protobuf::uint64 value) {
  set_has_projectileid();
  projectileid_ = value;
}

// required .Vector3Serialized startPos = 2;
inline bool ProjectileShoot_Projectile::has_startpos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProjectileShoot_Projectile::set_has_startpos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProjectileShoot_Projectile::clear_has_startpos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProjectileShoot_Projectile::clear_startpos() {
  if (startpos_ != NULL) startpos_->::Vector3Serialized::Clear();
  clear_has_startpos();
}
inline const ::Vector3Serialized& ProjectileShoot_Projectile::startpos() const {
  return startpos_ != NULL ? *startpos_ : *default_instance_->startpos_;
}
inline ::Vector3Serialized* ProjectileShoot_Projectile::mutable_startpos() {
  set_has_startpos();
  if (startpos_ == NULL) startpos_ = new ::Vector3Serialized;
  return startpos_;
}
inline ::Vector3Serialized* ProjectileShoot_Projectile::release_startpos() {
  clear_has_startpos();
  ::Vector3Serialized* temp = startpos_;
  startpos_ = NULL;
  return temp;
}
inline void ProjectileShoot_Projectile::set_allocated_startpos(::Vector3Serialized* startpos) {
  delete startpos_;
  startpos_ = startpos;
  if (startpos) {
    set_has_startpos();
  } else {
    clear_has_startpos();
  }
}

// required .Vector3Serialized startVel = 3;
inline bool ProjectileShoot_Projectile::has_startvel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProjectileShoot_Projectile::set_has_startvel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProjectileShoot_Projectile::clear_has_startvel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProjectileShoot_Projectile::clear_startvel() {
  if (startvel_ != NULL) startvel_->::Vector3Serialized::Clear();
  clear_has_startvel();
}
inline const ::Vector3Serialized& ProjectileShoot_Projectile::startvel() const {
  return startvel_ != NULL ? *startvel_ : *default_instance_->startvel_;
}
inline ::Vector3Serialized* ProjectileShoot_Projectile::mutable_startvel() {
  set_has_startvel();
  if (startvel_ == NULL) startvel_ = new ::Vector3Serialized;
  return startvel_;
}
inline ::Vector3Serialized* ProjectileShoot_Projectile::release_startvel() {
  clear_has_startvel();
  ::Vector3Serialized* temp = startvel_;
  startvel_ = NULL;
  return temp;
}
inline void ProjectileShoot_Projectile::set_allocated_startvel(::Vector3Serialized* startvel) {
  delete startvel_;
  startvel_ = startvel;
  if (startvel) {
    set_has_startvel();
  } else {
    clear_has_startvel();
  }
}

// required uint64 seed = 4;
inline bool ProjectileShoot_Projectile::has_seed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProjectileShoot_Projectile::set_has_seed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProjectileShoot_Projectile::clear_has_seed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProjectileShoot_Projectile::clear_seed() {
  seed_ = GOOGLE_ULONGLONG(0);
  clear_has_seed();
}
inline ::google::protobuf::uint64 ProjectileShoot_Projectile::seed() const {
  return seed_;
}
inline void ProjectileShoot_Projectile::set_seed(::google::protobuf::uint64 value) {
  set_has_seed();
  seed_ = value;
}

// -------------------------------------------------------------------

// ProjectileShoot

// required uint64 ammoType = 1;
inline bool ProjectileShoot::has_ammotype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProjectileShoot::set_has_ammotype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProjectileShoot::clear_has_ammotype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProjectileShoot::clear_ammotype() {
  ammotype_ = GOOGLE_ULONGLONG(0);
  clear_has_ammotype();
}
inline ::google::protobuf::uint64 ProjectileShoot::ammotype() const {
  return ammotype_;
}
inline void ProjectileShoot::set_ammotype(::google::protobuf::uint64 value) {
  set_has_ammotype();
  ammotype_ = value;
}

// repeated .ProjectileShoot.Projectile projectiles = 2;
inline int ProjectileShoot::projectiles_size() const {
  return projectiles_.size();
}
inline void ProjectileShoot::clear_projectiles() {
  projectiles_.Clear();
}
inline const ::ProjectileShoot_Projectile& ProjectileShoot::projectiles(int index) const {
  return projectiles_.Get(index);
}
inline ::ProjectileShoot_Projectile* ProjectileShoot::mutable_projectiles(int index) {
  return projectiles_.Mutable(index);
}
inline ::ProjectileShoot_Projectile* ProjectileShoot::add_projectiles() {
  return projectiles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProjectileShoot_Projectile >&
ProjectileShoot::projectiles() const {
  return projectiles_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProjectileShoot_Projectile >*
ProjectileShoot::mutable_projectiles() {
  return &projectiles_;
}

// -------------------------------------------------------------------

// RespawnInformation_SpawnOptions

// required .RespawnInformation.SpawnOptions.RespawnType type = 1;
inline bool RespawnInformation_SpawnOptions::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RespawnInformation_SpawnOptions::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RespawnInformation_SpawnOptions::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RespawnInformation_SpawnOptions::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::RespawnInformation_SpawnOptions_RespawnType RespawnInformation_SpawnOptions::type() const {
  return static_cast< ::RespawnInformation_SpawnOptions_RespawnType >(type_);
}
inline void RespawnInformation_SpawnOptions::set_type(::RespawnInformation_SpawnOptions_RespawnType value) {
  assert(::RespawnInformation_SpawnOptions_RespawnType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required uint32 id = 2;
inline bool RespawnInformation_SpawnOptions::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RespawnInformation_SpawnOptions::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RespawnInformation_SpawnOptions::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RespawnInformation_SpawnOptions::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 RespawnInformation_SpawnOptions::id() const {
  return id_;
}
inline void RespawnInformation_SpawnOptions::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required string name = 3;
inline bool RespawnInformation_SpawnOptions::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RespawnInformation_SpawnOptions::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RespawnInformation_SpawnOptions::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RespawnInformation_SpawnOptions::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RespawnInformation_SpawnOptions::name() const {
  return *name_;
}
inline void RespawnInformation_SpawnOptions::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RespawnInformation_SpawnOptions::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RespawnInformation_SpawnOptions::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RespawnInformation_SpawnOptions::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RespawnInformation_SpawnOptions::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RespawnInformation_SpawnOptions::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required float unlockSeconds = 4;
inline bool RespawnInformation_SpawnOptions::has_unlockseconds() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RespawnInformation_SpawnOptions::set_has_unlockseconds() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RespawnInformation_SpawnOptions::clear_has_unlockseconds() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RespawnInformation_SpawnOptions::clear_unlockseconds() {
  unlockseconds_ = 0;
  clear_has_unlockseconds();
}
inline float RespawnInformation_SpawnOptions::unlockseconds() const {
  return unlockseconds_;
}
inline void RespawnInformation_SpawnOptions::set_unlockseconds(float value) {
  set_has_unlockseconds();
  unlockseconds_ = value;
}

// -------------------------------------------------------------------

// RespawnInformation

// repeated .RespawnInformation.SpawnOptions spawnOptions = 1;
inline int RespawnInformation::spawnoptions_size() const {
  return spawnoptions_.size();
}
inline void RespawnInformation::clear_spawnoptions() {
  spawnoptions_.Clear();
}
inline const ::RespawnInformation_SpawnOptions& RespawnInformation::spawnoptions(int index) const {
  return spawnoptions_.Get(index);
}
inline ::RespawnInformation_SpawnOptions* RespawnInformation::mutable_spawnoptions(int index) {
  return spawnoptions_.Mutable(index);
}
inline ::RespawnInformation_SpawnOptions* RespawnInformation::add_spawnoptions() {
  return spawnoptions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RespawnInformation_SpawnOptions >&
RespawnInformation::spawnoptions() const {
  return spawnoptions_;
}
inline ::google::protobuf::RepeatedPtrField< ::RespawnInformation_SpawnOptions >*
RespawnInformation::mutable_spawnoptions() {
  return &spawnoptions_;
}

// optional .PlayerLifeStory previousLife = 2;
inline bool RespawnInformation::has_previouslife() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RespawnInformation::set_has_previouslife() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RespawnInformation::clear_has_previouslife() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RespawnInformation::clear_previouslife() {
  if (previouslife_ != NULL) previouslife_->::PlayerLifeStory::Clear();
  clear_has_previouslife();
}
inline const ::PlayerLifeStory& RespawnInformation::previouslife() const {
  return previouslife_ != NULL ? *previouslife_ : *default_instance_->previouslife_;
}
inline ::PlayerLifeStory* RespawnInformation::mutable_previouslife() {
  set_has_previouslife();
  if (previouslife_ == NULL) previouslife_ = new ::PlayerLifeStory;
  return previouslife_;
}
inline ::PlayerLifeStory* RespawnInformation::release_previouslife() {
  clear_has_previouslife();
  ::PlayerLifeStory* temp = previouslife_;
  previouslife_ = NULL;
  return temp;
}
inline void RespawnInformation::set_allocated_previouslife(::PlayerLifeStory* previouslife) {
  delete previouslife_;
  previouslife_ = previouslife;
  if (previouslife) {
    set_has_previouslife();
  } else {
    clear_has_previouslife();
  }
}

// required bool fadeIn = 3;
inline bool RespawnInformation::has_fadein() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RespawnInformation::set_has_fadein() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RespawnInformation::clear_has_fadein() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RespawnInformation::clear_fadein() {
  fadein_ = false;
  clear_has_fadein();
}
inline bool RespawnInformation::fadein() const {
  return fadein_;
}
inline void RespawnInformation::set_fadein(bool value) {
  set_has_fadein();
  fadein_ = value;
}

// -------------------------------------------------------------------

// TakeDamage

// required float amount = 1;
inline bool TakeDamage::has_amount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TakeDamage::set_has_amount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TakeDamage::clear_has_amount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TakeDamage::clear_amount() {
  amount_ = 0;
  clear_has_amount();
}
inline float TakeDamage::amount() const {
  return amount_;
}
inline void TakeDamage::set_amount(float value) {
  set_has_amount();
  amount_ = value;
}

// required .Vector3Serialized direction = 2;
inline bool TakeDamage::has_direction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TakeDamage::set_has_direction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TakeDamage::clear_has_direction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TakeDamage::clear_direction() {
  if (direction_ != NULL) direction_->::Vector3Serialized::Clear();
  clear_has_direction();
}
inline const ::Vector3Serialized& TakeDamage::direction() const {
  return direction_ != NULL ? *direction_ : *default_instance_->direction_;
}
inline ::Vector3Serialized* TakeDamage::mutable_direction() {
  set_has_direction();
  if (direction_ == NULL) direction_ = new ::Vector3Serialized;
  return direction_;
}
inline ::Vector3Serialized* TakeDamage::release_direction() {
  clear_has_direction();
  ::Vector3Serialized* temp = direction_;
  direction_ = NULL;
  return temp;
}
inline void TakeDamage::set_allocated_direction(::Vector3Serialized* direction) {
  delete direction_;
  direction_ = direction;
  if (direction) {
    set_has_direction();
  } else {
    clear_has_direction();
  }
}

// required uint64 type = 3;
inline bool TakeDamage::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TakeDamage::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TakeDamage::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TakeDamage::clear_type() {
  type_ = GOOGLE_ULONGLONG(0);
  clear_has_type();
}
inline ::google::protobuf::uint64 TakeDamage::type() const {
  return type_;
}
inline void TakeDamage::set_type(::google::protobuf::uint64 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// UpdateItem

// required .Item item = 1;
inline bool UpdateItem::has_item() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateItem::set_has_item() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateItem::clear_has_item() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateItem::clear_item() {
  if (item_ != NULL) item_->::Item::Clear();
  clear_has_item();
}
inline const ::Item& UpdateItem::item() const {
  return item_ != NULL ? *item_ : *default_instance_->item_;
}
inline ::Item* UpdateItem::mutable_item() {
  set_has_item();
  if (item_ == NULL) item_ = new ::Item;
  return item_;
}
inline ::Item* UpdateItem::release_item() {
  clear_has_item();
  ::Item* temp = item_;
  item_ = NULL;
  return temp;
}
inline void UpdateItem::set_allocated_item(::Item* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
}

// -------------------------------------------------------------------

// UpdateItemContainer

// required uint64 type = 1;
inline bool UpdateItemContainer::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateItemContainer::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateItemContainer::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateItemContainer::clear_type() {
  type_ = GOOGLE_ULONGLONG(0);
  clear_has_type();
}
inline ::google::protobuf::uint64 UpdateItemContainer::type() const {
  return type_;
}
inline void UpdateItemContainer::set_type(::google::protobuf::uint64 value) {
  set_has_type();
  type_ = value;
}

// repeated .ItemContainer container = 2;
inline int UpdateItemContainer::container_size() const {
  return container_.size();
}
inline void UpdateItemContainer::clear_container() {
  container_.Clear();
}
inline const ::ItemContainer& UpdateItemContainer::container(int index) const {
  return container_.Get(index);
}
inline ::ItemContainer* UpdateItemContainer::mutable_container(int index) {
  return container_.Mutable(index);
}
inline ::ItemContainer* UpdateItemContainer::add_container() {
  return container_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ItemContainer >&
UpdateItemContainer::container() const {
  return container_;
}
inline ::google::protobuf::RepeatedPtrField< ::ItemContainer >*
UpdateItemContainer::mutable_container() {
  return &container_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RespawnInformation_SpawnOptions_RespawnType>() {
  return ::RespawnInformation_SpawnOptions_RespawnType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_main_2eproto__INCLUDED
