// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: main.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "main.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* Vector3Serialized_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Vector3Serialized_reflection_ = NULL;
const ::google::protobuf::Descriptor* RaySerialized_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RaySerialized_reflection_ = NULL;
const ::google::protobuf::Descriptor* BaseNetworkable_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BaseNetworkable_reflection_ = NULL;
const ::google::protobuf::Descriptor* BaseEntity_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BaseEntity_reflection_ = NULL;
const ::google::protobuf::Descriptor* Item_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Item_reflection_ = NULL;
const ::google::protobuf::Descriptor* Item_InstanceData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Item_InstanceData_reflection_ = NULL;
const ::google::protobuf::Descriptor* Item_ConditionData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Item_ConditionData_reflection_ = NULL;
const ::google::protobuf::Descriptor* ItemContainer_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ItemContainer_reflection_ = NULL;
const ::google::protobuf::Descriptor* PlayerInventory_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PlayerInventory_reflection_ = NULL;
const ::google::protobuf::Descriptor* PlayerMetabolism_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PlayerMetabolism_reflection_ = NULL;
const ::google::protobuf::Descriptor* ModelState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ModelState_reflection_ = NULL;
const ::google::protobuf::Descriptor* PersistantPlayer_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PersistantPlayer_reflection_ = NULL;
const ::google::protobuf::Descriptor* PlayerLifeStory_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PlayerLifeStory_reflection_ = NULL;
const ::google::protobuf::Descriptor* PlayerLifeStory_DeathInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PlayerLifeStory_DeathInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* BasePlayer_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BasePlayer_reflection_ = NULL;
const ::google::protobuf::Descriptor* WorldItem_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WorldItem_reflection_ = NULL;
const ::google::protobuf::Descriptor* BaseResource_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BaseResource_reflection_ = NULL;
const ::google::protobuf::Descriptor* BuildingBlock_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BuildingBlock_reflection_ = NULL;
const ::google::protobuf::Descriptor* Environment_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Environment_reflection_ = NULL;
const ::google::protobuf::Descriptor* Corpse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Corpse_reflection_ = NULL;
const ::google::protobuf::Descriptor* ParentInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ParentInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* KeyLock_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  KeyLock_reflection_ = NULL;
const ::google::protobuf::Descriptor* CodeLock_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CodeLock_reflection_ = NULL;
const ::google::protobuf::Descriptor* CodeLock_Private_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CodeLock_Private_reflection_ = NULL;
const ::google::protobuf::Descriptor* EntitySlots_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EntitySlots_reflection_ = NULL;
const ::google::protobuf::Descriptor* PlayerNameID_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PlayerNameID_reflection_ = NULL;
const ::google::protobuf::Descriptor* BuildingPrivilege_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BuildingPrivilege_reflection_ = NULL;
const ::google::protobuf::Descriptor* StorageBox_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StorageBox_reflection_ = NULL;
const ::google::protobuf::Descriptor* HeldEntity_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HeldEntity_reflection_ = NULL;
const ::google::protobuf::Descriptor* Magazine_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Magazine_reflection_ = NULL;
const ::google::protobuf::Descriptor* BaseProjectile_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BaseProjectile_reflection_ = NULL;
const ::google::protobuf::Descriptor* BaseNPC_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BaseNPC_reflection_ = NULL;
const ::google::protobuf::Descriptor* Loot_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Loot_reflection_ = NULL;
const ::google::protobuf::Descriptor* GenericSpawner_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GenericSpawner_reflection_ = NULL;
const ::google::protobuf::Descriptor* GenericSpawner_SpawnedEnt_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GenericSpawner_SpawnedEnt_reflection_ = NULL;
const ::google::protobuf::Descriptor* SleepingBag_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SleepingBag_reflection_ = NULL;
const ::google::protobuf::Descriptor* SleepingBag_Private_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SleepingBag_Private_reflection_ = NULL;
const ::google::protobuf::Descriptor* LootableCorpse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LootableCorpse_reflection_ = NULL;
const ::google::protobuf::Descriptor* LootableCorpse_Private_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LootableCorpse_Private_reflection_ = NULL;
const ::google::protobuf::Descriptor* Sign_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Sign_reflection_ = NULL;
const ::google::protobuf::Descriptor* BaseCombat_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BaseCombat_reflection_ = NULL;
const ::google::protobuf::Descriptor* MapEntity_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MapEntity_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResearchTable_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResearchTable_reflection_ = NULL;
const ::google::protobuf::Descriptor* DudExplosive_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DudExplosive_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResourceExtractor_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResourceExtractor_reflection_ = NULL;
const ::google::protobuf::Descriptor* MiningQuarry_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MiningQuarry_reflection_ = NULL;
const ::google::protobuf::Descriptor* PlantEntity_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PlantEntity_reflection_ = NULL;
const ::google::protobuf::Descriptor* Helicopter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Helicopter_reflection_ = NULL;
const ::google::protobuf::Descriptor* Landmine_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Landmine_reflection_ = NULL;
const ::google::protobuf::Descriptor* AutoTurret_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AutoTurret_reflection_ = NULL;
const ::google::protobuf::Descriptor* SphereEntity_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SphereEntity_reflection_ = NULL;
const ::google::protobuf::Descriptor* StabilityEntity_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StabilityEntity_reflection_ = NULL;
const ::google::protobuf::Descriptor* OwnerInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  OwnerInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* DecayEntity_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DecayEntity_reflection_ = NULL;
const ::google::protobuf::Descriptor* Spawnable_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Spawnable_reflection_ = NULL;
const ::google::protobuf::Descriptor* ServerGib_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ServerGib_reflection_ = NULL;
const ::google::protobuf::Descriptor* VendingMachine_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VendingMachine_reflection_ = NULL;
const ::google::protobuf::Descriptor* VendingMachine_SellOrder_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VendingMachine_SellOrder_reflection_ = NULL;
const ::google::protobuf::Descriptor* VendingMachine_SellOrderContainer_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VendingMachine_SellOrderContainer_reflection_ = NULL;
const ::google::protobuf::Descriptor* SpinnerWheel_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SpinnerWheel_reflection_ = NULL;
const ::google::protobuf::Descriptor* Entity_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Entity_reflection_ = NULL;
const ::google::protobuf::Descriptor* Approval_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Approval_reflection_ = NULL;
const ::google::protobuf::Descriptor* Attack_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Attack_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClientReady_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClientReady_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClientReady_ClientInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClientReady_ClientInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* CreateBuilding_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CreateBuilding_reflection_ = NULL;
const ::google::protobuf::Descriptor* EntityList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EntityList_reflection_ = NULL;
const ::google::protobuf::Descriptor* ModuleMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ModuleMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* PlayerAttack_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PlayerAttack_reflection_ = NULL;
const ::google::protobuf::Descriptor* PlayerProjectileAttack_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PlayerProjectileAttack_reflection_ = NULL;
const ::google::protobuf::Descriptor* PlayerProjectileRicochet_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PlayerProjectileRicochet_reflection_ = NULL;
const ::google::protobuf::Descriptor* PlayerProjectileUpdate_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PlayerProjectileUpdate_reflection_ = NULL;
const ::google::protobuf::Descriptor* PlayerUpdateLoot_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PlayerUpdateLoot_reflection_ = NULL;
const ::google::protobuf::Descriptor* ProjectileShoot_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ProjectileShoot_reflection_ = NULL;
const ::google::protobuf::Descriptor* ProjectileShoot_Projectile_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ProjectileShoot_Projectile_reflection_ = NULL;
const ::google::protobuf::Descriptor* RespawnInformation_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RespawnInformation_reflection_ = NULL;
const ::google::protobuf::Descriptor* RespawnInformation_SpawnOptions_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RespawnInformation_SpawnOptions_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* RespawnInformation_SpawnOptions_RespawnType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* TakeDamage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TakeDamage_reflection_ = NULL;
const ::google::protobuf::Descriptor* UpdateItem_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UpdateItem_reflection_ = NULL;
const ::google::protobuf::Descriptor* UpdateItemContainer_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UpdateItemContainer_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_main_2eproto() {
  protobuf_AddDesc_main_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "main.proto");
  GOOGLE_CHECK(file != NULL);
  Vector3Serialized_descriptor_ = file->message_type(0);
  static const int Vector3Serialized_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vector3Serialized, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vector3Serialized, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vector3Serialized, z_),
  };
  Vector3Serialized_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Vector3Serialized_descriptor_,
      Vector3Serialized::default_instance_,
      Vector3Serialized_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vector3Serialized, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vector3Serialized, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Vector3Serialized));
  RaySerialized_descriptor_ = file->message_type(1);
  static const int RaySerialized_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RaySerialized, origin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RaySerialized, direction_),
  };
  RaySerialized_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RaySerialized_descriptor_,
      RaySerialized::default_instance_,
      RaySerialized_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RaySerialized, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RaySerialized, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RaySerialized));
  BaseNetworkable_descriptor_ = file->message_type(2);
  static const int BaseNetworkable_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BaseNetworkable, uid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BaseNetworkable, group_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BaseNetworkable, prefabid_),
  };
  BaseNetworkable_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BaseNetworkable_descriptor_,
      BaseNetworkable::default_instance_,
      BaseNetworkable_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BaseNetworkable, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BaseNetworkable, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BaseNetworkable));
  BaseEntity_descriptor_ = file->message_type(3);
  static const int BaseEntity_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BaseEntity, pos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BaseEntity, rot_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BaseEntity, flags_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BaseEntity, skinid_),
  };
  BaseEntity_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BaseEntity_descriptor_,
      BaseEntity::default_instance_,
      BaseEntity_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BaseEntity, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BaseEntity, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BaseEntity));
  Item_descriptor_ = file->message_type(4);
  static const int Item_offsets_[15] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Item, uid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Item, itemid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Item, slot_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Item, amount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Item, flags_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Item, removetime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Item, locktime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Item, worldentity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Item, instancedata_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Item, heldentity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Item, conditiondata_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Item, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Item, text_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Item, skinid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Item, contents_),
  };
  Item_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Item_descriptor_,
      Item::default_instance_,
      Item_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Item, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Item, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Item));
  Item_InstanceData_descriptor_ = Item_descriptor_->nested_type(0);
  static const int Item_InstanceData_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Item_InstanceData, dataint_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Item_InstanceData, blueprinttarget_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Item_InstanceData, blueprintamount_),
  };
  Item_InstanceData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Item_InstanceData_descriptor_,
      Item_InstanceData::default_instance_,
      Item_InstanceData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Item_InstanceData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Item_InstanceData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Item_InstanceData));
  Item_ConditionData_descriptor_ = Item_descriptor_->nested_type(1);
  static const int Item_ConditionData_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Item_ConditionData, condition_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Item_ConditionData, maxcondition_),
  };
  Item_ConditionData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Item_ConditionData_descriptor_,
      Item_ConditionData::default_instance_,
      Item_ConditionData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Item_ConditionData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Item_ConditionData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Item_ConditionData));
  ItemContainer_descriptor_ = file->message_type(5);
  static const int ItemContainer_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemContainer, uid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemContainer, slots_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemContainer, temperature_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemContainer, flags_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemContainer, allowedcontents_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemContainer, maxstacksize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemContainer, alloweditem_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemContainer, availableslots_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemContainer, contents_),
  };
  ItemContainer_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ItemContainer_descriptor_,
      ItemContainer::default_instance_,
      ItemContainer_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemContainer, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemContainer, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ItemContainer));
  PlayerInventory_descriptor_ = file->message_type(6);
  static const int PlayerInventory_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerInventory, invmain_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerInventory, invbelt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerInventory, invwear_),
  };
  PlayerInventory_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PlayerInventory_descriptor_,
      PlayerInventory::default_instance_,
      PlayerInventory_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerInventory, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerInventory, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PlayerInventory));
  PlayerMetabolism_descriptor_ = file->message_type(7);
  static const int PlayerMetabolism_offsets_[14] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerMetabolism, health_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerMetabolism, calories_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerMetabolism, hydration_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerMetabolism, heartrate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerMetabolism, temperature_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerMetabolism, poison_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerMetabolism, radiation_level_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerMetabolism, wetness_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerMetabolism, dirtyness_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerMetabolism, oxygen_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerMetabolism, bleeding_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerMetabolism, radiation_poisoning_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerMetabolism, comfort_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerMetabolism, pending_health_),
  };
  PlayerMetabolism_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PlayerMetabolism_descriptor_,
      PlayerMetabolism::default_instance_,
      PlayerMetabolism_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerMetabolism, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerMetabolism, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PlayerMetabolism));
  ModelState_descriptor_ = file->message_type(8);
  static const int ModelState_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelState, waterlevel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelState, lookdir_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelState, flags_),
  };
  ModelState_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ModelState_descriptor_,
      ModelState::default_instance_,
      ModelState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelState, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModelState, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ModelState));
  PersistantPlayer_descriptor_ = file->message_type(9);
  static const int PersistantPlayer_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PersistantPlayer, unlockeditems_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PersistantPlayer, protocolversion_),
  };
  PersistantPlayer_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PersistantPlayer_descriptor_,
      PersistantPlayer::default_instance_,
      PersistantPlayer_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PersistantPlayer, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PersistantPlayer, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PersistantPlayer));
  PlayerLifeStory_descriptor_ = file->message_type(10);
  static const int PlayerLifeStory_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerLifeStory, secondsalive_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerLifeStory, meterswalked_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerLifeStory, metersrun_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerLifeStory, secondssleeping_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerLifeStory, timeborn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerLifeStory, timedead_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerLifeStory, deathinfo_),
  };
  PlayerLifeStory_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PlayerLifeStory_descriptor_,
      PlayerLifeStory::default_instance_,
      PlayerLifeStory_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerLifeStory, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerLifeStory, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PlayerLifeStory));
  PlayerLifeStory_DeathInfo_descriptor_ = PlayerLifeStory_descriptor_->nested_type(0);
  static const int PlayerLifeStory_DeathInfo_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerLifeStory_DeathInfo, attackername_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerLifeStory_DeathInfo, attackersteamid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerLifeStory_DeathInfo, hitbone_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerLifeStory_DeathInfo, inflictorname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerLifeStory_DeathInfo, lastdamagetype_),
  };
  PlayerLifeStory_DeathInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PlayerLifeStory_DeathInfo_descriptor_,
      PlayerLifeStory_DeathInfo::default_instance_,
      PlayerLifeStory_DeathInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerLifeStory_DeathInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerLifeStory_DeathInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PlayerLifeStory_DeathInfo));
  BasePlayer_descriptor_ = file->message_type(11);
  static const int BasePlayer_offsets_[14] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BasePlayer, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BasePlayer, userid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BasePlayer, inventory_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BasePlayer, metabolism_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BasePlayer, modelstate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BasePlayer, playerflags_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BasePlayer, heldentity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BasePlayer, health_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BasePlayer, persistantdata_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BasePlayer, skincol_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BasePlayer, skintex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BasePlayer, skinmesh_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BasePlayer, currentlife_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BasePlayer, previouslife_),
  };
  BasePlayer_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BasePlayer_descriptor_,
      BasePlayer::default_instance_,
      BasePlayer_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BasePlayer, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BasePlayer, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BasePlayer));
  WorldItem_descriptor_ = file->message_type(12);
  static const int WorldItem_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WorldItem, item_),
  };
  WorldItem_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WorldItem_descriptor_,
      WorldItem::default_instance_,
      WorldItem_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WorldItem, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WorldItem, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WorldItem));
  BaseResource_descriptor_ = file->message_type(13);
  static const int BaseResource_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BaseResource, stage_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BaseResource, health_),
  };
  BaseResource_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BaseResource_descriptor_,
      BaseResource::default_instance_,
      BaseResource_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BaseResource, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BaseResource, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BaseResource));
  BuildingBlock_descriptor_ = file->message_type(14);
  static const int BuildingBlock_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BuildingBlock, grade_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BuildingBlock, beingdemolished_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BuildingBlock, stability_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BuildingBlock, buildingid_),
  };
  BuildingBlock_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BuildingBlock_descriptor_,
      BuildingBlock::default_instance_,
      BuildingBlock_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BuildingBlock, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BuildingBlock, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BuildingBlock));
  Environment_descriptor_ = file->message_type(15);
  static const int Environment_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Environment, datetime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Environment, clouds_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Environment, fog_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Environment, wind_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Environment, rain_),
  };
  Environment_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Environment_descriptor_,
      Environment::default_instance_,
      Environment_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Environment, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Environment, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Environment));
  Corpse_descriptor_ = file->message_type(16);
  static const int Corpse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Corpse, parentid_),
  };
  Corpse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Corpse_descriptor_,
      Corpse::default_instance_,
      Corpse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Corpse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Corpse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Corpse));
  ParentInfo_descriptor_ = file->message_type(17);
  static const int ParentInfo_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParentInfo, uid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParentInfo, bone_),
  };
  ParentInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ParentInfo_descriptor_,
      ParentInfo::default_instance_,
      ParentInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParentInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ParentInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ParentInfo));
  KeyLock_descriptor_ = file->message_type(18);
  static const int KeyLock_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyLock, code_),
  };
  KeyLock_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      KeyLock_descriptor_,
      KeyLock::default_instance_,
      KeyLock_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyLock, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyLock, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(KeyLock));
  CodeLock_descriptor_ = file->message_type(19);
  static const int CodeLock_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CodeLock, pv_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CodeLock, hascode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CodeLock, hasguestcode_),
  };
  CodeLock_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CodeLock_descriptor_,
      CodeLock::default_instance_,
      CodeLock_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CodeLock, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CodeLock, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CodeLock));
  CodeLock_Private_descriptor_ = CodeLock_descriptor_->nested_type(0);
  static const int CodeLock_Private_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CodeLock_Private, code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CodeLock_Private, users_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CodeLock_Private, guests_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CodeLock_Private, guestcode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CodeLock_Private, guestusers_),
  };
  CodeLock_Private_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CodeLock_Private_descriptor_,
      CodeLock_Private::default_instance_,
      CodeLock_Private_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CodeLock_Private, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CodeLock_Private, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CodeLock_Private));
  EntitySlots_descriptor_ = file->message_type(20);
  static const int EntitySlots_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EntitySlots, slotlock_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EntitySlots, slotfiremod_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EntitySlots, slotuppermodification_),
  };
  EntitySlots_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EntitySlots_descriptor_,
      EntitySlots::default_instance_,
      EntitySlots_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EntitySlots, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EntitySlots, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EntitySlots));
  PlayerNameID_descriptor_ = file->message_type(21);
  static const int PlayerNameID_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerNameID, username_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerNameID, userid_),
  };
  PlayerNameID_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PlayerNameID_descriptor_,
      PlayerNameID::default_instance_,
      PlayerNameID_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerNameID, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerNameID, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PlayerNameID));
  BuildingPrivilege_descriptor_ = file->message_type(22);
  static const int BuildingPrivilege_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BuildingPrivilege, users_),
  };
  BuildingPrivilege_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BuildingPrivilege_descriptor_,
      BuildingPrivilege::default_instance_,
      BuildingPrivilege_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BuildingPrivilege, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BuildingPrivilege, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BuildingPrivilege));
  StorageBox_descriptor_ = file->message_type(23);
  static const int StorageBox_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StorageBox, contents_),
  };
  StorageBox_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      StorageBox_descriptor_,
      StorageBox::default_instance_,
      StorageBox_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StorageBox, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StorageBox, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(StorageBox));
  HeldEntity_descriptor_ = file->message_type(24);
  static const int HeldEntity_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeldEntity, itemuid_),
  };
  HeldEntity_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HeldEntity_descriptor_,
      HeldEntity::default_instance_,
      HeldEntity_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeldEntity, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeldEntity, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HeldEntity));
  Magazine_descriptor_ = file->message_type(25);
  static const int Magazine_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Magazine, capacity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Magazine, contents_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Magazine, ammotype_),
  };
  Magazine_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Magazine_descriptor_,
      Magazine::default_instance_,
      Magazine_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Magazine, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Magazine, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Magazine));
  BaseProjectile_descriptor_ = file->message_type(26);
  static const int BaseProjectile_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BaseProjectile, primarymagazine_),
  };
  BaseProjectile_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BaseProjectile_descriptor_,
      BaseProjectile::default_instance_,
      BaseProjectile_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BaseProjectile, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BaseProjectile, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BaseProjectile));
  BaseNPC_descriptor_ = file->message_type(27);
  static const int BaseNPC_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BaseNPC, flags_),
  };
  BaseNPC_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BaseNPC_descriptor_,
      BaseNPC::default_instance_,
      BaseNPC_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BaseNPC, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BaseNPC, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BaseNPC));
  Loot_descriptor_ = file->message_type(28);
  static const int Loot_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Loot, contents_),
  };
  Loot_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Loot_descriptor_,
      Loot::default_instance_,
      Loot_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Loot, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Loot, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Loot));
  GenericSpawner_descriptor_ = file->message_type(29);
  static const int GenericSpawner_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GenericSpawner, ents_),
  };
  GenericSpawner_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GenericSpawner_descriptor_,
      GenericSpawner::default_instance_,
      GenericSpawner_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GenericSpawner, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GenericSpawner, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GenericSpawner));
  GenericSpawner_SpawnedEnt_descriptor_ = GenericSpawner_descriptor_->nested_type(0);
  static const int GenericSpawner_SpawnedEnt_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GenericSpawner_SpawnedEnt, uid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GenericSpawner_SpawnedEnt, spawnpointindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GenericSpawner_SpawnedEnt, mobile_),
  };
  GenericSpawner_SpawnedEnt_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GenericSpawner_SpawnedEnt_descriptor_,
      GenericSpawner_SpawnedEnt::default_instance_,
      GenericSpawner_SpawnedEnt_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GenericSpawner_SpawnedEnt, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GenericSpawner_SpawnedEnt, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GenericSpawner_SpawnedEnt));
  SleepingBag_descriptor_ = file->message_type(30);
  static const int SleepingBag_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SleepingBag, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SleepingBag, privatedata_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SleepingBag, deployerid_),
  };
  SleepingBag_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SleepingBag_descriptor_,
      SleepingBag::default_instance_,
      SleepingBag_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SleepingBag, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SleepingBag, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SleepingBag));
  SleepingBag_Private_descriptor_ = SleepingBag_descriptor_->nested_type(0);
  static const int SleepingBag_Private_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SleepingBag_Private, deployerid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SleepingBag_Private, deployername_),
  };
  SleepingBag_Private_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SleepingBag_Private_descriptor_,
      SleepingBag_Private::default_instance_,
      SleepingBag_Private_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SleepingBag_Private, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SleepingBag_Private, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SleepingBag_Private));
  LootableCorpse_descriptor_ = file->message_type(31);
  static const int LootableCorpse_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LootableCorpse, privatedata_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LootableCorpse, playerid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LootableCorpse, playername_),
  };
  LootableCorpse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LootableCorpse_descriptor_,
      LootableCorpse::default_instance_,
      LootableCorpse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LootableCorpse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LootableCorpse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LootableCorpse));
  LootableCorpse_Private_descriptor_ = LootableCorpse_descriptor_->nested_type(0);
  static const int LootableCorpse_Private_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LootableCorpse_Private, container_),
  };
  LootableCorpse_Private_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LootableCorpse_Private_descriptor_,
      LootableCorpse_Private::default_instance_,
      LootableCorpse_Private_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LootableCorpse_Private, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LootableCorpse_Private, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LootableCorpse_Private));
  Sign_descriptor_ = file->message_type(32);
  static const int Sign_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sign, imageid_),
  };
  Sign_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Sign_descriptor_,
      Sign::default_instance_,
      Sign_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sign, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sign, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Sign));
  BaseCombat_descriptor_ = file->message_type(33);
  static const int BaseCombat_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BaseCombat, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BaseCombat, health_),
  };
  BaseCombat_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BaseCombat_descriptor_,
      BaseCombat::default_instance_,
      BaseCombat_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BaseCombat, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BaseCombat, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BaseCombat));
  MapEntity_descriptor_ = file->message_type(34);
  static const int MapEntity_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapEntity, fogimages_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapEntity, paintimages_),
  };
  MapEntity_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MapEntity_descriptor_,
      MapEntity::default_instance_,
      MapEntity_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapEntity, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapEntity, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MapEntity));
  ResearchTable_descriptor_ = file->message_type(35);
  static const int ResearchTable_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResearchTable, researchtimeleft_),
  };
  ResearchTable_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ResearchTable_descriptor_,
      ResearchTable::default_instance_,
      ResearchTable_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResearchTable, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResearchTable, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ResearchTable));
  DudExplosive_descriptor_ = file->message_type(36);
  static const int DudExplosive_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DudExplosive, fusetimeleft_),
  };
  DudExplosive_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DudExplosive_descriptor_,
      DudExplosive::default_instance_,
      DudExplosive_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DudExplosive, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DudExplosive, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DudExplosive));
  ResourceExtractor_descriptor_ = file->message_type(37);
  static const int ResourceExtractor_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceExtractor, fuelcontents_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceExtractor, outputcontents_),
  };
  ResourceExtractor_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ResourceExtractor_descriptor_,
      ResourceExtractor::default_instance_,
      ResourceExtractor_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceExtractor, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceExtractor, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ResourceExtractor));
  MiningQuarry_descriptor_ = file->message_type(38);
  static const int MiningQuarry_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MiningQuarry, extractor_),
  };
  MiningQuarry_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MiningQuarry_descriptor_,
      MiningQuarry::default_instance_,
      MiningQuarry_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MiningQuarry, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MiningQuarry, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MiningQuarry));
  PlantEntity_descriptor_ = file->message_type(39);
  static const int PlantEntity_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlantEntity, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlantEntity, age_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlantEntity, genetics_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlantEntity, water_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlantEntity, healthy_),
  };
  PlantEntity_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PlantEntity_descriptor_,
      PlantEntity::default_instance_,
      PlantEntity_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlantEntity, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlantEntity, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PlantEntity));
  Helicopter_descriptor_ = file->message_type(40);
  static const int Helicopter_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Helicopter, tiltrot_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Helicopter, leftgun_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Helicopter, rightgun_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Helicopter, spotlightvec_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Helicopter, weakspothealths_),
  };
  Helicopter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Helicopter_descriptor_,
      Helicopter::default_instance_,
      Helicopter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Helicopter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Helicopter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Helicopter));
  Landmine_descriptor_ = file->message_type(41);
  static const int Landmine_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Landmine, triggeredid_),
  };
  Landmine_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Landmine_descriptor_,
      Landmine::default_instance_,
      Landmine_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Landmine, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Landmine, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Landmine));
  AutoTurret_descriptor_ = file->message_type(42);
  static const int AutoTurret_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AutoTurret, aimpos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AutoTurret, aimdir_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AutoTurret, targetid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AutoTurret, users_),
  };
  AutoTurret_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AutoTurret_descriptor_,
      AutoTurret::default_instance_,
      AutoTurret_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AutoTurret, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AutoTurret, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AutoTurret));
  SphereEntity_descriptor_ = file->message_type(43);
  static const int SphereEntity_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SphereEntity, radius_),
  };
  SphereEntity_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SphereEntity_descriptor_,
      SphereEntity::default_instance_,
      SphereEntity_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SphereEntity, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SphereEntity, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SphereEntity));
  StabilityEntity_descriptor_ = file->message_type(44);
  static const int StabilityEntity_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StabilityEntity, stability_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StabilityEntity, distancefromground_),
  };
  StabilityEntity_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      StabilityEntity_descriptor_,
      StabilityEntity::default_instance_,
      StabilityEntity_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StabilityEntity, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StabilityEntity, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(StabilityEntity));
  OwnerInfo_descriptor_ = file->message_type(45);
  static const int OwnerInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OwnerInfo, steamid_),
  };
  OwnerInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      OwnerInfo_descriptor_,
      OwnerInfo::default_instance_,
      OwnerInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OwnerInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OwnerInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(OwnerInfo));
  DecayEntity_descriptor_ = file->message_type(46);
  static const int DecayEntity_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DecayEntity, decaytimer_),
  };
  DecayEntity_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DecayEntity_descriptor_,
      DecayEntity::default_instance_,
      DecayEntity_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DecayEntity, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DecayEntity, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DecayEntity));
  Spawnable_descriptor_ = file->message_type(47);
  static const int Spawnable_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Spawnable, population_),
  };
  Spawnable_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Spawnable_descriptor_,
      Spawnable::default_instance_,
      Spawnable_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Spawnable, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Spawnable, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Spawnable));
  ServerGib_descriptor_ = file->message_type(48);
  static const int ServerGib_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServerGib, gibname_),
  };
  ServerGib_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ServerGib_descriptor_,
      ServerGib::default_instance_,
      ServerGib_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServerGib, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServerGib, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ServerGib));
  VendingMachine_descriptor_ = file->message_type(49);
  static const int VendingMachine_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VendingMachine, sellordercontainer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VendingMachine, shopname_),
  };
  VendingMachine_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VendingMachine_descriptor_,
      VendingMachine::default_instance_,
      VendingMachine_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VendingMachine, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VendingMachine, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VendingMachine));
  VendingMachine_SellOrder_descriptor_ = VendingMachine_descriptor_->nested_type(0);
  static const int VendingMachine_SellOrder_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VendingMachine_SellOrder, itemtosellid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VendingMachine_SellOrder, itemtosellamount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VendingMachine_SellOrder, currencyid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VendingMachine_SellOrder, currencyamountperitem_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VendingMachine_SellOrder, instock_),
  };
  VendingMachine_SellOrder_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VendingMachine_SellOrder_descriptor_,
      VendingMachine_SellOrder::default_instance_,
      VendingMachine_SellOrder_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VendingMachine_SellOrder, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VendingMachine_SellOrder, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VendingMachine_SellOrder));
  VendingMachine_SellOrderContainer_descriptor_ = VendingMachine_descriptor_->nested_type(1);
  static const int VendingMachine_SellOrderContainer_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VendingMachine_SellOrderContainer, sellorders_),
  };
  VendingMachine_SellOrderContainer_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VendingMachine_SellOrderContainer_descriptor_,
      VendingMachine_SellOrderContainer::default_instance_,
      VendingMachine_SellOrderContainer_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VendingMachine_SellOrderContainer, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VendingMachine_SellOrderContainer, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VendingMachine_SellOrderContainer));
  SpinnerWheel_descriptor_ = file->message_type(50);
  static const int SpinnerWheel_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SpinnerWheel, spin_),
  };
  SpinnerWheel_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SpinnerWheel_descriptor_,
      SpinnerWheel::default_instance_,
      SpinnerWheel_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SpinnerWheel, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SpinnerWheel, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SpinnerWheel));
  Entity_descriptor_ = file->message_type(51);
  static const int Entity_offsets_[40] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, basenetworkable_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, baseentity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, baseplayer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, worlditem_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, resource_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, buildingblock_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, environment_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, corpse_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, parent_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, keylock_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, codelock_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, entityslots_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, buildingprivilege_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, storagebox_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, heldentity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, baseprojectile_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, basenpc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, loot_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, genericspawner_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, sleepingbag_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, lootablecorpse_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, sign_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, basecombat_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, mapentity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, researchtable_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, dudexplosive_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, miningquarry_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, plantentity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, helicopter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, landmine_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, autoturret_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, sphereentity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, stabilityentity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, ownerinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, decayentity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, spawnable_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, servergib_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, vendingmachine_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, spinnerwheel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, createdthisframe_),
  };
  Entity_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Entity_descriptor_,
      Entity::default_instance_,
      Entity_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entity, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Entity));
  Approval_descriptor_ = file->message_type(52);
  static const int Approval_offsets_[10] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Approval, level_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Approval, hostname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Approval, modded_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Approval, official_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Approval, steamid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Approval, ipaddress_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Approval, port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Approval, levelseed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Approval, levelsize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Approval, checksum_),
  };
  Approval_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Approval_descriptor_,
      Approval::default_instance_,
      Approval_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Approval, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Approval, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Approval));
  Attack_descriptor_ = file->message_type(53);
  static const int Attack_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attack, pointstart_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attack, pointend_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attack, hitid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attack, hitbone_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attack, hitnormallocal_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attack, hitpositionlocal_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attack, hitnormalworld_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attack, hitpositionworld_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attack, hitpartid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attack, hitmaterialid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attack, hititem_),
  };
  Attack_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Attack_descriptor_,
      Attack::default_instance_,
      Attack_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attack, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attack, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Attack));
  ClientReady_descriptor_ = file->message_type(54);
  static const int ClientReady_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReady, clientinfo_),
  };
  ClientReady_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClientReady_descriptor_,
      ClientReady::default_instance_,
      ClientReady_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReady, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReady, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClientReady));
  ClientReady_ClientInfo_descriptor_ = ClientReady_descriptor_->nested_type(0);
  static const int ClientReady_ClientInfo_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReady_ClientInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReady_ClientInfo, value_),
  };
  ClientReady_ClientInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClientReady_ClientInfo_descriptor_,
      ClientReady_ClientInfo::default_instance_,
      ClientReady_ClientInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReady_ClientInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReady_ClientInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClientReady_ClientInfo));
  CreateBuilding_descriptor_ = file->message_type(55);
  static const int CreateBuilding_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CreateBuilding, entity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CreateBuilding, socket_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CreateBuilding, onterrain_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CreateBuilding, position_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CreateBuilding, normal_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CreateBuilding, ray_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CreateBuilding, blockid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CreateBuilding, rotation_),
  };
  CreateBuilding_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CreateBuilding_descriptor_,
      CreateBuilding::default_instance_,
      CreateBuilding_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CreateBuilding, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CreateBuilding, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CreateBuilding));
  EntityList_descriptor_ = file->message_type(56);
  static const int EntityList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EntityList, entity_),
  };
  EntityList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EntityList_descriptor_,
      EntityList::default_instance_,
      EntityList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EntityList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EntityList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EntityList));
  ModuleMessage_descriptor_ = file->message_type(57);
  static const int ModuleMessage_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModuleMessage, itemid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModuleMessage, moduleid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModuleMessage, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModuleMessage, data_),
  };
  ModuleMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ModuleMessage_descriptor_,
      ModuleMessage::default_instance_,
      ModuleMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModuleMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModuleMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ModuleMessage));
  PlayerAttack_descriptor_ = file->message_type(58);
  static const int PlayerAttack_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerAttack, attack_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerAttack, projectileid_),
  };
  PlayerAttack_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PlayerAttack_descriptor_,
      PlayerAttack::default_instance_,
      PlayerAttack_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerAttack, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerAttack, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PlayerAttack));
  PlayerProjectileAttack_descriptor_ = file->message_type(59);
  static const int PlayerProjectileAttack_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerProjectileAttack, playerattack_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerProjectileAttack, hitvelocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerProjectileAttack, hitdistance_),
  };
  PlayerProjectileAttack_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PlayerProjectileAttack_descriptor_,
      PlayerProjectileAttack::default_instance_,
      PlayerProjectileAttack_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerProjectileAttack, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerProjectileAttack, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PlayerProjectileAttack));
  PlayerProjectileRicochet_descriptor_ = file->message_type(60);
  static const int PlayerProjectileRicochet_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerProjectileRicochet, projectileid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerProjectileRicochet, hitposition_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerProjectileRicochet, invelocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerProjectileRicochet, outvelocity_),
  };
  PlayerProjectileRicochet_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PlayerProjectileRicochet_descriptor_,
      PlayerProjectileRicochet::default_instance_,
      PlayerProjectileRicochet_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerProjectileRicochet, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerProjectileRicochet, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PlayerProjectileRicochet));
  PlayerProjectileUpdate_descriptor_ = file->message_type(61);
  static const int PlayerProjectileUpdate_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerProjectileUpdate, projectileid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerProjectileUpdate, curposition_),
  };
  PlayerProjectileUpdate_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PlayerProjectileUpdate_descriptor_,
      PlayerProjectileUpdate::default_instance_,
      PlayerProjectileUpdate_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerProjectileUpdate, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerProjectileUpdate, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PlayerProjectileUpdate));
  PlayerUpdateLoot_descriptor_ = file->message_type(62);
  static const int PlayerUpdateLoot_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerUpdateLoot, itemid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerUpdateLoot, entityid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerUpdateLoot, containers_),
  };
  PlayerUpdateLoot_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PlayerUpdateLoot_descriptor_,
      PlayerUpdateLoot::default_instance_,
      PlayerUpdateLoot_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerUpdateLoot, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerUpdateLoot, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PlayerUpdateLoot));
  ProjectileShoot_descriptor_ = file->message_type(63);
  static const int ProjectileShoot_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProjectileShoot, ammotype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProjectileShoot, projectiles_),
  };
  ProjectileShoot_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ProjectileShoot_descriptor_,
      ProjectileShoot::default_instance_,
      ProjectileShoot_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProjectileShoot, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProjectileShoot, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ProjectileShoot));
  ProjectileShoot_Projectile_descriptor_ = ProjectileShoot_descriptor_->nested_type(0);
  static const int ProjectileShoot_Projectile_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProjectileShoot_Projectile, projectileid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProjectileShoot_Projectile, startpos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProjectileShoot_Projectile, startvel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProjectileShoot_Projectile, seed_),
  };
  ProjectileShoot_Projectile_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ProjectileShoot_Projectile_descriptor_,
      ProjectileShoot_Projectile::default_instance_,
      ProjectileShoot_Projectile_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProjectileShoot_Projectile, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProjectileShoot_Projectile, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ProjectileShoot_Projectile));
  RespawnInformation_descriptor_ = file->message_type(64);
  static const int RespawnInformation_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RespawnInformation, spawnoptions_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RespawnInformation, previouslife_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RespawnInformation, fadein_),
  };
  RespawnInformation_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RespawnInformation_descriptor_,
      RespawnInformation::default_instance_,
      RespawnInformation_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RespawnInformation, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RespawnInformation, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RespawnInformation));
  RespawnInformation_SpawnOptions_descriptor_ = RespawnInformation_descriptor_->nested_type(0);
  static const int RespawnInformation_SpawnOptions_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RespawnInformation_SpawnOptions, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RespawnInformation_SpawnOptions, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RespawnInformation_SpawnOptions, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RespawnInformation_SpawnOptions, unlockseconds_),
  };
  RespawnInformation_SpawnOptions_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RespawnInformation_SpawnOptions_descriptor_,
      RespawnInformation_SpawnOptions::default_instance_,
      RespawnInformation_SpawnOptions_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RespawnInformation_SpawnOptions, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RespawnInformation_SpawnOptions, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RespawnInformation_SpawnOptions));
  RespawnInformation_SpawnOptions_RespawnType_descriptor_ = RespawnInformation_SpawnOptions_descriptor_->enum_type(0);
  TakeDamage_descriptor_ = file->message_type(65);
  static const int TakeDamage_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TakeDamage, amount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TakeDamage, direction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TakeDamage, type_),
  };
  TakeDamage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TakeDamage_descriptor_,
      TakeDamage::default_instance_,
      TakeDamage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TakeDamage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TakeDamage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TakeDamage));
  UpdateItem_descriptor_ = file->message_type(66);
  static const int UpdateItem_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateItem, item_),
  };
  UpdateItem_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UpdateItem_descriptor_,
      UpdateItem::default_instance_,
      UpdateItem_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateItem, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateItem, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UpdateItem));
  UpdateItemContainer_descriptor_ = file->message_type(67);
  static const int UpdateItemContainer_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateItemContainer, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateItemContainer, container_),
  };
  UpdateItemContainer_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UpdateItemContainer_descriptor_,
      UpdateItemContainer::default_instance_,
      UpdateItemContainer_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateItemContainer, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateItemContainer, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UpdateItemContainer));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_main_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Vector3Serialized_descriptor_, &Vector3Serialized::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RaySerialized_descriptor_, &RaySerialized::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BaseNetworkable_descriptor_, &BaseNetworkable::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BaseEntity_descriptor_, &BaseEntity::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Item_descriptor_, &Item::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Item_InstanceData_descriptor_, &Item_InstanceData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Item_ConditionData_descriptor_, &Item_ConditionData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ItemContainer_descriptor_, &ItemContainer::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PlayerInventory_descriptor_, &PlayerInventory::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PlayerMetabolism_descriptor_, &PlayerMetabolism::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ModelState_descriptor_, &ModelState::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PersistantPlayer_descriptor_, &PersistantPlayer::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PlayerLifeStory_descriptor_, &PlayerLifeStory::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PlayerLifeStory_DeathInfo_descriptor_, &PlayerLifeStory_DeathInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BasePlayer_descriptor_, &BasePlayer::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WorldItem_descriptor_, &WorldItem::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BaseResource_descriptor_, &BaseResource::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BuildingBlock_descriptor_, &BuildingBlock::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Environment_descriptor_, &Environment::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Corpse_descriptor_, &Corpse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ParentInfo_descriptor_, &ParentInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    KeyLock_descriptor_, &KeyLock::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CodeLock_descriptor_, &CodeLock::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CodeLock_Private_descriptor_, &CodeLock_Private::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EntitySlots_descriptor_, &EntitySlots::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PlayerNameID_descriptor_, &PlayerNameID::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BuildingPrivilege_descriptor_, &BuildingPrivilege::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    StorageBox_descriptor_, &StorageBox::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HeldEntity_descriptor_, &HeldEntity::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Magazine_descriptor_, &Magazine::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BaseProjectile_descriptor_, &BaseProjectile::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BaseNPC_descriptor_, &BaseNPC::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Loot_descriptor_, &Loot::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GenericSpawner_descriptor_, &GenericSpawner::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GenericSpawner_SpawnedEnt_descriptor_, &GenericSpawner_SpawnedEnt::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SleepingBag_descriptor_, &SleepingBag::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SleepingBag_Private_descriptor_, &SleepingBag_Private::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LootableCorpse_descriptor_, &LootableCorpse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LootableCorpse_Private_descriptor_, &LootableCorpse_Private::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Sign_descriptor_, &Sign::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BaseCombat_descriptor_, &BaseCombat::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MapEntity_descriptor_, &MapEntity::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ResearchTable_descriptor_, &ResearchTable::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DudExplosive_descriptor_, &DudExplosive::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ResourceExtractor_descriptor_, &ResourceExtractor::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MiningQuarry_descriptor_, &MiningQuarry::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PlantEntity_descriptor_, &PlantEntity::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Helicopter_descriptor_, &Helicopter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Landmine_descriptor_, &Landmine::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AutoTurret_descriptor_, &AutoTurret::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SphereEntity_descriptor_, &SphereEntity::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    StabilityEntity_descriptor_, &StabilityEntity::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    OwnerInfo_descriptor_, &OwnerInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DecayEntity_descriptor_, &DecayEntity::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Spawnable_descriptor_, &Spawnable::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ServerGib_descriptor_, &ServerGib::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VendingMachine_descriptor_, &VendingMachine::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VendingMachine_SellOrder_descriptor_, &VendingMachine_SellOrder::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VendingMachine_SellOrderContainer_descriptor_, &VendingMachine_SellOrderContainer::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SpinnerWheel_descriptor_, &SpinnerWheel::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Entity_descriptor_, &Entity::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Approval_descriptor_, &Approval::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Attack_descriptor_, &Attack::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClientReady_descriptor_, &ClientReady::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClientReady_ClientInfo_descriptor_, &ClientReady_ClientInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CreateBuilding_descriptor_, &CreateBuilding::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EntityList_descriptor_, &EntityList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ModuleMessage_descriptor_, &ModuleMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PlayerAttack_descriptor_, &PlayerAttack::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PlayerProjectileAttack_descriptor_, &PlayerProjectileAttack::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PlayerProjectileRicochet_descriptor_, &PlayerProjectileRicochet::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PlayerProjectileUpdate_descriptor_, &PlayerProjectileUpdate::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PlayerUpdateLoot_descriptor_, &PlayerUpdateLoot::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ProjectileShoot_descriptor_, &ProjectileShoot::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ProjectileShoot_Projectile_descriptor_, &ProjectileShoot_Projectile::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RespawnInformation_descriptor_, &RespawnInformation::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RespawnInformation_SpawnOptions_descriptor_, &RespawnInformation_SpawnOptions::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TakeDamage_descriptor_, &TakeDamage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UpdateItem_descriptor_, &UpdateItem::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UpdateItemContainer_descriptor_, &UpdateItemContainer::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_main_2eproto() {
  delete Vector3Serialized::default_instance_;
  delete Vector3Serialized_reflection_;
  delete RaySerialized::default_instance_;
  delete RaySerialized_reflection_;
  delete BaseNetworkable::default_instance_;
  delete BaseNetworkable_reflection_;
  delete BaseEntity::default_instance_;
  delete BaseEntity_reflection_;
  delete Item::default_instance_;
  delete Item_reflection_;
  delete Item_InstanceData::default_instance_;
  delete Item_InstanceData_reflection_;
  delete Item_ConditionData::default_instance_;
  delete Item_ConditionData_reflection_;
  delete ItemContainer::default_instance_;
  delete ItemContainer_reflection_;
  delete PlayerInventory::default_instance_;
  delete PlayerInventory_reflection_;
  delete PlayerMetabolism::default_instance_;
  delete PlayerMetabolism_reflection_;
  delete ModelState::default_instance_;
  delete ModelState_reflection_;
  delete PersistantPlayer::default_instance_;
  delete PersistantPlayer_reflection_;
  delete PlayerLifeStory::default_instance_;
  delete PlayerLifeStory_reflection_;
  delete PlayerLifeStory_DeathInfo::default_instance_;
  delete PlayerLifeStory_DeathInfo_reflection_;
  delete BasePlayer::default_instance_;
  delete BasePlayer_reflection_;
  delete WorldItem::default_instance_;
  delete WorldItem_reflection_;
  delete BaseResource::default_instance_;
  delete BaseResource_reflection_;
  delete BuildingBlock::default_instance_;
  delete BuildingBlock_reflection_;
  delete Environment::default_instance_;
  delete Environment_reflection_;
  delete Corpse::default_instance_;
  delete Corpse_reflection_;
  delete ParentInfo::default_instance_;
  delete ParentInfo_reflection_;
  delete KeyLock::default_instance_;
  delete KeyLock_reflection_;
  delete CodeLock::default_instance_;
  delete CodeLock_reflection_;
  delete CodeLock_Private::default_instance_;
  delete CodeLock_Private_reflection_;
  delete EntitySlots::default_instance_;
  delete EntitySlots_reflection_;
  delete PlayerNameID::default_instance_;
  delete PlayerNameID_reflection_;
  delete BuildingPrivilege::default_instance_;
  delete BuildingPrivilege_reflection_;
  delete StorageBox::default_instance_;
  delete StorageBox_reflection_;
  delete HeldEntity::default_instance_;
  delete HeldEntity_reflection_;
  delete Magazine::default_instance_;
  delete Magazine_reflection_;
  delete BaseProjectile::default_instance_;
  delete BaseProjectile_reflection_;
  delete BaseNPC::default_instance_;
  delete BaseNPC_reflection_;
  delete Loot::default_instance_;
  delete Loot_reflection_;
  delete GenericSpawner::default_instance_;
  delete GenericSpawner_reflection_;
  delete GenericSpawner_SpawnedEnt::default_instance_;
  delete GenericSpawner_SpawnedEnt_reflection_;
  delete SleepingBag::default_instance_;
  delete SleepingBag_reflection_;
  delete SleepingBag_Private::default_instance_;
  delete SleepingBag_Private_reflection_;
  delete LootableCorpse::default_instance_;
  delete LootableCorpse_reflection_;
  delete LootableCorpse_Private::default_instance_;
  delete LootableCorpse_Private_reflection_;
  delete Sign::default_instance_;
  delete Sign_reflection_;
  delete BaseCombat::default_instance_;
  delete BaseCombat_reflection_;
  delete MapEntity::default_instance_;
  delete MapEntity_reflection_;
  delete ResearchTable::default_instance_;
  delete ResearchTable_reflection_;
  delete DudExplosive::default_instance_;
  delete DudExplosive_reflection_;
  delete ResourceExtractor::default_instance_;
  delete ResourceExtractor_reflection_;
  delete MiningQuarry::default_instance_;
  delete MiningQuarry_reflection_;
  delete PlantEntity::default_instance_;
  delete PlantEntity_reflection_;
  delete Helicopter::default_instance_;
  delete Helicopter_reflection_;
  delete Landmine::default_instance_;
  delete Landmine_reflection_;
  delete AutoTurret::default_instance_;
  delete AutoTurret_reflection_;
  delete SphereEntity::default_instance_;
  delete SphereEntity_reflection_;
  delete StabilityEntity::default_instance_;
  delete StabilityEntity_reflection_;
  delete OwnerInfo::default_instance_;
  delete OwnerInfo_reflection_;
  delete DecayEntity::default_instance_;
  delete DecayEntity_reflection_;
  delete Spawnable::default_instance_;
  delete Spawnable_reflection_;
  delete ServerGib::default_instance_;
  delete ServerGib_reflection_;
  delete VendingMachine::default_instance_;
  delete VendingMachine_reflection_;
  delete VendingMachine_SellOrder::default_instance_;
  delete VendingMachine_SellOrder_reflection_;
  delete VendingMachine_SellOrderContainer::default_instance_;
  delete VendingMachine_SellOrderContainer_reflection_;
  delete SpinnerWheel::default_instance_;
  delete SpinnerWheel_reflection_;
  delete Entity::default_instance_;
  delete Entity_reflection_;
  delete Approval::default_instance_;
  delete Approval_reflection_;
  delete Attack::default_instance_;
  delete Attack_reflection_;
  delete ClientReady::default_instance_;
  delete ClientReady_reflection_;
  delete ClientReady_ClientInfo::default_instance_;
  delete ClientReady_ClientInfo_reflection_;
  delete CreateBuilding::default_instance_;
  delete CreateBuilding_reflection_;
  delete EntityList::default_instance_;
  delete EntityList_reflection_;
  delete ModuleMessage::default_instance_;
  delete ModuleMessage_reflection_;
  delete PlayerAttack::default_instance_;
  delete PlayerAttack_reflection_;
  delete PlayerProjectileAttack::default_instance_;
  delete PlayerProjectileAttack_reflection_;
  delete PlayerProjectileRicochet::default_instance_;
  delete PlayerProjectileRicochet_reflection_;
  delete PlayerProjectileUpdate::default_instance_;
  delete PlayerProjectileUpdate_reflection_;
  delete PlayerUpdateLoot::default_instance_;
  delete PlayerUpdateLoot_reflection_;
  delete ProjectileShoot::default_instance_;
  delete ProjectileShoot_reflection_;
  delete ProjectileShoot_Projectile::default_instance_;
  delete ProjectileShoot_Projectile_reflection_;
  delete RespawnInformation::default_instance_;
  delete RespawnInformation_reflection_;
  delete RespawnInformation_SpawnOptions::default_instance_;
  delete RespawnInformation_SpawnOptions_reflection_;
  delete TakeDamage::default_instance_;
  delete TakeDamage_reflection_;
  delete UpdateItem::default_instance_;
  delete UpdateItem_reflection_;
  delete UpdateItemContainer::default_instance_;
  delete UpdateItemContainer_reflection_;
}

void protobuf_AddDesc_main_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\nmain.proto\"4\n\021Vector3Serialized\022\t\n\001x\030\001"
    " \002(\002\022\t\n\001y\030\002 \002(\002\022\t\n\001z\030\003 \002(\002\"Z\n\rRaySeriali"
    "zed\022\"\n\006origin\030\001 \002(\0132\022.Vector3Serialized\022"
    "%\n\tdirection\030\002 \002(\0132\022.Vector3Serialized\"\?"
    "\n\017BaseNetworkable\022\013\n\003uid\030\001 \002(\r\022\r\n\005group\030"
    "\002 \002(\r\022\020\n\010prefabID\030\003 \002(\r\"m\n\nBaseEntity\022\037\n"
    "\003pos\030\001 \002(\0132\022.Vector3Serialized\022\037\n\003rot\030\002 "
    "\002(\0132\022.Vector3Serialized\022\r\n\005flags\030\003 \002(\004\022\016"
    "\n\006skinid\030\004 \001(\004\"\320\003\n\004Item\022\013\n\003UID\030\001 \002(\r\022\016\n\006"
    "itemid\030\002 \002(\004\022\014\n\004slot\030\003 \002(\004\022\016\n\006amount\030\004 \002"
    "(\004\022\r\n\005flags\030\005 \002(\004\022\022\n\nremovetime\030\006 \002(\002\022\020\n"
    "\010locktime\030\007 \002(\002\022\023\n\013worldEntity\030\010 \002(\r\022(\n\014"
    "instanceData\030\t \001(\0132\022.Item.InstanceData\022\022"
    "\n\nheldEntity\030\n \002(\r\022*\n\rconditionData\030\013 \001("
    "\0132\023.Item.ConditionData\022\014\n\004name\030\016 \001(\t\022\014\n\004"
    "text\030\017 \001(\t\022\016\n\006skinid\030\020 \002(\004\022 \n\010contents\030d"
    " \001(\0132\016.ItemContainer\032Q\n\014InstanceData\022\017\n\007"
    "dataInt\030\001 \002(\004\022\027\n\017blueprintTarget\030\002 \002(\004\022\027"
    "\n\017blueprintAmount\030\003 \002(\004\0328\n\rConditionData"
    "\022\021\n\tcondition\030\001 \002(\002\022\024\n\014maxCondition\030\002 \002("
    "\002\"\304\001\n\rItemContainer\022\013\n\003UID\030\001 \002(\r\022\r\n\005slot"
    "s\030\002 \002(\004\022\023\n\013temperature\030\003 \002(\002\022\r\n\005flags\030\004 "
    "\002(\004\022\027\n\017allowedContents\030\005 \002(\004\022\024\n\014maxStack"
    "Size\030\006 \002(\004\022\023\n\013allowedItem\030\007 \002(\004\022\026\n\016avail"
    "ableSlots\030\010 \003(\004\022\027\n\010contents\030d \003(\0132\005.Item"
    "\"t\n\017PlayerInventory\022\037\n\007invMain\030\001 \001(\0132\016.I"
    "temContainer\022\037\n\007invBelt\030\002 \001(\0132\016.ItemCont"
    "ainer\022\037\n\007invWear\030\004 \001(\0132\016.ItemContainer\"\244"
    "\002\n\020PlayerMetabolism\022\016\n\006health\030\001 \002(\002\022\020\n\010c"
    "alories\030\002 \002(\002\022\021\n\thydration\030\003 \002(\002\022\021\n\thear"
    "trate\030\004 \002(\002\022\023\n\013temperature\030\005 \002(\002\022\016\n\006pois"
    "on\030\006 \002(\002\022\027\n\017radiation_level\030\007 \002(\002\022\017\n\007wet"
    "ness\030\010 \002(\002\022\021\n\tdirtyness\030\t \002(\002\022\016\n\006oxygen\030"
    "\n \002(\002\022\020\n\010bleeding\030\013 \002(\002\022\033\n\023radiation_poi"
    "soning\030\014 \002(\002\022\017\n\007comfort\030\r \002(\002\022\026\n\016pending"
    "_health\030\016 \002(\002\"T\n\nModelState\022\022\n\nwaterLeve"
    "l\030\004 \002(\002\022#\n\007lookDir\030\n \002(\0132\022.Vector3Serial"
    "ized\022\r\n\005flags\030\013 \002(\004\"B\n\020PersistantPlayer\022"
    "\025\n\runlockedItems\030\003 \003(\004\022\027\n\017protocolVersio"
    "n\030d \002(\004\"\271\002\n\017PlayerLifeStory\022\024\n\014secondsAl"
    "ive\030d \002(\002\022\024\n\014metersWalked\030e \002(\002\022\021\n\tmeter"
    "sRun\030f \002(\002\022\027\n\017secondsSleeping\030g \002(\002\022\020\n\010t"
    "imeBorn\030h \002(\r\022\020\n\010timeDead\030i \002(\r\022.\n\tdeath"
    "Info\030\310\001 \001(\0132\032.PlayerLifeStory.DeathInfo\032"
    "z\n\tDeathInfo\022\024\n\014attackerName\030\001 \001(\t\022\027\n\017at"
    "tackerSteamID\030\002 \002(\004\022\017\n\007hitBone\030\003 \001(\t\022\025\n\r"
    "inflictorName\030\004 \001(\t\022\026\n\016lastDamageType\030\005 "
    "\002(\004\"\376\002\n\nBasePlayer\022\014\n\004name\030\001 \001(\t\022\016\n\006user"
    "id\030\002 \002(\004\022#\n\tinventory\030\003 \001(\0132\020.PlayerInve"
    "ntory\022%\n\nmetabolism\030\004 \001(\0132\021.PlayerMetabo"
    "lism\022\037\n\nmodelState\030\006 \001(\0132\013.ModelState\022\023\n"
    "\013playerFlags\030\007 \002(\004\022\022\n\nheldEntity\030\010 \002(\r\022\016"
    "\n\006health\030\t \002(\002\022)\n\016persistantData\030\n \001(\0132\021"
    ".PersistantPlayer\022\017\n\007skinCol\030\017 \002(\002\022\017\n\007sk"
    "inTex\030\020 \002(\002\022\020\n\010skinMesh\030\021 \002(\002\022%\n\013current"
    "Life\030\024 \001(\0132\020.PlayerLifeStory\022&\n\014previous"
    "Life\030\025 \001(\0132\020.PlayerLifeStory\" \n\tWorldIte"
    "m\022\023\n\004item\030\001 \001(\0132\005.Item\"-\n\014BaseResource\022\r"
    "\n\005stage\030\001 \002(\004\022\016\n\006health\030\002 \002(\002\"^\n\rBuildin"
    "gBlock\022\r\n\005grade\030\002 \002(\004\022\027\n\017beingDemolished"
    "\030\003 \002(\010\022\021\n\tstability\030\004 \002(\002\022\022\n\nbuildingID\030"
    "\005 \002(\r\"X\n\013Environment\022\020\n\010dateTime\030\001 \002(\004\022\016"
    "\n\006clouds\030\002 \002(\002\022\013\n\003fog\030\003 \002(\002\022\014\n\004wind\030\004 \002("
    "\002\022\014\n\004rain\030\005 \002(\002\"\032\n\006Corpse\022\020\n\010parentID\030\001 "
    "\002(\r\"\'\n\nParentInfo\022\013\n\003uid\030\001 \002(\r\022\014\n\004bone\030\002"
    " \002(\r\"\027\n\007KeyLock\022\014\n\004code\030\001 \002(\004\"\257\001\n\010CodeLo"
    "ck\022\035\n\002pv\030\001 \001(\0132\021.CodeLock.Private\022\017\n\007has"
    "Code\030\002 \002(\010\022\024\n\014hasGuestCode\030\003 \002(\010\032]\n\007Priv"
    "ate\022\014\n\004code\030\001 \001(\t\022\r\n\005users\030\002 \003(\004\022\016\n\006gues"
    "ts\030\003 \003(\004\022\021\n\tguestCode\030\004 \001(\t\022\022\n\nguestUser"
    "s\030\005 \003(\004\"S\n\013EntitySlots\022\020\n\010slotLock\030\001 \002(\r"
    "\022\023\n\013slotFireMod\030\002 \002(\r\022\035\n\025slotUpperModifi"
    "cation\030\003 \002(\r\"0\n\014PlayerNameID\022\020\n\010username"
    "\030\001 \002(\t\022\016\n\006userid\030\002 \002(\004\"1\n\021BuildingPrivil"
    "ege\022\034\n\005users\030\001 \003(\0132\r.PlayerNameID\".\n\nSto"
    "rageBox\022 \n\010contents\030\001 \001(\0132\016.ItemContaine"
    "r\"\035\n\nHeldEntity\022\017\n\007itemUID\030\001 \002(\r\"@\n\010Maga"
    "zine\022\020\n\010capacity\030\001 \002(\004\022\020\n\010contents\030\002 \002(\004"
    "\022\020\n\010ammoType\030\003 \002(\004\"4\n\016BaseProjectile\022\"\n\017"
    "primaryMagazine\030\001 \001(\0132\t.Magazine\"\030\n\007Base"
    "NPC\022\r\n\005flags\030\002 \002(\004\"(\n\004Loot\022 \n\010contents\030\001"
    " \001(\0132\016.ItemContainer\"~\n\016GenericSpawner\022("
    "\n\004ents\030\001 \003(\0132\032.GenericSpawner.SpawnedEnt"
    "\032B\n\nSpawnedEnt\022\013\n\003uid\030\001 \002(\r\022\027\n\017spawnPoin"
    "tIndex\030\002 \002(\r\022\016\n\006mobile\030\003 \002(\010\"\217\001\n\013Sleepin"
    "gBag\022\014\n\004name\030\001 \001(\t\022)\n\013privateData\030\002 \001(\0132"
    "\024.SleepingBag.Private\022\022\n\ndeployerID\030\003 \002("
    "\004\0323\n\007Private\022\022\n\ndeployerID\030\001 \002(\004\022\024\n\014depl"
    "oyerName\030\002 \001(\t\"\222\001\n\016LootableCorpse\022,\n\013pri"
    "vateData\030\001 \001(\0132\027.LootableCorpse.Private\022"
    "\020\n\010playerID\030\002 \002(\004\022\022\n\nplayerName\030\003 \001(\t\032,\n"
    "\007Private\022!\n\tcontainer\030\001 \003(\0132\016.ItemContai"
    "ner\"\027\n\004Sign\022\017\n\007imageid\030\003 \002(\r\"+\n\nBaseComb"
    "at\022\r\n\005state\030\001 \002(\004\022\016\n\006health\030\002 \002(\002\"3\n\tMap"
    "Entity\022\021\n\tfogImages\030\001 \003(\r\022\023\n\013paintImages"
    "\030\002 \003(\r\")\n\rResearchTable\022\030\n\020researchTimeL"
    "eft\030\001 \002(\002\"$\n\014DudExplosive\022\024\n\014fuseTimeLef"
    "t\030\001 \002(\002\"a\n\021ResourceExtractor\022$\n\014fuelCont"
    "ents\030\001 \001(\0132\016.ItemContainer\022&\n\016outputCont"
    "ents\030\002 \001(\0132\016.ItemContainer\"5\n\014MiningQuar"
    "ry\022%\n\textractor\030\001 \001(\0132\022.ResourceExtracto"
    "r\"[\n\013PlantEntity\022\r\n\005state\030\001 \002(\004\022\013\n\003age\030\002"
    " \002(\002\022\020\n\010genetics\030\003 \002(\004\022\r\n\005water\030\004 \002(\004\022\017\n"
    "\007healthy\030\005 \002(\002\"\277\001\n\nHelicopter\022#\n\007tiltRot"
    "\030\001 \002(\0132\022.Vector3Serialized\022#\n\007leftGun\030\002 "
    "\002(\0132\022.Vector3Serialized\022$\n\010rightGun\030\003 \002("
    "\0132\022.Vector3Serialized\022(\n\014spotlightVec\030\004 "
    "\002(\0132\022.Vector3Serialized\022\027\n\017weakspothealt"
    "hs\030\005 \003(\002\"\037\n\010Landmine\022\023\n\013triggeredID\030\001 \002("
    "\004\"\204\001\n\nAutoTurret\022\"\n\006aimPos\030\001 \002(\0132\022.Vecto"
    "r3Serialized\022\"\n\006aimDir\030\002 \002(\0132\022.Vector3Se"
    "rialized\022\020\n\010targetID\030\003 \002(\r\022\034\n\005users\030\004 \003("
    "\0132\r.PlayerNameID\"\036\n\014SphereEntity\022\016\n\006radi"
    "us\030\001 \002(\002\"@\n\017StabilityEntity\022\021\n\tstability"
    "\030\001 \002(\002\022\032\n\022distanceFromGround\030\002 \002(\004\"\034\n\tOw"
    "nerInfo\022\017\n\007steamid\030\001 \002(\004\"!\n\013DecayEntity\022"
    "\022\n\ndecayTimer\030\001 \002(\002\"\037\n\tSpawnable\022\022\n\npopu"
    "lation\030\001 \002(\r\"\034\n\tServerGib\022\017\n\007gibName\030\001 \001"
    "(\t\"\250\002\n\016VendingMachine\022>\n\022sellOrderContai"
    "ner\030\001 \001(\0132\".VendingMachine.SellOrderCont"
    "ainer\022\020\n\010shopName\030\002 \001(\t\032\177\n\tSellOrder\022\024\n\014"
    "itemToSellID\030\001 \002(\004\022\030\n\020itemToSellAmount\030\002"
    " \002(\004\022\022\n\ncurrencyID\030\003 \002(\004\022\035\n\025currencyAmou"
    "ntPerItem\030\004 \002(\004\022\017\n\007inStock\030\005 \002(\004\032C\n\022Sell"
    "OrderContainer\022-\n\nsellOrders\030\001 \003(\0132\031.Ven"
    "dingMachine.SellOrder\"0\n\014SpinnerWheel\022 \n"
    "\004spin\030\001 \002(\0132\022.Vector3Serialized\"\317\n\n\006Enti"
    "ty\022)\n\017baseNetworkable\030\001 \001(\0132\020.BaseNetwor"
    "kable\022\037\n\nbaseEntity\030\002 \001(\0132\013.BaseEntity\022\037"
    "\n\nbasePlayer\030\003 \001(\0132\013.BasePlayer\022\035\n\tworld"
    "Item\030\004 \001(\0132\n.WorldItem\022\037\n\010resource\030\005 \001(\013"
    "2\r.BaseResource\022%\n\rbuildingBlock\030\006 \001(\0132\016"
    ".BuildingBlock\022!\n\013environment\030\007 \001(\0132\014.En"
    "vironment\022\027\n\006corpse\030\010 \001(\0132\007.Corpse\022\033\n\006pa"
    "rent\030\n \001(\0132\013.ParentInfo\022\031\n\007keyLock\030\013 \001(\013"
    "2\010.KeyLock\022\033\n\010codeLock\030\014 \001(\0132\t.CodeLock\022"
    "!\n\013entitySlots\030\r \001(\0132\014.EntitySlots\022-\n\021bu"
    "ildingPrivilege\030\016 \001(\0132\022.BuildingPrivileg"
    "e\022\037\n\nstorageBox\030\017 \001(\0132\013.StorageBox\022\037\n\nhe"
    "ldEntity\030\020 \001(\0132\013.HeldEntity\022\'\n\016baseProje"
    "ctile\030\021 \001(\0132\017.BaseProjectile\022\031\n\007baseNPC\030"
    "\022 \001(\0132\010.BaseNPC\022\023\n\004loot\030\023 \001(\0132\005.Loot\022\'\n\016"
    "genericSpawner\030\024 \001(\0132\017.GenericSpawner\022!\n"
    "\013sleepingBag\030\025 \001(\0132\014.SleepingBag\022\'\n\016loot"
    "ableCorpse\030\026 \001(\0132\017.LootableCorpse\022\023\n\004sig"
    "n\030\027 \001(\0132\005.Sign\022\037\n\nbaseCombat\030\030 \001(\0132\013.Bas"
    "eCombat\022\035\n\tmapEntity\030\031 \001(\0132\n.MapEntity\022%"
    "\n\rresearchTable\030\032 \001(\0132\016.ResearchTable\022#\n"
    "\014dudExplosive\030\033 \001(\0132\r.DudExplosive\022#\n\014mi"
    "ningQuarry\030\034 \001(\0132\r.MiningQuarry\022!\n\013plant"
    "Entity\030\035 \001(\0132\014.PlantEntity\022\037\n\nhelicopter"
    "\030\036 \001(\0132\013.Helicopter\022\033\n\010landmine\030\037 \001(\0132\t."
    "Landmine\022\037\n\nautoturret\030  \001(\0132\013.AutoTurre"
    "t\022#\n\014sphereEntity\030! \001(\0132\r.SphereEntity\022)"
    "\n\017stabilityEntity\030\" \001(\0132\020.StabilityEntit"
    "y\022\035\n\townerInfo\030# \001(\0132\n.OwnerInfo\022!\n\013deca"
    "yEntity\030$ \001(\0132\014.DecayEntity\022\035\n\tspawnable"
    "\030% \001(\0132\n.Spawnable\022\035\n\tservergib\030& \001(\0132\n."
    "ServerGib\022\'\n\016vendingMachine\030\' \001(\0132\017.Vend"
    "ingMachine\022#\n\014spinnerWheel\030( \001(\0132\r.Spinn"
    "erWheel\022\030\n\020createdThisFrame\030d \002(\010\"\267\001\n\010Ap"
    "proval\022\r\n\005level\030\002 \002(\t\022\020\n\010hostname\030\003 \001(\t\022"
    "\016\n\006modded\030\004 \002(\010\022\020\n\010official\030\005 \002(\010\022\017\n\007ste"
    "amid\030\006 \002(\004\022\021\n\tipaddress\030\007 \002(\r\022\014\n\004port\030\010 "
    "\002(\004\022\021\n\tlevelSeed\030\t \002(\r\022\021\n\tlevelSize\030\n \002("
    "\r\022\020\n\010checksum\030\013 \001(\t\"\345\002\n\006Attack\022&\n\npointS"
    "tart\030\001 \002(\0132\022.Vector3Serialized\022$\n\010pointE"
    "nd\030\002 \002(\0132\022.Vector3Serialized\022\r\n\005hitID\030\003 "
    "\002(\r\022\017\n\007hitBone\030\004 \002(\r\022*\n\016hitNormalLocal\030\005"
    " \002(\0132\022.Vector3Serialized\022,\n\020hitPositionL"
    "ocal\030\006 \002(\0132\022.Vector3Serialized\022*\n\016hitNor"
    "malWorld\030\007 \002(\0132\022.Vector3Serialized\022,\n\020hi"
    "tPositionWorld\030\010 \002(\0132\022.Vector3Serialized"
    "\022\021\n\thitPartID\030\t \002(\r\022\025\n\rhitMaterialID\030\n \002"
    "(\r\022\017\n\007hitItem\030\013 \002(\r\"e\n\013ClientReady\022+\n\ncl"
    "ientInfo\030\001 \003(\0132\027.ClientReady.ClientInfo\032"
    ")\n\nClientInfo\022\014\n\004name\030\001 \002(\t\022\r\n\005value\030\002 \002"
    "(\t\"\341\001\n\016CreateBuilding\022\016\n\006entity\030\001 \002(\r\022\016\n"
    "\006socket\030\002 \002(\r\022\021\n\tonterrain\030\003 \002(\010\022$\n\010posi"
    "tion\030\004 \002(\0132\022.Vector3Serialized\022\"\n\006normal"
    "\030\005 \002(\0132\022.Vector3Serialized\022\033\n\003ray\030\006 \002(\0132"
    "\016.RaySerialized\022\017\n\007blockID\030\007 \002(\r\022$\n\010rota"
    "tion\030\010 \002(\0132\022.Vector3Serialized\"%\n\nEntity"
    "List\022\027\n\006entity\030\001 \003(\0132\007.Entity\"M\n\rModuleM"
    "essage\022\016\n\006itemid\030\001 \002(\r\022\020\n\010moduleid\030\002 \002(\004"
    "\022\014\n\004type\030\003 \002(\004\022\014\n\004data\030\004 \001(\014\"=\n\014PlayerAt"
    "tack\022\027\n\006attack\030\001 \002(\0132\007.Attack\022\024\n\014project"
    "ileID\030\002 \002(\004\"{\n\026PlayerProjectileAttack\022#\n"
    "\014playerAttack\030\001 \002(\0132\r.PlayerAttack\022\'\n\013hi"
    "tVelocity\030\002 \002(\0132\022.Vector3Serialized\022\023\n\013h"
    "itDistance\030\003 \002(\002\"\252\001\n\030PlayerProjectileRic"
    "ochet\022\024\n\014projectileID\030\001 \002(\004\022\'\n\013hitPositi"
    "on\030\002 \002(\0132\022.Vector3Serialized\022&\n\ninVeloci"
    "ty\030\003 \002(\0132\022.Vector3Serialized\022\'\n\013outVeloc"
    "ity\030\004 \002(\0132\022.Vector3Serialized\"W\n\026PlayerP"
    "rojectileUpdate\022\024\n\014projectileID\030\001 \002(\004\022\'\n"
    "\013curPosition\030\002 \002(\0132\022.Vector3Serialized\"X"
    "\n\020PlayerUpdateLoot\022\016\n\006itemID\030\001 \002(\r\022\020\n\010en"
    "tityID\030\002 \002(\r\022\"\n\ncontainers\030\003 \003(\0132\016.ItemC"
    "ontainer\"\323\001\n\017ProjectileShoot\022\020\n\010ammoType"
    "\030\001 \002(\004\0220\n\013projectiles\030\002 \003(\0132\033.Projectile"
    "Shoot.Projectile\032|\n\nProjectile\022\024\n\014projec"
    "tileID\030\001 \002(\004\022$\n\010startPos\030\002 \002(\0132\022.Vector3"
    "Serialized\022$\n\010startVel\030\003 \002(\0132\022.Vector3Se"
    "rialized\022\014\n\004seed\030\004 \002(\004\"\253\002\n\022RespawnInform"
    "ation\0226\n\014spawnOptions\030\001 \003(\0132 .RespawnInf"
    "ormation.SpawnOptions\022&\n\014previousLife\030\002 "
    "\001(\0132\020.PlayerLifeStory\022\016\n\006fadeIn\030\003 \002(\010\032\244\001"
    "\n\014SpawnOptions\022:\n\004type\030\001 \002(\0162,.RespawnIn"
    "formation.SpawnOptions.RespawnType\022\n\n\002id"
    "\030\002 \002(\r\022\014\n\004name\030\003 \002(\t\022\025\n\runlockSeconds\030\004 "
    "\002(\002\"\'\n\013RespawnType\022\017\n\013SleepingBag\020\001\022\007\n\003B"
    "ed\020\002\"Q\n\nTakeDamage\022\016\n\006amount\030\001 \002(\002\022%\n\tdi"
    "rection\030\002 \002(\0132\022.Vector3Serialized\022\014\n\004typ"
    "e\030\003 \002(\004\"!\n\nUpdateItem\022\023\n\004item\030\001 \002(\0132\005.It"
    "em\"F\n\023UpdateItemContainer\022\014\n\004type\030\001 \002(\004\022"
    "!\n\tcontainer\030\002 \003(\0132\016.ItemContainer", 8674);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "main.proto", &protobuf_RegisterTypes);
  Vector3Serialized::default_instance_ = new Vector3Serialized();
  RaySerialized::default_instance_ = new RaySerialized();
  BaseNetworkable::default_instance_ = new BaseNetworkable();
  BaseEntity::default_instance_ = new BaseEntity();
  Item::default_instance_ = new Item();
  Item_InstanceData::default_instance_ = new Item_InstanceData();
  Item_ConditionData::default_instance_ = new Item_ConditionData();
  ItemContainer::default_instance_ = new ItemContainer();
  PlayerInventory::default_instance_ = new PlayerInventory();
  PlayerMetabolism::default_instance_ = new PlayerMetabolism();
  ModelState::default_instance_ = new ModelState();
  PersistantPlayer::default_instance_ = new PersistantPlayer();
  PlayerLifeStory::default_instance_ = new PlayerLifeStory();
  PlayerLifeStory_DeathInfo::default_instance_ = new PlayerLifeStory_DeathInfo();
  BasePlayer::default_instance_ = new BasePlayer();
  WorldItem::default_instance_ = new WorldItem();
  BaseResource::default_instance_ = new BaseResource();
  BuildingBlock::default_instance_ = new BuildingBlock();
  Environment::default_instance_ = new Environment();
  Corpse::default_instance_ = new Corpse();
  ParentInfo::default_instance_ = new ParentInfo();
  KeyLock::default_instance_ = new KeyLock();
  CodeLock::default_instance_ = new CodeLock();
  CodeLock_Private::default_instance_ = new CodeLock_Private();
  EntitySlots::default_instance_ = new EntitySlots();
  PlayerNameID::default_instance_ = new PlayerNameID();
  BuildingPrivilege::default_instance_ = new BuildingPrivilege();
  StorageBox::default_instance_ = new StorageBox();
  HeldEntity::default_instance_ = new HeldEntity();
  Magazine::default_instance_ = new Magazine();
  BaseProjectile::default_instance_ = new BaseProjectile();
  BaseNPC::default_instance_ = new BaseNPC();
  Loot::default_instance_ = new Loot();
  GenericSpawner::default_instance_ = new GenericSpawner();
  GenericSpawner_SpawnedEnt::default_instance_ = new GenericSpawner_SpawnedEnt();
  SleepingBag::default_instance_ = new SleepingBag();
  SleepingBag_Private::default_instance_ = new SleepingBag_Private();
  LootableCorpse::default_instance_ = new LootableCorpse();
  LootableCorpse_Private::default_instance_ = new LootableCorpse_Private();
  Sign::default_instance_ = new Sign();
  BaseCombat::default_instance_ = new BaseCombat();
  MapEntity::default_instance_ = new MapEntity();
  ResearchTable::default_instance_ = new ResearchTable();
  DudExplosive::default_instance_ = new DudExplosive();
  ResourceExtractor::default_instance_ = new ResourceExtractor();
  MiningQuarry::default_instance_ = new MiningQuarry();
  PlantEntity::default_instance_ = new PlantEntity();
  Helicopter::default_instance_ = new Helicopter();
  Landmine::default_instance_ = new Landmine();
  AutoTurret::default_instance_ = new AutoTurret();
  SphereEntity::default_instance_ = new SphereEntity();
  StabilityEntity::default_instance_ = new StabilityEntity();
  OwnerInfo::default_instance_ = new OwnerInfo();
  DecayEntity::default_instance_ = new DecayEntity();
  Spawnable::default_instance_ = new Spawnable();
  ServerGib::default_instance_ = new ServerGib();
  VendingMachine::default_instance_ = new VendingMachine();
  VendingMachine_SellOrder::default_instance_ = new VendingMachine_SellOrder();
  VendingMachine_SellOrderContainer::default_instance_ = new VendingMachine_SellOrderContainer();
  SpinnerWheel::default_instance_ = new SpinnerWheel();
  Entity::default_instance_ = new Entity();
  Approval::default_instance_ = new Approval();
  Attack::default_instance_ = new Attack();
  ClientReady::default_instance_ = new ClientReady();
  ClientReady_ClientInfo::default_instance_ = new ClientReady_ClientInfo();
  CreateBuilding::default_instance_ = new CreateBuilding();
  EntityList::default_instance_ = new EntityList();
  ModuleMessage::default_instance_ = new ModuleMessage();
  PlayerAttack::default_instance_ = new PlayerAttack();
  PlayerProjectileAttack::default_instance_ = new PlayerProjectileAttack();
  PlayerProjectileRicochet::default_instance_ = new PlayerProjectileRicochet();
  PlayerProjectileUpdate::default_instance_ = new PlayerProjectileUpdate();
  PlayerUpdateLoot::default_instance_ = new PlayerUpdateLoot();
  ProjectileShoot::default_instance_ = new ProjectileShoot();
  ProjectileShoot_Projectile::default_instance_ = new ProjectileShoot_Projectile();
  RespawnInformation::default_instance_ = new RespawnInformation();
  RespawnInformation_SpawnOptions::default_instance_ = new RespawnInformation_SpawnOptions();
  TakeDamage::default_instance_ = new TakeDamage();
  UpdateItem::default_instance_ = new UpdateItem();
  UpdateItemContainer::default_instance_ = new UpdateItemContainer();
  Vector3Serialized::default_instance_->InitAsDefaultInstance();
  RaySerialized::default_instance_->InitAsDefaultInstance();
  BaseNetworkable::default_instance_->InitAsDefaultInstance();
  BaseEntity::default_instance_->InitAsDefaultInstance();
  Item::default_instance_->InitAsDefaultInstance();
  Item_InstanceData::default_instance_->InitAsDefaultInstance();
  Item_ConditionData::default_instance_->InitAsDefaultInstance();
  ItemContainer::default_instance_->InitAsDefaultInstance();
  PlayerInventory::default_instance_->InitAsDefaultInstance();
  PlayerMetabolism::default_instance_->InitAsDefaultInstance();
  ModelState::default_instance_->InitAsDefaultInstance();
  PersistantPlayer::default_instance_->InitAsDefaultInstance();
  PlayerLifeStory::default_instance_->InitAsDefaultInstance();
  PlayerLifeStory_DeathInfo::default_instance_->InitAsDefaultInstance();
  BasePlayer::default_instance_->InitAsDefaultInstance();
  WorldItem::default_instance_->InitAsDefaultInstance();
  BaseResource::default_instance_->InitAsDefaultInstance();
  BuildingBlock::default_instance_->InitAsDefaultInstance();
  Environment::default_instance_->InitAsDefaultInstance();
  Corpse::default_instance_->InitAsDefaultInstance();
  ParentInfo::default_instance_->InitAsDefaultInstance();
  KeyLock::default_instance_->InitAsDefaultInstance();
  CodeLock::default_instance_->InitAsDefaultInstance();
  CodeLock_Private::default_instance_->InitAsDefaultInstance();
  EntitySlots::default_instance_->InitAsDefaultInstance();
  PlayerNameID::default_instance_->InitAsDefaultInstance();
  BuildingPrivilege::default_instance_->InitAsDefaultInstance();
  StorageBox::default_instance_->InitAsDefaultInstance();
  HeldEntity::default_instance_->InitAsDefaultInstance();
  Magazine::default_instance_->InitAsDefaultInstance();
  BaseProjectile::default_instance_->InitAsDefaultInstance();
  BaseNPC::default_instance_->InitAsDefaultInstance();
  Loot::default_instance_->InitAsDefaultInstance();
  GenericSpawner::default_instance_->InitAsDefaultInstance();
  GenericSpawner_SpawnedEnt::default_instance_->InitAsDefaultInstance();
  SleepingBag::default_instance_->InitAsDefaultInstance();
  SleepingBag_Private::default_instance_->InitAsDefaultInstance();
  LootableCorpse::default_instance_->InitAsDefaultInstance();
  LootableCorpse_Private::default_instance_->InitAsDefaultInstance();
  Sign::default_instance_->InitAsDefaultInstance();
  BaseCombat::default_instance_->InitAsDefaultInstance();
  MapEntity::default_instance_->InitAsDefaultInstance();
  ResearchTable::default_instance_->InitAsDefaultInstance();
  DudExplosive::default_instance_->InitAsDefaultInstance();
  ResourceExtractor::default_instance_->InitAsDefaultInstance();
  MiningQuarry::default_instance_->InitAsDefaultInstance();
  PlantEntity::default_instance_->InitAsDefaultInstance();
  Helicopter::default_instance_->InitAsDefaultInstance();
  Landmine::default_instance_->InitAsDefaultInstance();
  AutoTurret::default_instance_->InitAsDefaultInstance();
  SphereEntity::default_instance_->InitAsDefaultInstance();
  StabilityEntity::default_instance_->InitAsDefaultInstance();
  OwnerInfo::default_instance_->InitAsDefaultInstance();
  DecayEntity::default_instance_->InitAsDefaultInstance();
  Spawnable::default_instance_->InitAsDefaultInstance();
  ServerGib::default_instance_->InitAsDefaultInstance();
  VendingMachine::default_instance_->InitAsDefaultInstance();
  VendingMachine_SellOrder::default_instance_->InitAsDefaultInstance();
  VendingMachine_SellOrderContainer::default_instance_->InitAsDefaultInstance();
  SpinnerWheel::default_instance_->InitAsDefaultInstance();
  Entity::default_instance_->InitAsDefaultInstance();
  Approval::default_instance_->InitAsDefaultInstance();
  Attack::default_instance_->InitAsDefaultInstance();
  ClientReady::default_instance_->InitAsDefaultInstance();
  ClientReady_ClientInfo::default_instance_->InitAsDefaultInstance();
  CreateBuilding::default_instance_->InitAsDefaultInstance();
  EntityList::default_instance_->InitAsDefaultInstance();
  ModuleMessage::default_instance_->InitAsDefaultInstance();
  PlayerAttack::default_instance_->InitAsDefaultInstance();
  PlayerProjectileAttack::default_instance_->InitAsDefaultInstance();
  PlayerProjectileRicochet::default_instance_->InitAsDefaultInstance();
  PlayerProjectileUpdate::default_instance_->InitAsDefaultInstance();
  PlayerUpdateLoot::default_instance_->InitAsDefaultInstance();
  ProjectileShoot::default_instance_->InitAsDefaultInstance();
  ProjectileShoot_Projectile::default_instance_->InitAsDefaultInstance();
  RespawnInformation::default_instance_->InitAsDefaultInstance();
  RespawnInformation_SpawnOptions::default_instance_->InitAsDefaultInstance();
  TakeDamage::default_instance_->InitAsDefaultInstance();
  UpdateItem::default_instance_->InitAsDefaultInstance();
  UpdateItemContainer::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_main_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_main_2eproto {
  StaticDescriptorInitializer_main_2eproto() {
    protobuf_AddDesc_main_2eproto();
  }
} static_descriptor_initializer_main_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int Vector3Serialized::kXFieldNumber;
const int Vector3Serialized::kYFieldNumber;
const int Vector3Serialized::kZFieldNumber;
#endif  // !_MSC_VER

Vector3Serialized::Vector3Serialized()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Vector3Serialized::InitAsDefaultInstance() {
}

Vector3Serialized::Vector3Serialized(const Vector3Serialized& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Vector3Serialized::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Vector3Serialized::~Vector3Serialized() {
  SharedDtor();
}

void Vector3Serialized::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Vector3Serialized::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Vector3Serialized::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Vector3Serialized_descriptor_;
}

const Vector3Serialized& Vector3Serialized::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

Vector3Serialized* Vector3Serialized::default_instance_ = NULL;

Vector3Serialized* Vector3Serialized::New() const {
  return new Vector3Serialized;
}

void Vector3Serialized::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x_ = 0;
    y_ = 0;
    z_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Vector3Serialized::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_y;
        break;
      }

      // required float y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_z;
        break;
      }

      // required float z = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Vector3Serialized::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // required float y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  // required float z = 3;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->z(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Vector3Serialized::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }

  // required float y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }

  // required float z = 3;
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->z(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Vector3Serialized::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float x = 1;
    if (has_x()) {
      total_size += 1 + 4;
    }

    // required float y = 2;
    if (has_y()) {
      total_size += 1 + 4;
    }

    // required float z = 3;
    if (has_z()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Vector3Serialized::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Vector3Serialized* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Vector3Serialized*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Vector3Serialized::MergeFrom(const Vector3Serialized& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Vector3Serialized::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Vector3Serialized::CopyFrom(const Vector3Serialized& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vector3Serialized::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void Vector3Serialized::Swap(Vector3Serialized* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(z_, other->z_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Vector3Serialized::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Vector3Serialized_descriptor_;
  metadata.reflection = Vector3Serialized_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RaySerialized::kOriginFieldNumber;
const int RaySerialized::kDirectionFieldNumber;
#endif  // !_MSC_VER

RaySerialized::RaySerialized()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RaySerialized::InitAsDefaultInstance() {
  origin_ = const_cast< ::Vector3Serialized*>(&::Vector3Serialized::default_instance());
  direction_ = const_cast< ::Vector3Serialized*>(&::Vector3Serialized::default_instance());
}

RaySerialized::RaySerialized(const RaySerialized& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RaySerialized::SharedCtor() {
  _cached_size_ = 0;
  origin_ = NULL;
  direction_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RaySerialized::~RaySerialized() {
  SharedDtor();
}

void RaySerialized::SharedDtor() {
  if (this != default_instance_) {
    delete origin_;
    delete direction_;
  }
}

void RaySerialized::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RaySerialized::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RaySerialized_descriptor_;
}

const RaySerialized& RaySerialized::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

RaySerialized* RaySerialized::default_instance_ = NULL;

RaySerialized* RaySerialized::New() const {
  return new RaySerialized;
}

void RaySerialized::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_origin()) {
      if (origin_ != NULL) origin_->::Vector3Serialized::Clear();
    }
    if (has_direction()) {
      if (direction_ != NULL) direction_->::Vector3Serialized::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RaySerialized::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Vector3Serialized origin = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_origin()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_direction;
        break;
      }

      // required .Vector3Serialized direction = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_direction:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_direction()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RaySerialized::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .Vector3Serialized origin = 1;
  if (has_origin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->origin(), output);
  }

  // required .Vector3Serialized direction = 2;
  if (has_direction()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->direction(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RaySerialized::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .Vector3Serialized origin = 1;
  if (has_origin()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->origin(), target);
  }

  // required .Vector3Serialized direction = 2;
  if (has_direction()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->direction(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RaySerialized::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Vector3Serialized origin = 1;
    if (has_origin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->origin());
    }

    // required .Vector3Serialized direction = 2;
    if (has_direction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->direction());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RaySerialized::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RaySerialized* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RaySerialized*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RaySerialized::MergeFrom(const RaySerialized& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_origin()) {
      mutable_origin()->::Vector3Serialized::MergeFrom(from.origin());
    }
    if (from.has_direction()) {
      mutable_direction()->::Vector3Serialized::MergeFrom(from.direction());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RaySerialized::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RaySerialized::CopyFrom(const RaySerialized& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RaySerialized::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_origin()) {
    if (!this->origin().IsInitialized()) return false;
  }
  if (has_direction()) {
    if (!this->direction().IsInitialized()) return false;
  }
  return true;
}

void RaySerialized::Swap(RaySerialized* other) {
  if (other != this) {
    std::swap(origin_, other->origin_);
    std::swap(direction_, other->direction_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RaySerialized::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RaySerialized_descriptor_;
  metadata.reflection = RaySerialized_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BaseNetworkable::kUidFieldNumber;
const int BaseNetworkable::kGroupFieldNumber;
const int BaseNetworkable::kPrefabIDFieldNumber;
#endif  // !_MSC_VER

BaseNetworkable::BaseNetworkable()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void BaseNetworkable::InitAsDefaultInstance() {
}

BaseNetworkable::BaseNetworkable(const BaseNetworkable& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void BaseNetworkable::SharedCtor() {
  _cached_size_ = 0;
  uid_ = 0u;
  group_ = 0u;
  prefabid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BaseNetworkable::~BaseNetworkable() {
  SharedDtor();
}

void BaseNetworkable::SharedDtor() {
  if (this != default_instance_) {
  }
}

void BaseNetworkable::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BaseNetworkable::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BaseNetworkable_descriptor_;
}

const BaseNetworkable& BaseNetworkable::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

BaseNetworkable* BaseNetworkable::default_instance_ = NULL;

BaseNetworkable* BaseNetworkable::New() const {
  return new BaseNetworkable;
}

void BaseNetworkable::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    uid_ = 0u;
    group_ = 0u;
    prefabid_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BaseNetworkable::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 uid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uid_)));
          set_has_uid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_group;
        break;
      }

      // required uint32 group = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_group:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_)));
          set_has_group();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_prefabID;
        break;
      }

      // required uint32 prefabID = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_prefabID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &prefabid_)));
          set_has_prefabid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BaseNetworkable::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 uid = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->uid(), output);
  }

  // required uint32 group = 2;
  if (has_group()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->group(), output);
  }

  // required uint32 prefabID = 3;
  if (has_prefabid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->prefabid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* BaseNetworkable::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 uid = 1;
  if (has_uid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->uid(), target);
  }

  // required uint32 group = 2;
  if (has_group()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->group(), target);
  }

  // required uint32 prefabID = 3;
  if (has_prefabid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->prefabid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int BaseNetworkable::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 uid = 1;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uid());
    }

    // required uint32 group = 2;
    if (has_group()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->group());
    }

    // required uint32 prefabID = 3;
    if (has_prefabid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->prefabid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BaseNetworkable::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BaseNetworkable* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BaseNetworkable*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BaseNetworkable::MergeFrom(const BaseNetworkable& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      set_uid(from.uid());
    }
    if (from.has_group()) {
      set_group(from.group());
    }
    if (from.has_prefabid()) {
      set_prefabid(from.prefabid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BaseNetworkable::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BaseNetworkable::CopyFrom(const BaseNetworkable& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BaseNetworkable::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void BaseNetworkable::Swap(BaseNetworkable* other) {
  if (other != this) {
    std::swap(uid_, other->uid_);
    std::swap(group_, other->group_);
    std::swap(prefabid_, other->prefabid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BaseNetworkable::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BaseNetworkable_descriptor_;
  metadata.reflection = BaseNetworkable_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BaseEntity::kPosFieldNumber;
const int BaseEntity::kRotFieldNumber;
const int BaseEntity::kFlagsFieldNumber;
const int BaseEntity::kSkinidFieldNumber;
#endif  // !_MSC_VER

BaseEntity::BaseEntity()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void BaseEntity::InitAsDefaultInstance() {
  pos_ = const_cast< ::Vector3Serialized*>(&::Vector3Serialized::default_instance());
  rot_ = const_cast< ::Vector3Serialized*>(&::Vector3Serialized::default_instance());
}

BaseEntity::BaseEntity(const BaseEntity& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void BaseEntity::SharedCtor() {
  _cached_size_ = 0;
  pos_ = NULL;
  rot_ = NULL;
  flags_ = GOOGLE_ULONGLONG(0);
  skinid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BaseEntity::~BaseEntity() {
  SharedDtor();
}

void BaseEntity::SharedDtor() {
  if (this != default_instance_) {
    delete pos_;
    delete rot_;
  }
}

void BaseEntity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BaseEntity::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BaseEntity_descriptor_;
}

const BaseEntity& BaseEntity::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

BaseEntity* BaseEntity::default_instance_ = NULL;

BaseEntity* BaseEntity::New() const {
  return new BaseEntity;
}

void BaseEntity::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_pos()) {
      if (pos_ != NULL) pos_->::Vector3Serialized::Clear();
    }
    if (has_rot()) {
      if (rot_ != NULL) rot_->::Vector3Serialized::Clear();
    }
    flags_ = GOOGLE_ULONGLONG(0);
    skinid_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BaseEntity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Vector3Serialized pos = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pos()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_rot;
        break;
      }

      // required .Vector3Serialized rot = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_rot:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_rot()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_flags;
        break;
      }

      // required uint64 flags = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_flags:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &flags_)));
          set_has_flags();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_skinid;
        break;
      }

      // optional uint64 skinid = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_skinid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &skinid_)));
          set_has_skinid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BaseEntity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .Vector3Serialized pos = 1;
  if (has_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->pos(), output);
  }

  // required .Vector3Serialized rot = 2;
  if (has_rot()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->rot(), output);
  }

  // required uint64 flags = 3;
  if (has_flags()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->flags(), output);
  }

  // optional uint64 skinid = 4;
  if (has_skinid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->skinid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* BaseEntity::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .Vector3Serialized pos = 1;
  if (has_pos()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->pos(), target);
  }

  // required .Vector3Serialized rot = 2;
  if (has_rot()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->rot(), target);
  }

  // required uint64 flags = 3;
  if (has_flags()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->flags(), target);
  }

  // optional uint64 skinid = 4;
  if (has_skinid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->skinid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int BaseEntity::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Vector3Serialized pos = 1;
    if (has_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->pos());
    }

    // required .Vector3Serialized rot = 2;
    if (has_rot()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->rot());
    }

    // required uint64 flags = 3;
    if (has_flags()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->flags());
    }

    // optional uint64 skinid = 4;
    if (has_skinid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->skinid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BaseEntity::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BaseEntity* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BaseEntity*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BaseEntity::MergeFrom(const BaseEntity& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pos()) {
      mutable_pos()->::Vector3Serialized::MergeFrom(from.pos());
    }
    if (from.has_rot()) {
      mutable_rot()->::Vector3Serialized::MergeFrom(from.rot());
    }
    if (from.has_flags()) {
      set_flags(from.flags());
    }
    if (from.has_skinid()) {
      set_skinid(from.skinid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BaseEntity::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BaseEntity::CopyFrom(const BaseEntity& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BaseEntity::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_pos()) {
    if (!this->pos().IsInitialized()) return false;
  }
  if (has_rot()) {
    if (!this->rot().IsInitialized()) return false;
  }
  return true;
}

void BaseEntity::Swap(BaseEntity* other) {
  if (other != this) {
    std::swap(pos_, other->pos_);
    std::swap(rot_, other->rot_);
    std::swap(flags_, other->flags_);
    std::swap(skinid_, other->skinid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BaseEntity::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BaseEntity_descriptor_;
  metadata.reflection = BaseEntity_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Item_InstanceData::kDataIntFieldNumber;
const int Item_InstanceData::kBlueprintTargetFieldNumber;
const int Item_InstanceData::kBlueprintAmountFieldNumber;
#endif  // !_MSC_VER

Item_InstanceData::Item_InstanceData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Item_InstanceData::InitAsDefaultInstance() {
}

Item_InstanceData::Item_InstanceData(const Item_InstanceData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Item_InstanceData::SharedCtor() {
  _cached_size_ = 0;
  dataint_ = GOOGLE_ULONGLONG(0);
  blueprinttarget_ = GOOGLE_ULONGLONG(0);
  blueprintamount_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Item_InstanceData::~Item_InstanceData() {
  SharedDtor();
}

void Item_InstanceData::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Item_InstanceData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Item_InstanceData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Item_InstanceData_descriptor_;
}

const Item_InstanceData& Item_InstanceData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

Item_InstanceData* Item_InstanceData::default_instance_ = NULL;

Item_InstanceData* Item_InstanceData::New() const {
  return new Item_InstanceData;
}

void Item_InstanceData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    dataint_ = GOOGLE_ULONGLONG(0);
    blueprinttarget_ = GOOGLE_ULONGLONG(0);
    blueprintamount_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Item_InstanceData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 dataInt = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dataint_)));
          set_has_dataint();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_blueprintTarget;
        break;
      }

      // required uint64 blueprintTarget = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_blueprintTarget:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &blueprinttarget_)));
          set_has_blueprinttarget();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_blueprintAmount;
        break;
      }

      // required uint64 blueprintAmount = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_blueprintAmount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &blueprintamount_)));
          set_has_blueprintamount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Item_InstanceData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 dataInt = 1;
  if (has_dataint()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->dataint(), output);
  }

  // required uint64 blueprintTarget = 2;
  if (has_blueprinttarget()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->blueprinttarget(), output);
  }

  // required uint64 blueprintAmount = 3;
  if (has_blueprintamount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->blueprintamount(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Item_InstanceData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 dataInt = 1;
  if (has_dataint()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->dataint(), target);
  }

  // required uint64 blueprintTarget = 2;
  if (has_blueprinttarget()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->blueprinttarget(), target);
  }

  // required uint64 blueprintAmount = 3;
  if (has_blueprintamount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->blueprintamount(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Item_InstanceData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 dataInt = 1;
    if (has_dataint()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->dataint());
    }

    // required uint64 blueprintTarget = 2;
    if (has_blueprinttarget()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->blueprinttarget());
    }

    // required uint64 blueprintAmount = 3;
    if (has_blueprintamount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->blueprintamount());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Item_InstanceData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Item_InstanceData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Item_InstanceData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Item_InstanceData::MergeFrom(const Item_InstanceData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_dataint()) {
      set_dataint(from.dataint());
    }
    if (from.has_blueprinttarget()) {
      set_blueprinttarget(from.blueprinttarget());
    }
    if (from.has_blueprintamount()) {
      set_blueprintamount(from.blueprintamount());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Item_InstanceData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Item_InstanceData::CopyFrom(const Item_InstanceData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Item_InstanceData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void Item_InstanceData::Swap(Item_InstanceData* other) {
  if (other != this) {
    std::swap(dataint_, other->dataint_);
    std::swap(blueprinttarget_, other->blueprinttarget_);
    std::swap(blueprintamount_, other->blueprintamount_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Item_InstanceData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Item_InstanceData_descriptor_;
  metadata.reflection = Item_InstanceData_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Item_ConditionData::kConditionFieldNumber;
const int Item_ConditionData::kMaxConditionFieldNumber;
#endif  // !_MSC_VER

Item_ConditionData::Item_ConditionData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Item_ConditionData::InitAsDefaultInstance() {
}

Item_ConditionData::Item_ConditionData(const Item_ConditionData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Item_ConditionData::SharedCtor() {
  _cached_size_ = 0;
  condition_ = 0;
  maxcondition_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Item_ConditionData::~Item_ConditionData() {
  SharedDtor();
}

void Item_ConditionData::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Item_ConditionData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Item_ConditionData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Item_ConditionData_descriptor_;
}

const Item_ConditionData& Item_ConditionData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

Item_ConditionData* Item_ConditionData::default_instance_ = NULL;

Item_ConditionData* Item_ConditionData::New() const {
  return new Item_ConditionData;
}

void Item_ConditionData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    condition_ = 0;
    maxcondition_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Item_ConditionData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float condition = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &condition_)));
          set_has_condition();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_maxCondition;
        break;
      }

      // required float maxCondition = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_maxCondition:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &maxcondition_)));
          set_has_maxcondition();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Item_ConditionData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float condition = 1;
  if (has_condition()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->condition(), output);
  }

  // required float maxCondition = 2;
  if (has_maxcondition()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->maxcondition(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Item_ConditionData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float condition = 1;
  if (has_condition()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->condition(), target);
  }

  // required float maxCondition = 2;
  if (has_maxcondition()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->maxcondition(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Item_ConditionData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float condition = 1;
    if (has_condition()) {
      total_size += 1 + 4;
    }

    // required float maxCondition = 2;
    if (has_maxcondition()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Item_ConditionData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Item_ConditionData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Item_ConditionData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Item_ConditionData::MergeFrom(const Item_ConditionData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_condition()) {
      set_condition(from.condition());
    }
    if (from.has_maxcondition()) {
      set_maxcondition(from.maxcondition());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Item_ConditionData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Item_ConditionData::CopyFrom(const Item_ConditionData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Item_ConditionData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Item_ConditionData::Swap(Item_ConditionData* other) {
  if (other != this) {
    std::swap(condition_, other->condition_);
    std::swap(maxcondition_, other->maxcondition_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Item_ConditionData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Item_ConditionData_descriptor_;
  metadata.reflection = Item_ConditionData_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Item::kUIDFieldNumber;
const int Item::kItemidFieldNumber;
const int Item::kSlotFieldNumber;
const int Item::kAmountFieldNumber;
const int Item::kFlagsFieldNumber;
const int Item::kRemovetimeFieldNumber;
const int Item::kLocktimeFieldNumber;
const int Item::kWorldEntityFieldNumber;
const int Item::kInstanceDataFieldNumber;
const int Item::kHeldEntityFieldNumber;
const int Item::kConditionDataFieldNumber;
const int Item::kNameFieldNumber;
const int Item::kTextFieldNumber;
const int Item::kSkinidFieldNumber;
const int Item::kContentsFieldNumber;
#endif  // !_MSC_VER

Item::Item()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Item::InitAsDefaultInstance() {
  instancedata_ = const_cast< ::Item_InstanceData*>(&::Item_InstanceData::default_instance());
  conditiondata_ = const_cast< ::Item_ConditionData*>(&::Item_ConditionData::default_instance());
  contents_ = const_cast< ::ItemContainer*>(&::ItemContainer::default_instance());
}

Item::Item(const Item& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Item::SharedCtor() {
  _cached_size_ = 0;
  uid_ = 0u;
  itemid_ = GOOGLE_ULONGLONG(0);
  slot_ = GOOGLE_ULONGLONG(0);
  amount_ = GOOGLE_ULONGLONG(0);
  flags_ = GOOGLE_ULONGLONG(0);
  removetime_ = 0;
  locktime_ = 0;
  worldentity_ = 0u;
  instancedata_ = NULL;
  heldentity_ = 0u;
  conditiondata_ = NULL;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  skinid_ = GOOGLE_ULONGLONG(0);
  contents_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Item::~Item() {
  SharedDtor();
}

void Item::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (this != default_instance_) {
    delete instancedata_;
    delete conditiondata_;
    delete contents_;
  }
}

void Item::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Item::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Item_descriptor_;
}

const Item& Item::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

Item* Item::default_instance_ = NULL;

Item* Item::New() const {
  return new Item;
}

void Item::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    uid_ = 0u;
    itemid_ = GOOGLE_ULONGLONG(0);
    slot_ = GOOGLE_ULONGLONG(0);
    amount_ = GOOGLE_ULONGLONG(0);
    flags_ = GOOGLE_ULONGLONG(0);
    removetime_ = 0;
    locktime_ = 0;
    worldentity_ = 0u;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_instancedata()) {
      if (instancedata_ != NULL) instancedata_->::Item_InstanceData::Clear();
    }
    heldentity_ = 0u;
    if (has_conditiondata()) {
      if (conditiondata_ != NULL) conditiondata_->::Item_ConditionData::Clear();
    }
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_text()) {
      if (text_ != &::google::protobuf::internal::kEmptyString) {
        text_->clear();
      }
    }
    skinid_ = GOOGLE_ULONGLONG(0);
    if (has_contents()) {
      if (contents_ != NULL) contents_->::ItemContainer::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Item::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 UID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uid_)));
          set_has_uid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_itemid;
        break;
      }

      // required uint64 itemid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_itemid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_slot;
        break;
      }

      // required uint64 slot = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_slot:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &slot_)));
          set_has_slot();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_amount;
        break;
      }

      // required uint64 amount = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_amount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &amount_)));
          set_has_amount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_flags;
        break;
      }

      // required uint64 flags = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_flags:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &flags_)));
          set_has_flags();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_removetime;
        break;
      }

      // required float removetime = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_removetime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &removetime_)));
          set_has_removetime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(61)) goto parse_locktime;
        break;
      }

      // required float locktime = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_locktime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &locktime_)));
          set_has_locktime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_worldEntity;
        break;
      }

      // required uint32 worldEntity = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_worldEntity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &worldentity_)));
          set_has_worldentity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_instanceData;
        break;
      }

      // optional .Item.InstanceData instanceData = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_instanceData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_instancedata()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_heldEntity;
        break;
      }

      // required uint32 heldEntity = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_heldEntity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &heldentity_)));
          set_has_heldentity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_conditionData;
        break;
      }

      // optional .Item.ConditionData conditionData = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_conditionData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_conditiondata()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(114)) goto parse_name;
        break;
      }

      // optional string name = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_text;
        break;
      }

      // optional string text = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_text:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_text()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->text().data(), this->text().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(128)) goto parse_skinid;
        break;
      }

      // required uint64 skinid = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_skinid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &skinid_)));
          set_has_skinid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(802)) goto parse_contents;
        break;
      }

      // optional .ItemContainer contents = 100;
      case 100: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_contents:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_contents()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Item::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 UID = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->uid(), output);
  }

  // required uint64 itemid = 2;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->itemid(), output);
  }

  // required uint64 slot = 3;
  if (has_slot()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->slot(), output);
  }

  // required uint64 amount = 4;
  if (has_amount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->amount(), output);
  }

  // required uint64 flags = 5;
  if (has_flags()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->flags(), output);
  }

  // required float removetime = 6;
  if (has_removetime()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->removetime(), output);
  }

  // required float locktime = 7;
  if (has_locktime()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->locktime(), output);
  }

  // required uint32 worldEntity = 8;
  if (has_worldentity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->worldentity(), output);
  }

  // optional .Item.InstanceData instanceData = 9;
  if (has_instancedata()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->instancedata(), output);
  }

  // required uint32 heldEntity = 10;
  if (has_heldentity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->heldentity(), output);
  }

  // optional .Item.ConditionData conditionData = 11;
  if (has_conditiondata()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, this->conditiondata(), output);
  }

  // optional string name = 14;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      14, this->name(), output);
  }

  // optional string text = 15;
  if (has_text()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      15, this->text(), output);
  }

  // required uint64 skinid = 16;
  if (has_skinid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(16, this->skinid(), output);
  }

  // optional .ItemContainer contents = 100;
  if (has_contents()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      100, this->contents(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Item::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 UID = 1;
  if (has_uid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->uid(), target);
  }

  // required uint64 itemid = 2;
  if (has_itemid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->itemid(), target);
  }

  // required uint64 slot = 3;
  if (has_slot()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->slot(), target);
  }

  // required uint64 amount = 4;
  if (has_amount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->amount(), target);
  }

  // required uint64 flags = 5;
  if (has_flags()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(5, this->flags(), target);
  }

  // required float removetime = 6;
  if (has_removetime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->removetime(), target);
  }

  // required float locktime = 7;
  if (has_locktime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->locktime(), target);
  }

  // required uint32 worldEntity = 8;
  if (has_worldentity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->worldentity(), target);
  }

  // optional .Item.InstanceData instanceData = 9;
  if (has_instancedata()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->instancedata(), target);
  }

  // required uint32 heldEntity = 10;
  if (has_heldentity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->heldentity(), target);
  }

  // optional .Item.ConditionData conditionData = 11;
  if (has_conditiondata()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, this->conditiondata(), target);
  }

  // optional string name = 14;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        14, this->name(), target);
  }

  // optional string text = 15;
  if (has_text()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        15, this->text(), target);
  }

  // required uint64 skinid = 16;
  if (has_skinid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(16, this->skinid(), target);
  }

  // optional .ItemContainer contents = 100;
  if (has_contents()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        100, this->contents(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Item::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 UID = 1;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uid());
    }

    // required uint64 itemid = 2;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->itemid());
    }

    // required uint64 slot = 3;
    if (has_slot()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->slot());
    }

    // required uint64 amount = 4;
    if (has_amount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->amount());
    }

    // required uint64 flags = 5;
    if (has_flags()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->flags());
    }

    // required float removetime = 6;
    if (has_removetime()) {
      total_size += 1 + 4;
    }

    // required float locktime = 7;
    if (has_locktime()) {
      total_size += 1 + 4;
    }

    // required uint32 worldEntity = 8;
    if (has_worldentity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->worldentity());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .Item.InstanceData instanceData = 9;
    if (has_instancedata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->instancedata());
    }

    // required uint32 heldEntity = 10;
    if (has_heldentity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->heldentity());
    }

    // optional .Item.ConditionData conditionData = 11;
    if (has_conditiondata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->conditiondata());
    }

    // optional string name = 14;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string text = 15;
    if (has_text()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->text());
    }

    // required uint64 skinid = 16;
    if (has_skinid()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->skinid());
    }

    // optional .ItemContainer contents = 100;
    if (has_contents()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->contents());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Item::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Item* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Item*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Item::MergeFrom(const Item& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      set_uid(from.uid());
    }
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
    if (from.has_slot()) {
      set_slot(from.slot());
    }
    if (from.has_amount()) {
      set_amount(from.amount());
    }
    if (from.has_flags()) {
      set_flags(from.flags());
    }
    if (from.has_removetime()) {
      set_removetime(from.removetime());
    }
    if (from.has_locktime()) {
      set_locktime(from.locktime());
    }
    if (from.has_worldentity()) {
      set_worldentity(from.worldentity());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_instancedata()) {
      mutable_instancedata()->::Item_InstanceData::MergeFrom(from.instancedata());
    }
    if (from.has_heldentity()) {
      set_heldentity(from.heldentity());
    }
    if (from.has_conditiondata()) {
      mutable_conditiondata()->::Item_ConditionData::MergeFrom(from.conditiondata());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_text()) {
      set_text(from.text());
    }
    if (from.has_skinid()) {
      set_skinid(from.skinid());
    }
    if (from.has_contents()) {
      mutable_contents()->::ItemContainer::MergeFrom(from.contents());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Item::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Item::CopyFrom(const Item& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Item::IsInitialized() const {
  if ((_has_bits_[0] & 0x000022ff) != 0x000022ff) return false;

  if (has_instancedata()) {
    if (!this->instancedata().IsInitialized()) return false;
  }
  if (has_conditiondata()) {
    if (!this->conditiondata().IsInitialized()) return false;
  }
  if (has_contents()) {
    if (!this->contents().IsInitialized()) return false;
  }
  return true;
}

void Item::Swap(Item* other) {
  if (other != this) {
    std::swap(uid_, other->uid_);
    std::swap(itemid_, other->itemid_);
    std::swap(slot_, other->slot_);
    std::swap(amount_, other->amount_);
    std::swap(flags_, other->flags_);
    std::swap(removetime_, other->removetime_);
    std::swap(locktime_, other->locktime_);
    std::swap(worldentity_, other->worldentity_);
    std::swap(instancedata_, other->instancedata_);
    std::swap(heldentity_, other->heldentity_);
    std::swap(conditiondata_, other->conditiondata_);
    std::swap(name_, other->name_);
    std::swap(text_, other->text_);
    std::swap(skinid_, other->skinid_);
    std::swap(contents_, other->contents_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Item::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Item_descriptor_;
  metadata.reflection = Item_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ItemContainer::kUIDFieldNumber;
const int ItemContainer::kSlotsFieldNumber;
const int ItemContainer::kTemperatureFieldNumber;
const int ItemContainer::kFlagsFieldNumber;
const int ItemContainer::kAllowedContentsFieldNumber;
const int ItemContainer::kMaxStackSizeFieldNumber;
const int ItemContainer::kAllowedItemFieldNumber;
const int ItemContainer::kAvailableSlotsFieldNumber;
const int ItemContainer::kContentsFieldNumber;
#endif  // !_MSC_VER

ItemContainer::ItemContainer()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ItemContainer::InitAsDefaultInstance() {
}

ItemContainer::ItemContainer(const ItemContainer& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ItemContainer::SharedCtor() {
  _cached_size_ = 0;
  uid_ = 0u;
  slots_ = GOOGLE_ULONGLONG(0);
  temperature_ = 0;
  flags_ = GOOGLE_ULONGLONG(0);
  allowedcontents_ = GOOGLE_ULONGLONG(0);
  maxstacksize_ = GOOGLE_ULONGLONG(0);
  alloweditem_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ItemContainer::~ItemContainer() {
  SharedDtor();
}

void ItemContainer::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ItemContainer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ItemContainer::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ItemContainer_descriptor_;
}

const ItemContainer& ItemContainer::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

ItemContainer* ItemContainer::default_instance_ = NULL;

ItemContainer* ItemContainer::New() const {
  return new ItemContainer;
}

void ItemContainer::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    uid_ = 0u;
    slots_ = GOOGLE_ULONGLONG(0);
    temperature_ = 0;
    flags_ = GOOGLE_ULONGLONG(0);
    allowedcontents_ = GOOGLE_ULONGLONG(0);
    maxstacksize_ = GOOGLE_ULONGLONG(0);
    alloweditem_ = GOOGLE_ULONGLONG(0);
  }
  availableslots_.Clear();
  contents_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ItemContainer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 UID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uid_)));
          set_has_uid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_slots;
        break;
      }

      // required uint64 slots = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_slots:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &slots_)));
          set_has_slots();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_temperature;
        break;
      }

      // required float temperature = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_temperature:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &temperature_)));
          set_has_temperature();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_flags;
        break;
      }

      // required uint64 flags = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_flags:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &flags_)));
          set_has_flags();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_allowedContents;
        break;
      }

      // required uint64 allowedContents = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_allowedContents:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &allowedcontents_)));
          set_has_allowedcontents();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_maxStackSize;
        break;
      }

      // required uint64 maxStackSize = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_maxStackSize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &maxstacksize_)));
          set_has_maxstacksize();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_allowedItem;
        break;
      }

      // required uint64 allowedItem = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_allowedItem:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &alloweditem_)));
          set_has_alloweditem();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_availableSlots;
        break;
      }

      // repeated uint64 availableSlots = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_availableSlots:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 64, input, this->mutable_availableslots())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_availableslots())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_availableSlots;
        if (input->ExpectTag(802)) goto parse_contents;
        break;
      }

      // repeated .Item contents = 100;
      case 100: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_contents:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_contents()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(802)) goto parse_contents;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ItemContainer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 UID = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->uid(), output);
  }

  // required uint64 slots = 2;
  if (has_slots()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->slots(), output);
  }

  // required float temperature = 3;
  if (has_temperature()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->temperature(), output);
  }

  // required uint64 flags = 4;
  if (has_flags()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->flags(), output);
  }

  // required uint64 allowedContents = 5;
  if (has_allowedcontents()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->allowedcontents(), output);
  }

  // required uint64 maxStackSize = 6;
  if (has_maxstacksize()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->maxstacksize(), output);
  }

  // required uint64 allowedItem = 7;
  if (has_alloweditem()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(7, this->alloweditem(), output);
  }

  // repeated uint64 availableSlots = 8;
  for (int i = 0; i < this->availableslots_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(
      8, this->availableslots(i), output);
  }

  // repeated .Item contents = 100;
  for (int i = 0; i < this->contents_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      100, this->contents(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ItemContainer::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 UID = 1;
  if (has_uid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->uid(), target);
  }

  // required uint64 slots = 2;
  if (has_slots()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->slots(), target);
  }

  // required float temperature = 3;
  if (has_temperature()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->temperature(), target);
  }

  // required uint64 flags = 4;
  if (has_flags()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->flags(), target);
  }

  // required uint64 allowedContents = 5;
  if (has_allowedcontents()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(5, this->allowedcontents(), target);
  }

  // required uint64 maxStackSize = 6;
  if (has_maxstacksize()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->maxstacksize(), target);
  }

  // required uint64 allowedItem = 7;
  if (has_alloweditem()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(7, this->alloweditem(), target);
  }

  // repeated uint64 availableSlots = 8;
  for (int i = 0; i < this->availableslots_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt64ToArray(8, this->availableslots(i), target);
  }

  // repeated .Item contents = 100;
  for (int i = 0; i < this->contents_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        100, this->contents(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ItemContainer::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 UID = 1;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uid());
    }

    // required uint64 slots = 2;
    if (has_slots()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->slots());
    }

    // required float temperature = 3;
    if (has_temperature()) {
      total_size += 1 + 4;
    }

    // required uint64 flags = 4;
    if (has_flags()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->flags());
    }

    // required uint64 allowedContents = 5;
    if (has_allowedcontents()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->allowedcontents());
    }

    // required uint64 maxStackSize = 6;
    if (has_maxstacksize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->maxstacksize());
    }

    // required uint64 allowedItem = 7;
    if (has_alloweditem()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->alloweditem());
    }

  }
  // repeated uint64 availableSlots = 8;
  {
    int data_size = 0;
    for (int i = 0; i < this->availableslots_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt64Size(this->availableslots(i));
    }
    total_size += 1 * this->availableslots_size() + data_size;
  }

  // repeated .Item contents = 100;
  total_size += 2 * this->contents_size();
  for (int i = 0; i < this->contents_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->contents(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ItemContainer::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ItemContainer* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ItemContainer*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ItemContainer::MergeFrom(const ItemContainer& from) {
  GOOGLE_CHECK_NE(&from, this);
  availableslots_.MergeFrom(from.availableslots_);
  contents_.MergeFrom(from.contents_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      set_uid(from.uid());
    }
    if (from.has_slots()) {
      set_slots(from.slots());
    }
    if (from.has_temperature()) {
      set_temperature(from.temperature());
    }
    if (from.has_flags()) {
      set_flags(from.flags());
    }
    if (from.has_allowedcontents()) {
      set_allowedcontents(from.allowedcontents());
    }
    if (from.has_maxstacksize()) {
      set_maxstacksize(from.maxstacksize());
    }
    if (from.has_alloweditem()) {
      set_alloweditem(from.alloweditem());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ItemContainer::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ItemContainer::CopyFrom(const ItemContainer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ItemContainer::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;

  for (int i = 0; i < contents_size(); i++) {
    if (!this->contents(i).IsInitialized()) return false;
  }
  return true;
}

void ItemContainer::Swap(ItemContainer* other) {
  if (other != this) {
    std::swap(uid_, other->uid_);
    std::swap(slots_, other->slots_);
    std::swap(temperature_, other->temperature_);
    std::swap(flags_, other->flags_);
    std::swap(allowedcontents_, other->allowedcontents_);
    std::swap(maxstacksize_, other->maxstacksize_);
    std::swap(alloweditem_, other->alloweditem_);
    availableslots_.Swap(&other->availableslots_);
    contents_.Swap(&other->contents_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ItemContainer::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ItemContainer_descriptor_;
  metadata.reflection = ItemContainer_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PlayerInventory::kInvMainFieldNumber;
const int PlayerInventory::kInvBeltFieldNumber;
const int PlayerInventory::kInvWearFieldNumber;
#endif  // !_MSC_VER

PlayerInventory::PlayerInventory()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PlayerInventory::InitAsDefaultInstance() {
  invmain_ = const_cast< ::ItemContainer*>(&::ItemContainer::default_instance());
  invbelt_ = const_cast< ::ItemContainer*>(&::ItemContainer::default_instance());
  invwear_ = const_cast< ::ItemContainer*>(&::ItemContainer::default_instance());
}

PlayerInventory::PlayerInventory(const PlayerInventory& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PlayerInventory::SharedCtor() {
  _cached_size_ = 0;
  invmain_ = NULL;
  invbelt_ = NULL;
  invwear_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlayerInventory::~PlayerInventory() {
  SharedDtor();
}

void PlayerInventory::SharedDtor() {
  if (this != default_instance_) {
    delete invmain_;
    delete invbelt_;
    delete invwear_;
  }
}

void PlayerInventory::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PlayerInventory::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PlayerInventory_descriptor_;
}

const PlayerInventory& PlayerInventory::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

PlayerInventory* PlayerInventory::default_instance_ = NULL;

PlayerInventory* PlayerInventory::New() const {
  return new PlayerInventory;
}

void PlayerInventory::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_invmain()) {
      if (invmain_ != NULL) invmain_->::ItemContainer::Clear();
    }
    if (has_invbelt()) {
      if (invbelt_ != NULL) invbelt_->::ItemContainer::Clear();
    }
    if (has_invwear()) {
      if (invwear_ != NULL) invwear_->::ItemContainer::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PlayerInventory::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ItemContainer invMain = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_invmain()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_invBelt;
        break;
      }

      // optional .ItemContainer invBelt = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_invBelt:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_invbelt()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_invWear;
        break;
      }

      // optional .ItemContainer invWear = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_invWear:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_invwear()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PlayerInventory::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .ItemContainer invMain = 1;
  if (has_invmain()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->invmain(), output);
  }

  // optional .ItemContainer invBelt = 2;
  if (has_invbelt()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->invbelt(), output);
  }

  // optional .ItemContainer invWear = 4;
  if (has_invwear()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->invwear(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PlayerInventory::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .ItemContainer invMain = 1;
  if (has_invmain()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->invmain(), target);
  }

  // optional .ItemContainer invBelt = 2;
  if (has_invbelt()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->invbelt(), target);
  }

  // optional .ItemContainer invWear = 4;
  if (has_invwear()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->invwear(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PlayerInventory::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ItemContainer invMain = 1;
    if (has_invmain()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->invmain());
    }

    // optional .ItemContainer invBelt = 2;
    if (has_invbelt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->invbelt());
    }

    // optional .ItemContainer invWear = 4;
    if (has_invwear()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->invwear());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlayerInventory::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PlayerInventory* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PlayerInventory*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PlayerInventory::MergeFrom(const PlayerInventory& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_invmain()) {
      mutable_invmain()->::ItemContainer::MergeFrom(from.invmain());
    }
    if (from.has_invbelt()) {
      mutable_invbelt()->::ItemContainer::MergeFrom(from.invbelt());
    }
    if (from.has_invwear()) {
      mutable_invwear()->::ItemContainer::MergeFrom(from.invwear());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PlayerInventory::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PlayerInventory::CopyFrom(const PlayerInventory& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerInventory::IsInitialized() const {

  if (has_invmain()) {
    if (!this->invmain().IsInitialized()) return false;
  }
  if (has_invbelt()) {
    if (!this->invbelt().IsInitialized()) return false;
  }
  if (has_invwear()) {
    if (!this->invwear().IsInitialized()) return false;
  }
  return true;
}

void PlayerInventory::Swap(PlayerInventory* other) {
  if (other != this) {
    std::swap(invmain_, other->invmain_);
    std::swap(invbelt_, other->invbelt_);
    std::swap(invwear_, other->invwear_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PlayerInventory::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PlayerInventory_descriptor_;
  metadata.reflection = PlayerInventory_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PlayerMetabolism::kHealthFieldNumber;
const int PlayerMetabolism::kCaloriesFieldNumber;
const int PlayerMetabolism::kHydrationFieldNumber;
const int PlayerMetabolism::kHeartrateFieldNumber;
const int PlayerMetabolism::kTemperatureFieldNumber;
const int PlayerMetabolism::kPoisonFieldNumber;
const int PlayerMetabolism::kRadiationLevelFieldNumber;
const int PlayerMetabolism::kWetnessFieldNumber;
const int PlayerMetabolism::kDirtynessFieldNumber;
const int PlayerMetabolism::kOxygenFieldNumber;
const int PlayerMetabolism::kBleedingFieldNumber;
const int PlayerMetabolism::kRadiationPoisoningFieldNumber;
const int PlayerMetabolism::kComfortFieldNumber;
const int PlayerMetabolism::kPendingHealthFieldNumber;
#endif  // !_MSC_VER

PlayerMetabolism::PlayerMetabolism()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PlayerMetabolism::InitAsDefaultInstance() {
}

PlayerMetabolism::PlayerMetabolism(const PlayerMetabolism& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PlayerMetabolism::SharedCtor() {
  _cached_size_ = 0;
  health_ = 0;
  calories_ = 0;
  hydration_ = 0;
  heartrate_ = 0;
  temperature_ = 0;
  poison_ = 0;
  radiation_level_ = 0;
  wetness_ = 0;
  dirtyness_ = 0;
  oxygen_ = 0;
  bleeding_ = 0;
  radiation_poisoning_ = 0;
  comfort_ = 0;
  pending_health_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlayerMetabolism::~PlayerMetabolism() {
  SharedDtor();
}

void PlayerMetabolism::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PlayerMetabolism::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PlayerMetabolism::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PlayerMetabolism_descriptor_;
}

const PlayerMetabolism& PlayerMetabolism::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

PlayerMetabolism* PlayerMetabolism::default_instance_ = NULL;

PlayerMetabolism* PlayerMetabolism::New() const {
  return new PlayerMetabolism;
}

void PlayerMetabolism::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    health_ = 0;
    calories_ = 0;
    hydration_ = 0;
    heartrate_ = 0;
    temperature_ = 0;
    poison_ = 0;
    radiation_level_ = 0;
    wetness_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    dirtyness_ = 0;
    oxygen_ = 0;
    bleeding_ = 0;
    radiation_poisoning_ = 0;
    comfort_ = 0;
    pending_health_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PlayerMetabolism::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float health = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &health_)));
          set_has_health();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_calories;
        break;
      }

      // required float calories = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_calories:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &calories_)));
          set_has_calories();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_hydration;
        break;
      }

      // required float hydration = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_hydration:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &hydration_)));
          set_has_hydration();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_heartrate;
        break;
      }

      // required float heartrate = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_heartrate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &heartrate_)));
          set_has_heartrate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_temperature;
        break;
      }

      // required float temperature = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_temperature:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &temperature_)));
          set_has_temperature();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_poison;
        break;
      }

      // required float poison = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_poison:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &poison_)));
          set_has_poison();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(61)) goto parse_radiation_level;
        break;
      }

      // required float radiation_level = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_radiation_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &radiation_level_)));
          set_has_radiation_level();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(69)) goto parse_wetness;
        break;
      }

      // required float wetness = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_wetness:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &wetness_)));
          set_has_wetness();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(77)) goto parse_dirtyness;
        break;
      }

      // required float dirtyness = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_dirtyness:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &dirtyness_)));
          set_has_dirtyness();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(85)) goto parse_oxygen;
        break;
      }

      // required float oxygen = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_oxygen:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &oxygen_)));
          set_has_oxygen();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(93)) goto parse_bleeding;
        break;
      }

      // required float bleeding = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_bleeding:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &bleeding_)));
          set_has_bleeding();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(101)) goto parse_radiation_poisoning;
        break;
      }

      // required float radiation_poisoning = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_radiation_poisoning:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &radiation_poisoning_)));
          set_has_radiation_poisoning();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(109)) goto parse_comfort;
        break;
      }

      // required float comfort = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_comfort:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &comfort_)));
          set_has_comfort();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(117)) goto parse_pending_health;
        break;
      }

      // required float pending_health = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_pending_health:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &pending_health_)));
          set_has_pending_health();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PlayerMetabolism::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float health = 1;
  if (has_health()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->health(), output);
  }

  // required float calories = 2;
  if (has_calories()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->calories(), output);
  }

  // required float hydration = 3;
  if (has_hydration()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->hydration(), output);
  }

  // required float heartrate = 4;
  if (has_heartrate()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->heartrate(), output);
  }

  // required float temperature = 5;
  if (has_temperature()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->temperature(), output);
  }

  // required float poison = 6;
  if (has_poison()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->poison(), output);
  }

  // required float radiation_level = 7;
  if (has_radiation_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->radiation_level(), output);
  }

  // required float wetness = 8;
  if (has_wetness()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->wetness(), output);
  }

  // required float dirtyness = 9;
  if (has_dirtyness()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->dirtyness(), output);
  }

  // required float oxygen = 10;
  if (has_oxygen()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(10, this->oxygen(), output);
  }

  // required float bleeding = 11;
  if (has_bleeding()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(11, this->bleeding(), output);
  }

  // required float radiation_poisoning = 12;
  if (has_radiation_poisoning()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(12, this->radiation_poisoning(), output);
  }

  // required float comfort = 13;
  if (has_comfort()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(13, this->comfort(), output);
  }

  // required float pending_health = 14;
  if (has_pending_health()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(14, this->pending_health(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PlayerMetabolism::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float health = 1;
  if (has_health()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->health(), target);
  }

  // required float calories = 2;
  if (has_calories()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->calories(), target);
  }

  // required float hydration = 3;
  if (has_hydration()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->hydration(), target);
  }

  // required float heartrate = 4;
  if (has_heartrate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->heartrate(), target);
  }

  // required float temperature = 5;
  if (has_temperature()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->temperature(), target);
  }

  // required float poison = 6;
  if (has_poison()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->poison(), target);
  }

  // required float radiation_level = 7;
  if (has_radiation_level()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->radiation_level(), target);
  }

  // required float wetness = 8;
  if (has_wetness()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->wetness(), target);
  }

  // required float dirtyness = 9;
  if (has_dirtyness()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(9, this->dirtyness(), target);
  }

  // required float oxygen = 10;
  if (has_oxygen()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(10, this->oxygen(), target);
  }

  // required float bleeding = 11;
  if (has_bleeding()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(11, this->bleeding(), target);
  }

  // required float radiation_poisoning = 12;
  if (has_radiation_poisoning()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(12, this->radiation_poisoning(), target);
  }

  // required float comfort = 13;
  if (has_comfort()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(13, this->comfort(), target);
  }

  // required float pending_health = 14;
  if (has_pending_health()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(14, this->pending_health(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PlayerMetabolism::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float health = 1;
    if (has_health()) {
      total_size += 1 + 4;
    }

    // required float calories = 2;
    if (has_calories()) {
      total_size += 1 + 4;
    }

    // required float hydration = 3;
    if (has_hydration()) {
      total_size += 1 + 4;
    }

    // required float heartrate = 4;
    if (has_heartrate()) {
      total_size += 1 + 4;
    }

    // required float temperature = 5;
    if (has_temperature()) {
      total_size += 1 + 4;
    }

    // required float poison = 6;
    if (has_poison()) {
      total_size += 1 + 4;
    }

    // required float radiation_level = 7;
    if (has_radiation_level()) {
      total_size += 1 + 4;
    }

    // required float wetness = 8;
    if (has_wetness()) {
      total_size += 1 + 4;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required float dirtyness = 9;
    if (has_dirtyness()) {
      total_size += 1 + 4;
    }

    // required float oxygen = 10;
    if (has_oxygen()) {
      total_size += 1 + 4;
    }

    // required float bleeding = 11;
    if (has_bleeding()) {
      total_size += 1 + 4;
    }

    // required float radiation_poisoning = 12;
    if (has_radiation_poisoning()) {
      total_size += 1 + 4;
    }

    // required float comfort = 13;
    if (has_comfort()) {
      total_size += 1 + 4;
    }

    // required float pending_health = 14;
    if (has_pending_health()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlayerMetabolism::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PlayerMetabolism* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PlayerMetabolism*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PlayerMetabolism::MergeFrom(const PlayerMetabolism& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_health()) {
      set_health(from.health());
    }
    if (from.has_calories()) {
      set_calories(from.calories());
    }
    if (from.has_hydration()) {
      set_hydration(from.hydration());
    }
    if (from.has_heartrate()) {
      set_heartrate(from.heartrate());
    }
    if (from.has_temperature()) {
      set_temperature(from.temperature());
    }
    if (from.has_poison()) {
      set_poison(from.poison());
    }
    if (from.has_radiation_level()) {
      set_radiation_level(from.radiation_level());
    }
    if (from.has_wetness()) {
      set_wetness(from.wetness());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_dirtyness()) {
      set_dirtyness(from.dirtyness());
    }
    if (from.has_oxygen()) {
      set_oxygen(from.oxygen());
    }
    if (from.has_bleeding()) {
      set_bleeding(from.bleeding());
    }
    if (from.has_radiation_poisoning()) {
      set_radiation_poisoning(from.radiation_poisoning());
    }
    if (from.has_comfort()) {
      set_comfort(from.comfort());
    }
    if (from.has_pending_health()) {
      set_pending_health(from.pending_health());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PlayerMetabolism::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PlayerMetabolism::CopyFrom(const PlayerMetabolism& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerMetabolism::IsInitialized() const {
  if ((_has_bits_[0] & 0x00003fff) != 0x00003fff) return false;

  return true;
}

void PlayerMetabolism::Swap(PlayerMetabolism* other) {
  if (other != this) {
    std::swap(health_, other->health_);
    std::swap(calories_, other->calories_);
    std::swap(hydration_, other->hydration_);
    std::swap(heartrate_, other->heartrate_);
    std::swap(temperature_, other->temperature_);
    std::swap(poison_, other->poison_);
    std::swap(radiation_level_, other->radiation_level_);
    std::swap(wetness_, other->wetness_);
    std::swap(dirtyness_, other->dirtyness_);
    std::swap(oxygen_, other->oxygen_);
    std::swap(bleeding_, other->bleeding_);
    std::swap(radiation_poisoning_, other->radiation_poisoning_);
    std::swap(comfort_, other->comfort_);
    std::swap(pending_health_, other->pending_health_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PlayerMetabolism::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PlayerMetabolism_descriptor_;
  metadata.reflection = PlayerMetabolism_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ModelState::kWaterLevelFieldNumber;
const int ModelState::kLookDirFieldNumber;
const int ModelState::kFlagsFieldNumber;
#endif  // !_MSC_VER

ModelState::ModelState()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ModelState::InitAsDefaultInstance() {
  lookdir_ = const_cast< ::Vector3Serialized*>(&::Vector3Serialized::default_instance());
}

ModelState::ModelState(const ModelState& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ModelState::SharedCtor() {
  _cached_size_ = 0;
  waterlevel_ = 0;
  lookdir_ = NULL;
  flags_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ModelState::~ModelState() {
  SharedDtor();
}

void ModelState::SharedDtor() {
  if (this != default_instance_) {
    delete lookdir_;
  }
}

void ModelState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ModelState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ModelState_descriptor_;
}

const ModelState& ModelState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

ModelState* ModelState::default_instance_ = NULL;

ModelState* ModelState::New() const {
  return new ModelState;
}

void ModelState::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    waterlevel_ = 0;
    if (has_lookdir()) {
      if (lookdir_ != NULL) lookdir_->::Vector3Serialized::Clear();
    }
    flags_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ModelState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float waterLevel = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &waterlevel_)));
          set_has_waterlevel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_lookDir;
        break;
      }

      // required .Vector3Serialized lookDir = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_lookDir:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_lookdir()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_flags;
        break;
      }

      // required uint64 flags = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_flags:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &flags_)));
          set_has_flags();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ModelState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float waterLevel = 4;
  if (has_waterlevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->waterlevel(), output);
  }

  // required .Vector3Serialized lookDir = 10;
  if (has_lookdir()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->lookdir(), output);
  }

  // required uint64 flags = 11;
  if (has_flags()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(11, this->flags(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ModelState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float waterLevel = 4;
  if (has_waterlevel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->waterlevel(), target);
  }

  // required .Vector3Serialized lookDir = 10;
  if (has_lookdir()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->lookdir(), target);
  }

  // required uint64 flags = 11;
  if (has_flags()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(11, this->flags(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ModelState::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float waterLevel = 4;
    if (has_waterlevel()) {
      total_size += 1 + 4;
    }

    // required .Vector3Serialized lookDir = 10;
    if (has_lookdir()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->lookdir());
    }

    // required uint64 flags = 11;
    if (has_flags()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->flags());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ModelState::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ModelState* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ModelState*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ModelState::MergeFrom(const ModelState& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_waterlevel()) {
      set_waterlevel(from.waterlevel());
    }
    if (from.has_lookdir()) {
      mutable_lookdir()->::Vector3Serialized::MergeFrom(from.lookdir());
    }
    if (from.has_flags()) {
      set_flags(from.flags());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ModelState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ModelState::CopyFrom(const ModelState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelState::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_lookdir()) {
    if (!this->lookdir().IsInitialized()) return false;
  }
  return true;
}

void ModelState::Swap(ModelState* other) {
  if (other != this) {
    std::swap(waterlevel_, other->waterlevel_);
    std::swap(lookdir_, other->lookdir_);
    std::swap(flags_, other->flags_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ModelState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ModelState_descriptor_;
  metadata.reflection = ModelState_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PersistantPlayer::kUnlockedItemsFieldNumber;
const int PersistantPlayer::kProtocolVersionFieldNumber;
#endif  // !_MSC_VER

PersistantPlayer::PersistantPlayer()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PersistantPlayer::InitAsDefaultInstance() {
}

PersistantPlayer::PersistantPlayer(const PersistantPlayer& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PersistantPlayer::SharedCtor() {
  _cached_size_ = 0;
  protocolversion_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PersistantPlayer::~PersistantPlayer() {
  SharedDtor();
}

void PersistantPlayer::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PersistantPlayer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PersistantPlayer::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PersistantPlayer_descriptor_;
}

const PersistantPlayer& PersistantPlayer::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

PersistantPlayer* PersistantPlayer::default_instance_ = NULL;

PersistantPlayer* PersistantPlayer::New() const {
  return new PersistantPlayer;
}

void PersistantPlayer::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    protocolversion_ = GOOGLE_ULONGLONG(0);
  }
  unlockeditems_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PersistantPlayer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint64 unlockedItems = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_unlockedItems:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 24, input, this->mutable_unlockeditems())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_unlockeditems())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_unlockedItems;
        if (input->ExpectTag(800)) goto parse_protocolVersion;
        break;
      }

      // required uint64 protocolVersion = 100;
      case 100: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_protocolVersion:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &protocolversion_)));
          set_has_protocolversion();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PersistantPlayer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated uint64 unlockedItems = 3;
  for (int i = 0; i < this->unlockeditems_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(
      3, this->unlockeditems(i), output);
  }

  // required uint64 protocolVersion = 100;
  if (has_protocolversion()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(100, this->protocolversion(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PersistantPlayer::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated uint64 unlockedItems = 3;
  for (int i = 0; i < this->unlockeditems_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt64ToArray(3, this->unlockeditems(i), target);
  }

  // required uint64 protocolVersion = 100;
  if (has_protocolversion()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(100, this->protocolversion(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PersistantPlayer::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required uint64 protocolVersion = 100;
    if (has_protocolversion()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->protocolversion());
    }

  }
  // repeated uint64 unlockedItems = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->unlockeditems_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt64Size(this->unlockeditems(i));
    }
    total_size += 1 * this->unlockeditems_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PersistantPlayer::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PersistantPlayer* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PersistantPlayer*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PersistantPlayer::MergeFrom(const PersistantPlayer& from) {
  GOOGLE_CHECK_NE(&from, this);
  unlockeditems_.MergeFrom(from.unlockeditems_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_protocolversion()) {
      set_protocolversion(from.protocolversion());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PersistantPlayer::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PersistantPlayer::CopyFrom(const PersistantPlayer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PersistantPlayer::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  return true;
}

void PersistantPlayer::Swap(PersistantPlayer* other) {
  if (other != this) {
    unlockeditems_.Swap(&other->unlockeditems_);
    std::swap(protocolversion_, other->protocolversion_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PersistantPlayer::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PersistantPlayer_descriptor_;
  metadata.reflection = PersistantPlayer_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PlayerLifeStory_DeathInfo::kAttackerNameFieldNumber;
const int PlayerLifeStory_DeathInfo::kAttackerSteamIDFieldNumber;
const int PlayerLifeStory_DeathInfo::kHitBoneFieldNumber;
const int PlayerLifeStory_DeathInfo::kInflictorNameFieldNumber;
const int PlayerLifeStory_DeathInfo::kLastDamageTypeFieldNumber;
#endif  // !_MSC_VER

PlayerLifeStory_DeathInfo::PlayerLifeStory_DeathInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PlayerLifeStory_DeathInfo::InitAsDefaultInstance() {
}

PlayerLifeStory_DeathInfo::PlayerLifeStory_DeathInfo(const PlayerLifeStory_DeathInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PlayerLifeStory_DeathInfo::SharedCtor() {
  _cached_size_ = 0;
  attackername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  attackersteamid_ = GOOGLE_ULONGLONG(0);
  hitbone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  inflictorname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  lastdamagetype_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlayerLifeStory_DeathInfo::~PlayerLifeStory_DeathInfo() {
  SharedDtor();
}

void PlayerLifeStory_DeathInfo::SharedDtor() {
  if (attackername_ != &::google::protobuf::internal::kEmptyString) {
    delete attackername_;
  }
  if (hitbone_ != &::google::protobuf::internal::kEmptyString) {
    delete hitbone_;
  }
  if (inflictorname_ != &::google::protobuf::internal::kEmptyString) {
    delete inflictorname_;
  }
  if (this != default_instance_) {
  }
}

void PlayerLifeStory_DeathInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PlayerLifeStory_DeathInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PlayerLifeStory_DeathInfo_descriptor_;
}

const PlayerLifeStory_DeathInfo& PlayerLifeStory_DeathInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

PlayerLifeStory_DeathInfo* PlayerLifeStory_DeathInfo::default_instance_ = NULL;

PlayerLifeStory_DeathInfo* PlayerLifeStory_DeathInfo::New() const {
  return new PlayerLifeStory_DeathInfo;
}

void PlayerLifeStory_DeathInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_attackername()) {
      if (attackername_ != &::google::protobuf::internal::kEmptyString) {
        attackername_->clear();
      }
    }
    attackersteamid_ = GOOGLE_ULONGLONG(0);
    if (has_hitbone()) {
      if (hitbone_ != &::google::protobuf::internal::kEmptyString) {
        hitbone_->clear();
      }
    }
    if (has_inflictorname()) {
      if (inflictorname_ != &::google::protobuf::internal::kEmptyString) {
        inflictorname_->clear();
      }
    }
    lastdamagetype_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PlayerLifeStory_DeathInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string attackerName = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_attackername()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->attackername().data(), this->attackername().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_attackerSteamID;
        break;
      }

      // required uint64 attackerSteamID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_attackerSteamID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &attackersteamid_)));
          set_has_attackersteamid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_hitBone;
        break;
      }

      // optional string hitBone = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_hitBone:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hitbone()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->hitbone().data(), this->hitbone().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_inflictorName;
        break;
      }

      // optional string inflictorName = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_inflictorName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_inflictorname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->inflictorname().data(), this->inflictorname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_lastDamageType;
        break;
      }

      // required uint64 lastDamageType = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_lastDamageType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &lastdamagetype_)));
          set_has_lastdamagetype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PlayerLifeStory_DeathInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string attackerName = 1;
  if (has_attackername()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->attackername().data(), this->attackername().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->attackername(), output);
  }

  // required uint64 attackerSteamID = 2;
  if (has_attackersteamid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->attackersteamid(), output);
  }

  // optional string hitBone = 3;
  if (has_hitbone()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->hitbone().data(), this->hitbone().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->hitbone(), output);
  }

  // optional string inflictorName = 4;
  if (has_inflictorname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->inflictorname().data(), this->inflictorname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->inflictorname(), output);
  }

  // required uint64 lastDamageType = 5;
  if (has_lastdamagetype()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->lastdamagetype(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PlayerLifeStory_DeathInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string attackerName = 1;
  if (has_attackername()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->attackername().data(), this->attackername().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->attackername(), target);
  }

  // required uint64 attackerSteamID = 2;
  if (has_attackersteamid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->attackersteamid(), target);
  }

  // optional string hitBone = 3;
  if (has_hitbone()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->hitbone().data(), this->hitbone().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->hitbone(), target);
  }

  // optional string inflictorName = 4;
  if (has_inflictorname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->inflictorname().data(), this->inflictorname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->inflictorname(), target);
  }

  // required uint64 lastDamageType = 5;
  if (has_lastdamagetype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(5, this->lastdamagetype(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PlayerLifeStory_DeathInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string attackerName = 1;
    if (has_attackername()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->attackername());
    }

    // required uint64 attackerSteamID = 2;
    if (has_attackersteamid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->attackersteamid());
    }

    // optional string hitBone = 3;
    if (has_hitbone()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->hitbone());
    }

    // optional string inflictorName = 4;
    if (has_inflictorname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->inflictorname());
    }

    // required uint64 lastDamageType = 5;
    if (has_lastdamagetype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->lastdamagetype());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlayerLifeStory_DeathInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PlayerLifeStory_DeathInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PlayerLifeStory_DeathInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PlayerLifeStory_DeathInfo::MergeFrom(const PlayerLifeStory_DeathInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_attackername()) {
      set_attackername(from.attackername());
    }
    if (from.has_attackersteamid()) {
      set_attackersteamid(from.attackersteamid());
    }
    if (from.has_hitbone()) {
      set_hitbone(from.hitbone());
    }
    if (from.has_inflictorname()) {
      set_inflictorname(from.inflictorname());
    }
    if (from.has_lastdamagetype()) {
      set_lastdamagetype(from.lastdamagetype());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PlayerLifeStory_DeathInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PlayerLifeStory_DeathInfo::CopyFrom(const PlayerLifeStory_DeathInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerLifeStory_DeathInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000012) != 0x00000012) return false;

  return true;
}

void PlayerLifeStory_DeathInfo::Swap(PlayerLifeStory_DeathInfo* other) {
  if (other != this) {
    std::swap(attackername_, other->attackername_);
    std::swap(attackersteamid_, other->attackersteamid_);
    std::swap(hitbone_, other->hitbone_);
    std::swap(inflictorname_, other->inflictorname_);
    std::swap(lastdamagetype_, other->lastdamagetype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PlayerLifeStory_DeathInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PlayerLifeStory_DeathInfo_descriptor_;
  metadata.reflection = PlayerLifeStory_DeathInfo_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int PlayerLifeStory::kSecondsAliveFieldNumber;
const int PlayerLifeStory::kMetersWalkedFieldNumber;
const int PlayerLifeStory::kMetersRunFieldNumber;
const int PlayerLifeStory::kSecondsSleepingFieldNumber;
const int PlayerLifeStory::kTimeBornFieldNumber;
const int PlayerLifeStory::kTimeDeadFieldNumber;
const int PlayerLifeStory::kDeathInfoFieldNumber;
#endif  // !_MSC_VER

PlayerLifeStory::PlayerLifeStory()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PlayerLifeStory::InitAsDefaultInstance() {
  deathinfo_ = const_cast< ::PlayerLifeStory_DeathInfo*>(&::PlayerLifeStory_DeathInfo::default_instance());
}

PlayerLifeStory::PlayerLifeStory(const PlayerLifeStory& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PlayerLifeStory::SharedCtor() {
  _cached_size_ = 0;
  secondsalive_ = 0;
  meterswalked_ = 0;
  metersrun_ = 0;
  secondssleeping_ = 0;
  timeborn_ = 0u;
  timedead_ = 0u;
  deathinfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlayerLifeStory::~PlayerLifeStory() {
  SharedDtor();
}

void PlayerLifeStory::SharedDtor() {
  if (this != default_instance_) {
    delete deathinfo_;
  }
}

void PlayerLifeStory::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PlayerLifeStory::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PlayerLifeStory_descriptor_;
}

const PlayerLifeStory& PlayerLifeStory::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

PlayerLifeStory* PlayerLifeStory::default_instance_ = NULL;

PlayerLifeStory* PlayerLifeStory::New() const {
  return new PlayerLifeStory;
}

void PlayerLifeStory::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    secondsalive_ = 0;
    meterswalked_ = 0;
    metersrun_ = 0;
    secondssleeping_ = 0;
    timeborn_ = 0u;
    timedead_ = 0u;
    if (has_deathinfo()) {
      if (deathinfo_ != NULL) deathinfo_->::PlayerLifeStory_DeathInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PlayerLifeStory::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float secondsAlive = 100;
      case 100: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &secondsalive_)));
          set_has_secondsalive();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(813)) goto parse_metersWalked;
        break;
      }

      // required float metersWalked = 101;
      case 101: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_metersWalked:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &meterswalked_)));
          set_has_meterswalked();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(821)) goto parse_metersRun;
        break;
      }

      // required float metersRun = 102;
      case 102: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_metersRun:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &metersrun_)));
          set_has_metersrun();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(829)) goto parse_secondsSleeping;
        break;
      }

      // required float secondsSleeping = 103;
      case 103: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_secondsSleeping:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &secondssleeping_)));
          set_has_secondssleeping();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(832)) goto parse_timeBorn;
        break;
      }

      // required uint32 timeBorn = 104;
      case 104: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_timeBorn:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &timeborn_)));
          set_has_timeborn();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(840)) goto parse_timeDead;
        break;
      }

      // required uint32 timeDead = 105;
      case 105: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_timeDead:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &timedead_)));
          set_has_timedead();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(1602)) goto parse_deathInfo;
        break;
      }

      // optional .PlayerLifeStory.DeathInfo deathInfo = 200;
      case 200: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_deathInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_deathinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PlayerLifeStory::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float secondsAlive = 100;
  if (has_secondsalive()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(100, this->secondsalive(), output);
  }

  // required float metersWalked = 101;
  if (has_meterswalked()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(101, this->meterswalked(), output);
  }

  // required float metersRun = 102;
  if (has_metersrun()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(102, this->metersrun(), output);
  }

  // required float secondsSleeping = 103;
  if (has_secondssleeping()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(103, this->secondssleeping(), output);
  }

  // required uint32 timeBorn = 104;
  if (has_timeborn()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(104, this->timeborn(), output);
  }

  // required uint32 timeDead = 105;
  if (has_timedead()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(105, this->timedead(), output);
  }

  // optional .PlayerLifeStory.DeathInfo deathInfo = 200;
  if (has_deathinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      200, this->deathinfo(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PlayerLifeStory::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float secondsAlive = 100;
  if (has_secondsalive()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(100, this->secondsalive(), target);
  }

  // required float metersWalked = 101;
  if (has_meterswalked()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(101, this->meterswalked(), target);
  }

  // required float metersRun = 102;
  if (has_metersrun()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(102, this->metersrun(), target);
  }

  // required float secondsSleeping = 103;
  if (has_secondssleeping()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(103, this->secondssleeping(), target);
  }

  // required uint32 timeBorn = 104;
  if (has_timeborn()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(104, this->timeborn(), target);
  }

  // required uint32 timeDead = 105;
  if (has_timedead()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(105, this->timedead(), target);
  }

  // optional .PlayerLifeStory.DeathInfo deathInfo = 200;
  if (has_deathinfo()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        200, this->deathinfo(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PlayerLifeStory::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float secondsAlive = 100;
    if (has_secondsalive()) {
      total_size += 2 + 4;
    }

    // required float metersWalked = 101;
    if (has_meterswalked()) {
      total_size += 2 + 4;
    }

    // required float metersRun = 102;
    if (has_metersrun()) {
      total_size += 2 + 4;
    }

    // required float secondsSleeping = 103;
    if (has_secondssleeping()) {
      total_size += 2 + 4;
    }

    // required uint32 timeBorn = 104;
    if (has_timeborn()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->timeborn());
    }

    // required uint32 timeDead = 105;
    if (has_timedead()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->timedead());
    }

    // optional .PlayerLifeStory.DeathInfo deathInfo = 200;
    if (has_deathinfo()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->deathinfo());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlayerLifeStory::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PlayerLifeStory* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PlayerLifeStory*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PlayerLifeStory::MergeFrom(const PlayerLifeStory& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_secondsalive()) {
      set_secondsalive(from.secondsalive());
    }
    if (from.has_meterswalked()) {
      set_meterswalked(from.meterswalked());
    }
    if (from.has_metersrun()) {
      set_metersrun(from.metersrun());
    }
    if (from.has_secondssleeping()) {
      set_secondssleeping(from.secondssleeping());
    }
    if (from.has_timeborn()) {
      set_timeborn(from.timeborn());
    }
    if (from.has_timedead()) {
      set_timedead(from.timedead());
    }
    if (from.has_deathinfo()) {
      mutable_deathinfo()->::PlayerLifeStory_DeathInfo::MergeFrom(from.deathinfo());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PlayerLifeStory::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PlayerLifeStory::CopyFrom(const PlayerLifeStory& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerLifeStory::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  if (has_deathinfo()) {
    if (!this->deathinfo().IsInitialized()) return false;
  }
  return true;
}

void PlayerLifeStory::Swap(PlayerLifeStory* other) {
  if (other != this) {
    std::swap(secondsalive_, other->secondsalive_);
    std::swap(meterswalked_, other->meterswalked_);
    std::swap(metersrun_, other->metersrun_);
    std::swap(secondssleeping_, other->secondssleeping_);
    std::swap(timeborn_, other->timeborn_);
    std::swap(timedead_, other->timedead_);
    std::swap(deathinfo_, other->deathinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PlayerLifeStory::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PlayerLifeStory_descriptor_;
  metadata.reflection = PlayerLifeStory_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BasePlayer::kNameFieldNumber;
const int BasePlayer::kUseridFieldNumber;
const int BasePlayer::kInventoryFieldNumber;
const int BasePlayer::kMetabolismFieldNumber;
const int BasePlayer::kModelStateFieldNumber;
const int BasePlayer::kPlayerFlagsFieldNumber;
const int BasePlayer::kHeldEntityFieldNumber;
const int BasePlayer::kHealthFieldNumber;
const int BasePlayer::kPersistantDataFieldNumber;
const int BasePlayer::kSkinColFieldNumber;
const int BasePlayer::kSkinTexFieldNumber;
const int BasePlayer::kSkinMeshFieldNumber;
const int BasePlayer::kCurrentLifeFieldNumber;
const int BasePlayer::kPreviousLifeFieldNumber;
#endif  // !_MSC_VER

BasePlayer::BasePlayer()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void BasePlayer::InitAsDefaultInstance() {
  inventory_ = const_cast< ::PlayerInventory*>(&::PlayerInventory::default_instance());
  metabolism_ = const_cast< ::PlayerMetabolism*>(&::PlayerMetabolism::default_instance());
  modelstate_ = const_cast< ::ModelState*>(&::ModelState::default_instance());
  persistantdata_ = const_cast< ::PersistantPlayer*>(&::PersistantPlayer::default_instance());
  currentlife_ = const_cast< ::PlayerLifeStory*>(&::PlayerLifeStory::default_instance());
  previouslife_ = const_cast< ::PlayerLifeStory*>(&::PlayerLifeStory::default_instance());
}

BasePlayer::BasePlayer(const BasePlayer& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void BasePlayer::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  userid_ = GOOGLE_ULONGLONG(0);
  inventory_ = NULL;
  metabolism_ = NULL;
  modelstate_ = NULL;
  playerflags_ = GOOGLE_ULONGLONG(0);
  heldentity_ = 0u;
  health_ = 0;
  persistantdata_ = NULL;
  skincol_ = 0;
  skintex_ = 0;
  skinmesh_ = 0;
  currentlife_ = NULL;
  previouslife_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BasePlayer::~BasePlayer() {
  SharedDtor();
}

void BasePlayer::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
    delete inventory_;
    delete metabolism_;
    delete modelstate_;
    delete persistantdata_;
    delete currentlife_;
    delete previouslife_;
  }
}

void BasePlayer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BasePlayer::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BasePlayer_descriptor_;
}

const BasePlayer& BasePlayer::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

BasePlayer* BasePlayer::default_instance_ = NULL;

BasePlayer* BasePlayer::New() const {
  return new BasePlayer;
}

void BasePlayer::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    userid_ = GOOGLE_ULONGLONG(0);
    if (has_inventory()) {
      if (inventory_ != NULL) inventory_->::PlayerInventory::Clear();
    }
    if (has_metabolism()) {
      if (metabolism_ != NULL) metabolism_->::PlayerMetabolism::Clear();
    }
    if (has_modelstate()) {
      if (modelstate_ != NULL) modelstate_->::ModelState::Clear();
    }
    playerflags_ = GOOGLE_ULONGLONG(0);
    heldentity_ = 0u;
    health_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_persistantdata()) {
      if (persistantdata_ != NULL) persistantdata_->::PersistantPlayer::Clear();
    }
    skincol_ = 0;
    skintex_ = 0;
    skinmesh_ = 0;
    if (has_currentlife()) {
      if (currentlife_ != NULL) currentlife_->::PlayerLifeStory::Clear();
    }
    if (has_previouslife()) {
      if (previouslife_ != NULL) previouslife_->::PlayerLifeStory::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BasePlayer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_userid;
        break;
      }

      // required uint64 userid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_userid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &userid_)));
          set_has_userid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_inventory;
        break;
      }

      // optional .PlayerInventory inventory = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_inventory:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_inventory()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_metabolism;
        break;
      }

      // optional .PlayerMetabolism metabolism = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_metabolism:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_metabolism()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_modelState;
        break;
      }

      // optional .ModelState modelState = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_modelState:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_modelstate()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_playerFlags;
        break;
      }

      // required uint64 playerFlags = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_playerFlags:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &playerflags_)));
          set_has_playerflags();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_heldEntity;
        break;
      }

      // required uint32 heldEntity = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_heldEntity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &heldentity_)));
          set_has_heldentity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(77)) goto parse_health;
        break;
      }

      // required float health = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_health:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &health_)));
          set_has_health();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_persistantData;
        break;
      }

      // optional .PersistantPlayer persistantData = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_persistantData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_persistantdata()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(125)) goto parse_skinCol;
        break;
      }

      // required float skinCol = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_skinCol:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &skincol_)));
          set_has_skincol();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(133)) goto parse_skinTex;
        break;
      }

      // required float skinTex = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_skinTex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &skintex_)));
          set_has_skintex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(141)) goto parse_skinMesh;
        break;
      }

      // required float skinMesh = 17;
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_skinMesh:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &skinmesh_)));
          set_has_skinmesh();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(162)) goto parse_currentLife;
        break;
      }

      // optional .PlayerLifeStory currentLife = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_currentLife:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_currentlife()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(170)) goto parse_previousLife;
        break;
      }

      // optional .PlayerLifeStory previousLife = 21;
      case 21: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_previousLife:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_previouslife()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BasePlayer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // required uint64 userid = 2;
  if (has_userid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->userid(), output);
  }

  // optional .PlayerInventory inventory = 3;
  if (has_inventory()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->inventory(), output);
  }

  // optional .PlayerMetabolism metabolism = 4;
  if (has_metabolism()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->metabolism(), output);
  }

  // optional .ModelState modelState = 6;
  if (has_modelstate()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->modelstate(), output);
  }

  // required uint64 playerFlags = 7;
  if (has_playerflags()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(7, this->playerflags(), output);
  }

  // required uint32 heldEntity = 8;
  if (has_heldentity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->heldentity(), output);
  }

  // required float health = 9;
  if (has_health()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->health(), output);
  }

  // optional .PersistantPlayer persistantData = 10;
  if (has_persistantdata()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->persistantdata(), output);
  }

  // required float skinCol = 15;
  if (has_skincol()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(15, this->skincol(), output);
  }

  // required float skinTex = 16;
  if (has_skintex()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(16, this->skintex(), output);
  }

  // required float skinMesh = 17;
  if (has_skinmesh()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(17, this->skinmesh(), output);
  }

  // optional .PlayerLifeStory currentLife = 20;
  if (has_currentlife()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      20, this->currentlife(), output);
  }

  // optional .PlayerLifeStory previousLife = 21;
  if (has_previouslife()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      21, this->previouslife(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* BasePlayer::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required uint64 userid = 2;
  if (has_userid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->userid(), target);
  }

  // optional .PlayerInventory inventory = 3;
  if (has_inventory()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->inventory(), target);
  }

  // optional .PlayerMetabolism metabolism = 4;
  if (has_metabolism()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->metabolism(), target);
  }

  // optional .ModelState modelState = 6;
  if (has_modelstate()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->modelstate(), target);
  }

  // required uint64 playerFlags = 7;
  if (has_playerflags()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(7, this->playerflags(), target);
  }

  // required uint32 heldEntity = 8;
  if (has_heldentity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->heldentity(), target);
  }

  // required float health = 9;
  if (has_health()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(9, this->health(), target);
  }

  // optional .PersistantPlayer persistantData = 10;
  if (has_persistantdata()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->persistantdata(), target);
  }

  // required float skinCol = 15;
  if (has_skincol()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(15, this->skincol(), target);
  }

  // required float skinTex = 16;
  if (has_skintex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(16, this->skintex(), target);
  }

  // required float skinMesh = 17;
  if (has_skinmesh()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(17, this->skinmesh(), target);
  }

  // optional .PlayerLifeStory currentLife = 20;
  if (has_currentlife()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        20, this->currentlife(), target);
  }

  // optional .PlayerLifeStory previousLife = 21;
  if (has_previouslife()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        21, this->previouslife(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int BasePlayer::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required uint64 userid = 2;
    if (has_userid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->userid());
    }

    // optional .PlayerInventory inventory = 3;
    if (has_inventory()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->inventory());
    }

    // optional .PlayerMetabolism metabolism = 4;
    if (has_metabolism()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->metabolism());
    }

    // optional .ModelState modelState = 6;
    if (has_modelstate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->modelstate());
    }

    // required uint64 playerFlags = 7;
    if (has_playerflags()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->playerflags());
    }

    // required uint32 heldEntity = 8;
    if (has_heldentity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->heldentity());
    }

    // required float health = 9;
    if (has_health()) {
      total_size += 1 + 4;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .PersistantPlayer persistantData = 10;
    if (has_persistantdata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->persistantdata());
    }

    // required float skinCol = 15;
    if (has_skincol()) {
      total_size += 1 + 4;
    }

    // required float skinTex = 16;
    if (has_skintex()) {
      total_size += 2 + 4;
    }

    // required float skinMesh = 17;
    if (has_skinmesh()) {
      total_size += 2 + 4;
    }

    // optional .PlayerLifeStory currentLife = 20;
    if (has_currentlife()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->currentlife());
    }

    // optional .PlayerLifeStory previousLife = 21;
    if (has_previouslife()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->previouslife());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BasePlayer::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BasePlayer* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BasePlayer*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BasePlayer::MergeFrom(const BasePlayer& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_userid()) {
      set_userid(from.userid());
    }
    if (from.has_inventory()) {
      mutable_inventory()->::PlayerInventory::MergeFrom(from.inventory());
    }
    if (from.has_metabolism()) {
      mutable_metabolism()->::PlayerMetabolism::MergeFrom(from.metabolism());
    }
    if (from.has_modelstate()) {
      mutable_modelstate()->::ModelState::MergeFrom(from.modelstate());
    }
    if (from.has_playerflags()) {
      set_playerflags(from.playerflags());
    }
    if (from.has_heldentity()) {
      set_heldentity(from.heldentity());
    }
    if (from.has_health()) {
      set_health(from.health());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_persistantdata()) {
      mutable_persistantdata()->::PersistantPlayer::MergeFrom(from.persistantdata());
    }
    if (from.has_skincol()) {
      set_skincol(from.skincol());
    }
    if (from.has_skintex()) {
      set_skintex(from.skintex());
    }
    if (from.has_skinmesh()) {
      set_skinmesh(from.skinmesh());
    }
    if (from.has_currentlife()) {
      mutable_currentlife()->::PlayerLifeStory::MergeFrom(from.currentlife());
    }
    if (from.has_previouslife()) {
      mutable_previouslife()->::PlayerLifeStory::MergeFrom(from.previouslife());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BasePlayer::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BasePlayer::CopyFrom(const BasePlayer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BasePlayer::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000ee2) != 0x00000ee2) return false;

  if (has_inventory()) {
    if (!this->inventory().IsInitialized()) return false;
  }
  if (has_metabolism()) {
    if (!this->metabolism().IsInitialized()) return false;
  }
  if (has_modelstate()) {
    if (!this->modelstate().IsInitialized()) return false;
  }
  if (has_persistantdata()) {
    if (!this->persistantdata().IsInitialized()) return false;
  }
  if (has_currentlife()) {
    if (!this->currentlife().IsInitialized()) return false;
  }
  if (has_previouslife()) {
    if (!this->previouslife().IsInitialized()) return false;
  }
  return true;
}

void BasePlayer::Swap(BasePlayer* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(userid_, other->userid_);
    std::swap(inventory_, other->inventory_);
    std::swap(metabolism_, other->metabolism_);
    std::swap(modelstate_, other->modelstate_);
    std::swap(playerflags_, other->playerflags_);
    std::swap(heldentity_, other->heldentity_);
    std::swap(health_, other->health_);
    std::swap(persistantdata_, other->persistantdata_);
    std::swap(skincol_, other->skincol_);
    std::swap(skintex_, other->skintex_);
    std::swap(skinmesh_, other->skinmesh_);
    std::swap(currentlife_, other->currentlife_);
    std::swap(previouslife_, other->previouslife_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BasePlayer::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BasePlayer_descriptor_;
  metadata.reflection = BasePlayer_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int WorldItem::kItemFieldNumber;
#endif  // !_MSC_VER

WorldItem::WorldItem()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void WorldItem::InitAsDefaultInstance() {
  item_ = const_cast< ::Item*>(&::Item::default_instance());
}

WorldItem::WorldItem(const WorldItem& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void WorldItem::SharedCtor() {
  _cached_size_ = 0;
  item_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WorldItem::~WorldItem() {
  SharedDtor();
}

void WorldItem::SharedDtor() {
  if (this != default_instance_) {
    delete item_;
  }
}

void WorldItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WorldItem::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WorldItem_descriptor_;
}

const WorldItem& WorldItem::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

WorldItem* WorldItem::default_instance_ = NULL;

WorldItem* WorldItem::New() const {
  return new WorldItem;
}

void WorldItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_item()) {
      if (item_ != NULL) item_->::Item::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WorldItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Item item = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_item()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void WorldItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Item item = 1;
  if (has_item()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->item(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* WorldItem::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .Item item = 1;
  if (has_item()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->item(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int WorldItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Item item = 1;
    if (has_item()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->item());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WorldItem::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WorldItem* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WorldItem*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WorldItem::MergeFrom(const WorldItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_item()) {
      mutable_item()->::Item::MergeFrom(from.item());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WorldItem::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WorldItem::CopyFrom(const WorldItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WorldItem::IsInitialized() const {

  if (has_item()) {
    if (!this->item().IsInitialized()) return false;
  }
  return true;
}

void WorldItem::Swap(WorldItem* other) {
  if (other != this) {
    std::swap(item_, other->item_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WorldItem::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WorldItem_descriptor_;
  metadata.reflection = WorldItem_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BaseResource::kStageFieldNumber;
const int BaseResource::kHealthFieldNumber;
#endif  // !_MSC_VER

BaseResource::BaseResource()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void BaseResource::InitAsDefaultInstance() {
}

BaseResource::BaseResource(const BaseResource& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void BaseResource::SharedCtor() {
  _cached_size_ = 0;
  stage_ = GOOGLE_ULONGLONG(0);
  health_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BaseResource::~BaseResource() {
  SharedDtor();
}

void BaseResource::SharedDtor() {
  if (this != default_instance_) {
  }
}

void BaseResource::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BaseResource::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BaseResource_descriptor_;
}

const BaseResource& BaseResource::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

BaseResource* BaseResource::default_instance_ = NULL;

BaseResource* BaseResource::New() const {
  return new BaseResource;
}

void BaseResource::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    stage_ = GOOGLE_ULONGLONG(0);
    health_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BaseResource::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 stage = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &stage_)));
          set_has_stage();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_health;
        break;
      }

      // required float health = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_health:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &health_)));
          set_has_health();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BaseResource::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 stage = 1;
  if (has_stage()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->stage(), output);
  }

  // required float health = 2;
  if (has_health()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->health(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* BaseResource::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 stage = 1;
  if (has_stage()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->stage(), target);
  }

  // required float health = 2;
  if (has_health()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->health(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int BaseResource::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 stage = 1;
    if (has_stage()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->stage());
    }

    // required float health = 2;
    if (has_health()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BaseResource::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BaseResource* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BaseResource*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BaseResource::MergeFrom(const BaseResource& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_stage()) {
      set_stage(from.stage());
    }
    if (from.has_health()) {
      set_health(from.health());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BaseResource::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BaseResource::CopyFrom(const BaseResource& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BaseResource::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void BaseResource::Swap(BaseResource* other) {
  if (other != this) {
    std::swap(stage_, other->stage_);
    std::swap(health_, other->health_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BaseResource::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BaseResource_descriptor_;
  metadata.reflection = BaseResource_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BuildingBlock::kGradeFieldNumber;
const int BuildingBlock::kBeingDemolishedFieldNumber;
const int BuildingBlock::kStabilityFieldNumber;
const int BuildingBlock::kBuildingIDFieldNumber;
#endif  // !_MSC_VER

BuildingBlock::BuildingBlock()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void BuildingBlock::InitAsDefaultInstance() {
}

BuildingBlock::BuildingBlock(const BuildingBlock& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void BuildingBlock::SharedCtor() {
  _cached_size_ = 0;
  grade_ = GOOGLE_ULONGLONG(0);
  beingdemolished_ = false;
  stability_ = 0;
  buildingid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BuildingBlock::~BuildingBlock() {
  SharedDtor();
}

void BuildingBlock::SharedDtor() {
  if (this != default_instance_) {
  }
}

void BuildingBlock::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BuildingBlock::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BuildingBlock_descriptor_;
}

const BuildingBlock& BuildingBlock::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

BuildingBlock* BuildingBlock::default_instance_ = NULL;

BuildingBlock* BuildingBlock::New() const {
  return new BuildingBlock;
}

void BuildingBlock::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    grade_ = GOOGLE_ULONGLONG(0);
    beingdemolished_ = false;
    stability_ = 0;
    buildingid_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BuildingBlock::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 grade = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &grade_)));
          set_has_grade();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_beingDemolished;
        break;
      }

      // required bool beingDemolished = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_beingDemolished:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &beingdemolished_)));
          set_has_beingdemolished();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_stability;
        break;
      }

      // required float stability = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_stability:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &stability_)));
          set_has_stability();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_buildingID;
        break;
      }

      // required uint32 buildingID = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_buildingID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &buildingid_)));
          set_has_buildingid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BuildingBlock::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 grade = 2;
  if (has_grade()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->grade(), output);
  }

  // required bool beingDemolished = 3;
  if (has_beingdemolished()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->beingdemolished(), output);
  }

  // required float stability = 4;
  if (has_stability()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->stability(), output);
  }

  // required uint32 buildingID = 5;
  if (has_buildingid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->buildingid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* BuildingBlock::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 grade = 2;
  if (has_grade()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->grade(), target);
  }

  // required bool beingDemolished = 3;
  if (has_beingdemolished()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->beingdemolished(), target);
  }

  // required float stability = 4;
  if (has_stability()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->stability(), target);
  }

  // required uint32 buildingID = 5;
  if (has_buildingid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->buildingid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int BuildingBlock::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 grade = 2;
    if (has_grade()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->grade());
    }

    // required bool beingDemolished = 3;
    if (has_beingdemolished()) {
      total_size += 1 + 1;
    }

    // required float stability = 4;
    if (has_stability()) {
      total_size += 1 + 4;
    }

    // required uint32 buildingID = 5;
    if (has_buildingid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->buildingid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BuildingBlock::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BuildingBlock* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BuildingBlock*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BuildingBlock::MergeFrom(const BuildingBlock& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_grade()) {
      set_grade(from.grade());
    }
    if (from.has_beingdemolished()) {
      set_beingdemolished(from.beingdemolished());
    }
    if (from.has_stability()) {
      set_stability(from.stability());
    }
    if (from.has_buildingid()) {
      set_buildingid(from.buildingid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BuildingBlock::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BuildingBlock::CopyFrom(const BuildingBlock& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BuildingBlock::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void BuildingBlock::Swap(BuildingBlock* other) {
  if (other != this) {
    std::swap(grade_, other->grade_);
    std::swap(beingdemolished_, other->beingdemolished_);
    std::swap(stability_, other->stability_);
    std::swap(buildingid_, other->buildingid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BuildingBlock::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BuildingBlock_descriptor_;
  metadata.reflection = BuildingBlock_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Environment::kDateTimeFieldNumber;
const int Environment::kCloudsFieldNumber;
const int Environment::kFogFieldNumber;
const int Environment::kWindFieldNumber;
const int Environment::kRainFieldNumber;
#endif  // !_MSC_VER

Environment::Environment()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Environment::InitAsDefaultInstance() {
}

Environment::Environment(const Environment& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Environment::SharedCtor() {
  _cached_size_ = 0;
  datetime_ = GOOGLE_ULONGLONG(0);
  clouds_ = 0;
  fog_ = 0;
  wind_ = 0;
  rain_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Environment::~Environment() {
  SharedDtor();
}

void Environment::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Environment::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Environment::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Environment_descriptor_;
}

const Environment& Environment::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

Environment* Environment::default_instance_ = NULL;

Environment* Environment::New() const {
  return new Environment;
}

void Environment::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    datetime_ = GOOGLE_ULONGLONG(0);
    clouds_ = 0;
    fog_ = 0;
    wind_ = 0;
    rain_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Environment::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 dateTime = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &datetime_)));
          set_has_datetime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_clouds;
        break;
      }

      // required float clouds = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_clouds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &clouds_)));
          set_has_clouds();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_fog;
        break;
      }

      // required float fog = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_fog:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &fog_)));
          set_has_fog();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_wind;
        break;
      }

      // required float wind = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_wind:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &wind_)));
          set_has_wind();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_rain;
        break;
      }

      // required float rain = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_rain:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &rain_)));
          set_has_rain();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Environment::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 dateTime = 1;
  if (has_datetime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->datetime(), output);
  }

  // required float clouds = 2;
  if (has_clouds()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->clouds(), output);
  }

  // required float fog = 3;
  if (has_fog()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->fog(), output);
  }

  // required float wind = 4;
  if (has_wind()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->wind(), output);
  }

  // required float rain = 5;
  if (has_rain()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->rain(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Environment::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 dateTime = 1;
  if (has_datetime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->datetime(), target);
  }

  // required float clouds = 2;
  if (has_clouds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->clouds(), target);
  }

  // required float fog = 3;
  if (has_fog()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->fog(), target);
  }

  // required float wind = 4;
  if (has_wind()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->wind(), target);
  }

  // required float rain = 5;
  if (has_rain()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->rain(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Environment::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 dateTime = 1;
    if (has_datetime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->datetime());
    }

    // required float clouds = 2;
    if (has_clouds()) {
      total_size += 1 + 4;
    }

    // required float fog = 3;
    if (has_fog()) {
      total_size += 1 + 4;
    }

    // required float wind = 4;
    if (has_wind()) {
      total_size += 1 + 4;
    }

    // required float rain = 5;
    if (has_rain()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Environment::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Environment* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Environment*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Environment::MergeFrom(const Environment& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_datetime()) {
      set_datetime(from.datetime());
    }
    if (from.has_clouds()) {
      set_clouds(from.clouds());
    }
    if (from.has_fog()) {
      set_fog(from.fog());
    }
    if (from.has_wind()) {
      set_wind(from.wind());
    }
    if (from.has_rain()) {
      set_rain(from.rain());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Environment::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Environment::CopyFrom(const Environment& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Environment::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void Environment::Swap(Environment* other) {
  if (other != this) {
    std::swap(datetime_, other->datetime_);
    std::swap(clouds_, other->clouds_);
    std::swap(fog_, other->fog_);
    std::swap(wind_, other->wind_);
    std::swap(rain_, other->rain_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Environment::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Environment_descriptor_;
  metadata.reflection = Environment_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Corpse::kParentIDFieldNumber;
#endif  // !_MSC_VER

Corpse::Corpse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Corpse::InitAsDefaultInstance() {
}

Corpse::Corpse(const Corpse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Corpse::SharedCtor() {
  _cached_size_ = 0;
  parentid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Corpse::~Corpse() {
  SharedDtor();
}

void Corpse::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Corpse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Corpse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Corpse_descriptor_;
}

const Corpse& Corpse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

Corpse* Corpse::default_instance_ = NULL;

Corpse* Corpse::New() const {
  return new Corpse;
}

void Corpse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    parentid_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Corpse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 parentID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &parentid_)));
          set_has_parentid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Corpse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 parentID = 1;
  if (has_parentid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->parentid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Corpse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 parentID = 1;
  if (has_parentid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->parentid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Corpse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 parentID = 1;
    if (has_parentid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->parentid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Corpse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Corpse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Corpse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Corpse::MergeFrom(const Corpse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_parentid()) {
      set_parentid(from.parentid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Corpse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Corpse::CopyFrom(const Corpse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Corpse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Corpse::Swap(Corpse* other) {
  if (other != this) {
    std::swap(parentid_, other->parentid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Corpse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Corpse_descriptor_;
  metadata.reflection = Corpse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ParentInfo::kUidFieldNumber;
const int ParentInfo::kBoneFieldNumber;
#endif  // !_MSC_VER

ParentInfo::ParentInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ParentInfo::InitAsDefaultInstance() {
}

ParentInfo::ParentInfo(const ParentInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ParentInfo::SharedCtor() {
  _cached_size_ = 0;
  uid_ = 0u;
  bone_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ParentInfo::~ParentInfo() {
  SharedDtor();
}

void ParentInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ParentInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ParentInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ParentInfo_descriptor_;
}

const ParentInfo& ParentInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

ParentInfo* ParentInfo::default_instance_ = NULL;

ParentInfo* ParentInfo::New() const {
  return new ParentInfo;
}

void ParentInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    uid_ = 0u;
    bone_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ParentInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 uid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uid_)));
          set_has_uid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_bone;
        break;
      }

      // required uint32 bone = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_bone:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bone_)));
          set_has_bone();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ParentInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 uid = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->uid(), output);
  }

  // required uint32 bone = 2;
  if (has_bone()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->bone(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ParentInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 uid = 1;
  if (has_uid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->uid(), target);
  }

  // required uint32 bone = 2;
  if (has_bone()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->bone(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ParentInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 uid = 1;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uid());
    }

    // required uint32 bone = 2;
    if (has_bone()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->bone());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ParentInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ParentInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ParentInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ParentInfo::MergeFrom(const ParentInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      set_uid(from.uid());
    }
    if (from.has_bone()) {
      set_bone(from.bone());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ParentInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ParentInfo::CopyFrom(const ParentInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ParentInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ParentInfo::Swap(ParentInfo* other) {
  if (other != this) {
    std::swap(uid_, other->uid_);
    std::swap(bone_, other->bone_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ParentInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ParentInfo_descriptor_;
  metadata.reflection = ParentInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int KeyLock::kCodeFieldNumber;
#endif  // !_MSC_VER

KeyLock::KeyLock()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void KeyLock::InitAsDefaultInstance() {
}

KeyLock::KeyLock(const KeyLock& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void KeyLock::SharedCtor() {
  _cached_size_ = 0;
  code_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

KeyLock::~KeyLock() {
  SharedDtor();
}

void KeyLock::SharedDtor() {
  if (this != default_instance_) {
  }
}

void KeyLock::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* KeyLock::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KeyLock_descriptor_;
}

const KeyLock& KeyLock::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

KeyLock* KeyLock::default_instance_ = NULL;

KeyLock* KeyLock::New() const {
  return new KeyLock;
}

void KeyLock::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    code_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool KeyLock::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void KeyLock::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->code(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* KeyLock::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 code = 1;
  if (has_code()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->code(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int KeyLock::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->code());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void KeyLock::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const KeyLock* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const KeyLock*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void KeyLock::MergeFrom(const KeyLock& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_code()) {
      set_code(from.code());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void KeyLock::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void KeyLock::CopyFrom(const KeyLock& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyLock::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void KeyLock::Swap(KeyLock* other) {
  if (other != this) {
    std::swap(code_, other->code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata KeyLock::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = KeyLock_descriptor_;
  metadata.reflection = KeyLock_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CodeLock_Private::kCodeFieldNumber;
const int CodeLock_Private::kUsersFieldNumber;
const int CodeLock_Private::kGuestsFieldNumber;
const int CodeLock_Private::kGuestCodeFieldNumber;
const int CodeLock_Private::kGuestUsersFieldNumber;
#endif  // !_MSC_VER

CodeLock_Private::CodeLock_Private()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CodeLock_Private::InitAsDefaultInstance() {
}

CodeLock_Private::CodeLock_Private(const CodeLock_Private& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CodeLock_Private::SharedCtor() {
  _cached_size_ = 0;
  code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  guestcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CodeLock_Private::~CodeLock_Private() {
  SharedDtor();
}

void CodeLock_Private::SharedDtor() {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    delete code_;
  }
  if (guestcode_ != &::google::protobuf::internal::kEmptyString) {
    delete guestcode_;
  }
  if (this != default_instance_) {
  }
}

void CodeLock_Private::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CodeLock_Private::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CodeLock_Private_descriptor_;
}

const CodeLock_Private& CodeLock_Private::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

CodeLock_Private* CodeLock_Private::default_instance_ = NULL;

CodeLock_Private* CodeLock_Private::New() const {
  return new CodeLock_Private;
}

void CodeLock_Private::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_code()) {
      if (code_ != &::google::protobuf::internal::kEmptyString) {
        code_->clear();
      }
    }
    if (has_guestcode()) {
      if (guestcode_ != &::google::protobuf::internal::kEmptyString) {
        guestcode_->clear();
      }
    }
  }
  users_.Clear();
  guests_.Clear();
  guestusers_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CodeLock_Private::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_code()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->code().data(), this->code().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_users;
        break;
      }

      // repeated uint64 users = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_users:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 16, input, this->mutable_users())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_users())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_users;
        if (input->ExpectTag(24)) goto parse_guests;
        break;
      }

      // repeated uint64 guests = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_guests:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 24, input, this->mutable_guests())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_guests())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_guests;
        if (input->ExpectTag(34)) goto parse_guestCode;
        break;
      }

      // optional string guestCode = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_guestCode:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_guestcode()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->guestcode().data(), this->guestcode().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_guestUsers;
        break;
      }

      // repeated uint64 guestUsers = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_guestUsers:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 40, input, this->mutable_guestusers())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_guestusers())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_guestUsers;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CodeLock_Private::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->code().data(), this->code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->code(), output);
  }

  // repeated uint64 users = 2;
  for (int i = 0; i < this->users_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(
      2, this->users(i), output);
  }

  // repeated uint64 guests = 3;
  for (int i = 0; i < this->guests_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(
      3, this->guests(i), output);
  }

  // optional string guestCode = 4;
  if (has_guestcode()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->guestcode().data(), this->guestcode().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->guestcode(), output);
  }

  // repeated uint64 guestUsers = 5;
  for (int i = 0; i < this->guestusers_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(
      5, this->guestusers(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CodeLock_Private::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->code().data(), this->code().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->code(), target);
  }

  // repeated uint64 users = 2;
  for (int i = 0; i < this->users_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt64ToArray(2, this->users(i), target);
  }

  // repeated uint64 guests = 3;
  for (int i = 0; i < this->guests_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt64ToArray(3, this->guests(i), target);
  }

  // optional string guestCode = 4;
  if (has_guestcode()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->guestcode().data(), this->guestcode().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->guestcode(), target);
  }

  // repeated uint64 guestUsers = 5;
  for (int i = 0; i < this->guestusers_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt64ToArray(5, this->guestusers(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CodeLock_Private::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->code());
    }

    // optional string guestCode = 4;
    if (has_guestcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->guestcode());
    }

  }
  // repeated uint64 users = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->users_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt64Size(this->users(i));
    }
    total_size += 1 * this->users_size() + data_size;
  }

  // repeated uint64 guests = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->guests_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt64Size(this->guests(i));
    }
    total_size += 1 * this->guests_size() + data_size;
  }

  // repeated uint64 guestUsers = 5;
  {
    int data_size = 0;
    for (int i = 0; i < this->guestusers_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt64Size(this->guestusers(i));
    }
    total_size += 1 * this->guestusers_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CodeLock_Private::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CodeLock_Private* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CodeLock_Private*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CodeLock_Private::MergeFrom(const CodeLock_Private& from) {
  GOOGLE_CHECK_NE(&from, this);
  users_.MergeFrom(from.users_);
  guests_.MergeFrom(from.guests_);
  guestusers_.MergeFrom(from.guestusers_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_code()) {
      set_code(from.code());
    }
    if (from.has_guestcode()) {
      set_guestcode(from.guestcode());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CodeLock_Private::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CodeLock_Private::CopyFrom(const CodeLock_Private& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CodeLock_Private::IsInitialized() const {

  return true;
}

void CodeLock_Private::Swap(CodeLock_Private* other) {
  if (other != this) {
    std::swap(code_, other->code_);
    users_.Swap(&other->users_);
    guests_.Swap(&other->guests_);
    std::swap(guestcode_, other->guestcode_);
    guestusers_.Swap(&other->guestusers_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CodeLock_Private::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CodeLock_Private_descriptor_;
  metadata.reflection = CodeLock_Private_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int CodeLock::kPvFieldNumber;
const int CodeLock::kHasCodeFieldNumber;
const int CodeLock::kHasGuestCodeFieldNumber;
#endif  // !_MSC_VER

CodeLock::CodeLock()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CodeLock::InitAsDefaultInstance() {
  pv_ = const_cast< ::CodeLock_Private*>(&::CodeLock_Private::default_instance());
}

CodeLock::CodeLock(const CodeLock& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CodeLock::SharedCtor() {
  _cached_size_ = 0;
  pv_ = NULL;
  hascode_ = false;
  hasguestcode_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CodeLock::~CodeLock() {
  SharedDtor();
}

void CodeLock::SharedDtor() {
  if (this != default_instance_) {
    delete pv_;
  }
}

void CodeLock::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CodeLock::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CodeLock_descriptor_;
}

const CodeLock& CodeLock::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

CodeLock* CodeLock::default_instance_ = NULL;

CodeLock* CodeLock::New() const {
  return new CodeLock;
}

void CodeLock::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_pv()) {
      if (pv_ != NULL) pv_->::CodeLock_Private::Clear();
    }
    hascode_ = false;
    hasguestcode_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CodeLock::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CodeLock.Private pv = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pv()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_hasCode;
        break;
      }

      // required bool hasCode = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_hasCode:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &hascode_)));
          set_has_hascode();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_hasGuestCode;
        break;
      }

      // required bool hasGuestCode = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_hasGuestCode:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &hasguestcode_)));
          set_has_hasguestcode();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CodeLock::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .CodeLock.Private pv = 1;
  if (has_pv()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->pv(), output);
  }

  // required bool hasCode = 2;
  if (has_hascode()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->hascode(), output);
  }

  // required bool hasGuestCode = 3;
  if (has_hasguestcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->hasguestcode(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CodeLock::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .CodeLock.Private pv = 1;
  if (has_pv()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->pv(), target);
  }

  // required bool hasCode = 2;
  if (has_hascode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->hascode(), target);
  }

  // required bool hasGuestCode = 3;
  if (has_hasguestcode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->hasguestcode(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CodeLock::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .CodeLock.Private pv = 1;
    if (has_pv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->pv());
    }

    // required bool hasCode = 2;
    if (has_hascode()) {
      total_size += 1 + 1;
    }

    // required bool hasGuestCode = 3;
    if (has_hasguestcode()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CodeLock::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CodeLock* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CodeLock*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CodeLock::MergeFrom(const CodeLock& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pv()) {
      mutable_pv()->::CodeLock_Private::MergeFrom(from.pv());
    }
    if (from.has_hascode()) {
      set_hascode(from.hascode());
    }
    if (from.has_hasguestcode()) {
      set_hasguestcode(from.hasguestcode());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CodeLock::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CodeLock::CopyFrom(const CodeLock& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CodeLock::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;

  return true;
}

void CodeLock::Swap(CodeLock* other) {
  if (other != this) {
    std::swap(pv_, other->pv_);
    std::swap(hascode_, other->hascode_);
    std::swap(hasguestcode_, other->hasguestcode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CodeLock::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CodeLock_descriptor_;
  metadata.reflection = CodeLock_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EntitySlots::kSlotLockFieldNumber;
const int EntitySlots::kSlotFireModFieldNumber;
const int EntitySlots::kSlotUpperModificationFieldNumber;
#endif  // !_MSC_VER

EntitySlots::EntitySlots()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void EntitySlots::InitAsDefaultInstance() {
}

EntitySlots::EntitySlots(const EntitySlots& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void EntitySlots::SharedCtor() {
  _cached_size_ = 0;
  slotlock_ = 0u;
  slotfiremod_ = 0u;
  slotuppermodification_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EntitySlots::~EntitySlots() {
  SharedDtor();
}

void EntitySlots::SharedDtor() {
  if (this != default_instance_) {
  }
}

void EntitySlots::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EntitySlots::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EntitySlots_descriptor_;
}

const EntitySlots& EntitySlots::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

EntitySlots* EntitySlots::default_instance_ = NULL;

EntitySlots* EntitySlots::New() const {
  return new EntitySlots;
}

void EntitySlots::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    slotlock_ = 0u;
    slotfiremod_ = 0u;
    slotuppermodification_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EntitySlots::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 slotLock = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &slotlock_)));
          set_has_slotlock();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_slotFireMod;
        break;
      }

      // required uint32 slotFireMod = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_slotFireMod:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &slotfiremod_)));
          set_has_slotfiremod();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_slotUpperModification;
        break;
      }

      // required uint32 slotUpperModification = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_slotUpperModification:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &slotuppermodification_)));
          set_has_slotuppermodification();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EntitySlots::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 slotLock = 1;
  if (has_slotlock()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->slotlock(), output);
  }

  // required uint32 slotFireMod = 2;
  if (has_slotfiremod()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->slotfiremod(), output);
  }

  // required uint32 slotUpperModification = 3;
  if (has_slotuppermodification()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->slotuppermodification(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* EntitySlots::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 slotLock = 1;
  if (has_slotlock()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->slotlock(), target);
  }

  // required uint32 slotFireMod = 2;
  if (has_slotfiremod()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->slotfiremod(), target);
  }

  // required uint32 slotUpperModification = 3;
  if (has_slotuppermodification()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->slotuppermodification(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int EntitySlots::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 slotLock = 1;
    if (has_slotlock()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->slotlock());
    }

    // required uint32 slotFireMod = 2;
    if (has_slotfiremod()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->slotfiremod());
    }

    // required uint32 slotUpperModification = 3;
    if (has_slotuppermodification()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->slotuppermodification());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EntitySlots::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EntitySlots* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EntitySlots*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EntitySlots::MergeFrom(const EntitySlots& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slotlock()) {
      set_slotlock(from.slotlock());
    }
    if (from.has_slotfiremod()) {
      set_slotfiremod(from.slotfiremod());
    }
    if (from.has_slotuppermodification()) {
      set_slotuppermodification(from.slotuppermodification());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EntitySlots::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EntitySlots::CopyFrom(const EntitySlots& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EntitySlots::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void EntitySlots::Swap(EntitySlots* other) {
  if (other != this) {
    std::swap(slotlock_, other->slotlock_);
    std::swap(slotfiremod_, other->slotfiremod_);
    std::swap(slotuppermodification_, other->slotuppermodification_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EntitySlots::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EntitySlots_descriptor_;
  metadata.reflection = EntitySlots_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PlayerNameID::kUsernameFieldNumber;
const int PlayerNameID::kUseridFieldNumber;
#endif  // !_MSC_VER

PlayerNameID::PlayerNameID()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PlayerNameID::InitAsDefaultInstance() {
}

PlayerNameID::PlayerNameID(const PlayerNameID& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PlayerNameID::SharedCtor() {
  _cached_size_ = 0;
  username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  userid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlayerNameID::~PlayerNameID() {
  SharedDtor();
}

void PlayerNameID::SharedDtor() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (this != default_instance_) {
  }
}

void PlayerNameID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PlayerNameID::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PlayerNameID_descriptor_;
}

const PlayerNameID& PlayerNameID::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

PlayerNameID* PlayerNameID::default_instance_ = NULL;

PlayerNameID* PlayerNameID::New() const {
  return new PlayerNameID;
}

void PlayerNameID::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_username()) {
      if (username_ != &::google::protobuf::internal::kEmptyString) {
        username_->clear();
      }
    }
    userid_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PlayerNameID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string username = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_username()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->username().data(), this->username().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_userid;
        break;
      }

      // required uint64 userid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_userid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &userid_)));
          set_has_userid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PlayerNameID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string username = 1;
  if (has_username()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->username().data(), this->username().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->username(), output);
  }

  // required uint64 userid = 2;
  if (has_userid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->userid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PlayerNameID::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string username = 1;
  if (has_username()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->username().data(), this->username().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->username(), target);
  }

  // required uint64 userid = 2;
  if (has_userid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->userid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PlayerNameID::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string username = 1;
    if (has_username()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->username());
    }

    // required uint64 userid = 2;
    if (has_userid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->userid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlayerNameID::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PlayerNameID* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PlayerNameID*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PlayerNameID::MergeFrom(const PlayerNameID& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_username()) {
      set_username(from.username());
    }
    if (from.has_userid()) {
      set_userid(from.userid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PlayerNameID::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PlayerNameID::CopyFrom(const PlayerNameID& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerNameID::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void PlayerNameID::Swap(PlayerNameID* other) {
  if (other != this) {
    std::swap(username_, other->username_);
    std::swap(userid_, other->userid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PlayerNameID::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PlayerNameID_descriptor_;
  metadata.reflection = PlayerNameID_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BuildingPrivilege::kUsersFieldNumber;
#endif  // !_MSC_VER

BuildingPrivilege::BuildingPrivilege()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void BuildingPrivilege::InitAsDefaultInstance() {
}

BuildingPrivilege::BuildingPrivilege(const BuildingPrivilege& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void BuildingPrivilege::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BuildingPrivilege::~BuildingPrivilege() {
  SharedDtor();
}

void BuildingPrivilege::SharedDtor() {
  if (this != default_instance_) {
  }
}

void BuildingPrivilege::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BuildingPrivilege::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BuildingPrivilege_descriptor_;
}

const BuildingPrivilege& BuildingPrivilege::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

BuildingPrivilege* BuildingPrivilege::default_instance_ = NULL;

BuildingPrivilege* BuildingPrivilege::New() const {
  return new BuildingPrivilege;
}

void BuildingPrivilege::Clear() {
  users_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BuildingPrivilege::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .PlayerNameID users = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_users:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_users()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_users;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BuildingPrivilege::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .PlayerNameID users = 1;
  for (int i = 0; i < this->users_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->users(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* BuildingPrivilege::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .PlayerNameID users = 1;
  for (int i = 0; i < this->users_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->users(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int BuildingPrivilege::ByteSize() const {
  int total_size = 0;

  // repeated .PlayerNameID users = 1;
  total_size += 1 * this->users_size();
  for (int i = 0; i < this->users_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->users(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BuildingPrivilege::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BuildingPrivilege* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BuildingPrivilege*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BuildingPrivilege::MergeFrom(const BuildingPrivilege& from) {
  GOOGLE_CHECK_NE(&from, this);
  users_.MergeFrom(from.users_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BuildingPrivilege::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BuildingPrivilege::CopyFrom(const BuildingPrivilege& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BuildingPrivilege::IsInitialized() const {

  for (int i = 0; i < users_size(); i++) {
    if (!this->users(i).IsInitialized()) return false;
  }
  return true;
}

void BuildingPrivilege::Swap(BuildingPrivilege* other) {
  if (other != this) {
    users_.Swap(&other->users_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BuildingPrivilege::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BuildingPrivilege_descriptor_;
  metadata.reflection = BuildingPrivilege_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int StorageBox::kContentsFieldNumber;
#endif  // !_MSC_VER

StorageBox::StorageBox()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void StorageBox::InitAsDefaultInstance() {
  contents_ = const_cast< ::ItemContainer*>(&::ItemContainer::default_instance());
}

StorageBox::StorageBox(const StorageBox& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void StorageBox::SharedCtor() {
  _cached_size_ = 0;
  contents_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StorageBox::~StorageBox() {
  SharedDtor();
}

void StorageBox::SharedDtor() {
  if (this != default_instance_) {
    delete contents_;
  }
}

void StorageBox::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StorageBox::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StorageBox_descriptor_;
}

const StorageBox& StorageBox::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

StorageBox* StorageBox::default_instance_ = NULL;

StorageBox* StorageBox::New() const {
  return new StorageBox;
}

void StorageBox::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_contents()) {
      if (contents_ != NULL) contents_->::ItemContainer::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool StorageBox::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ItemContainer contents = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_contents()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StorageBox::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .ItemContainer contents = 1;
  if (has_contents()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->contents(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* StorageBox::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .ItemContainer contents = 1;
  if (has_contents()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->contents(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int StorageBox::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ItemContainer contents = 1;
    if (has_contents()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->contents());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StorageBox::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const StorageBox* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const StorageBox*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void StorageBox::MergeFrom(const StorageBox& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_contents()) {
      mutable_contents()->::ItemContainer::MergeFrom(from.contents());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void StorageBox::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StorageBox::CopyFrom(const StorageBox& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StorageBox::IsInitialized() const {

  if (has_contents()) {
    if (!this->contents().IsInitialized()) return false;
  }
  return true;
}

void StorageBox::Swap(StorageBox* other) {
  if (other != this) {
    std::swap(contents_, other->contents_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata StorageBox::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StorageBox_descriptor_;
  metadata.reflection = StorageBox_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int HeldEntity::kItemUIDFieldNumber;
#endif  // !_MSC_VER

HeldEntity::HeldEntity()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void HeldEntity::InitAsDefaultInstance() {
}

HeldEntity::HeldEntity(const HeldEntity& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void HeldEntity::SharedCtor() {
  _cached_size_ = 0;
  itemuid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HeldEntity::~HeldEntity() {
  SharedDtor();
}

void HeldEntity::SharedDtor() {
  if (this != default_instance_) {
  }
}

void HeldEntity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HeldEntity::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HeldEntity_descriptor_;
}

const HeldEntity& HeldEntity::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

HeldEntity* HeldEntity::default_instance_ = NULL;

HeldEntity* HeldEntity::New() const {
  return new HeldEntity;
}

void HeldEntity::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    itemuid_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HeldEntity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 itemUID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &itemuid_)));
          set_has_itemuid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HeldEntity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 itemUID = 1;
  if (has_itemuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->itemuid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* HeldEntity::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 itemUID = 1;
  if (has_itemuid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->itemuid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int HeldEntity::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 itemUID = 1;
    if (has_itemuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->itemuid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HeldEntity::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HeldEntity* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HeldEntity*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HeldEntity::MergeFrom(const HeldEntity& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_itemuid()) {
      set_itemuid(from.itemuid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HeldEntity::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HeldEntity::CopyFrom(const HeldEntity& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeldEntity::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void HeldEntity::Swap(HeldEntity* other) {
  if (other != this) {
    std::swap(itemuid_, other->itemuid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HeldEntity::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HeldEntity_descriptor_;
  metadata.reflection = HeldEntity_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Magazine::kCapacityFieldNumber;
const int Magazine::kContentsFieldNumber;
const int Magazine::kAmmoTypeFieldNumber;
#endif  // !_MSC_VER

Magazine::Magazine()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Magazine::InitAsDefaultInstance() {
}

Magazine::Magazine(const Magazine& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Magazine::SharedCtor() {
  _cached_size_ = 0;
  capacity_ = GOOGLE_ULONGLONG(0);
  contents_ = GOOGLE_ULONGLONG(0);
  ammotype_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Magazine::~Magazine() {
  SharedDtor();
}

void Magazine::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Magazine::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Magazine::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Magazine_descriptor_;
}

const Magazine& Magazine::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

Magazine* Magazine::default_instance_ = NULL;

Magazine* Magazine::New() const {
  return new Magazine;
}

void Magazine::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    capacity_ = GOOGLE_ULONGLONG(0);
    contents_ = GOOGLE_ULONGLONG(0);
    ammotype_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Magazine::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 capacity = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &capacity_)));
          set_has_capacity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_contents;
        break;
      }

      // required uint64 contents = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_contents:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &contents_)));
          set_has_contents();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_ammoType;
        break;
      }

      // required uint64 ammoType = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ammoType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ammotype_)));
          set_has_ammotype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Magazine::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 capacity = 1;
  if (has_capacity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->capacity(), output);
  }

  // required uint64 contents = 2;
  if (has_contents()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->contents(), output);
  }

  // required uint64 ammoType = 3;
  if (has_ammotype()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->ammotype(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Magazine::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 capacity = 1;
  if (has_capacity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->capacity(), target);
  }

  // required uint64 contents = 2;
  if (has_contents()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->contents(), target);
  }

  // required uint64 ammoType = 3;
  if (has_ammotype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->ammotype(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Magazine::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 capacity = 1;
    if (has_capacity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->capacity());
    }

    // required uint64 contents = 2;
    if (has_contents()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->contents());
    }

    // required uint64 ammoType = 3;
    if (has_ammotype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->ammotype());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Magazine::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Magazine* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Magazine*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Magazine::MergeFrom(const Magazine& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_capacity()) {
      set_capacity(from.capacity());
    }
    if (from.has_contents()) {
      set_contents(from.contents());
    }
    if (from.has_ammotype()) {
      set_ammotype(from.ammotype());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Magazine::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Magazine::CopyFrom(const Magazine& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Magazine::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void Magazine::Swap(Magazine* other) {
  if (other != this) {
    std::swap(capacity_, other->capacity_);
    std::swap(contents_, other->contents_);
    std::swap(ammotype_, other->ammotype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Magazine::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Magazine_descriptor_;
  metadata.reflection = Magazine_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BaseProjectile::kPrimaryMagazineFieldNumber;
#endif  // !_MSC_VER

BaseProjectile::BaseProjectile()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void BaseProjectile::InitAsDefaultInstance() {
  primarymagazine_ = const_cast< ::Magazine*>(&::Magazine::default_instance());
}

BaseProjectile::BaseProjectile(const BaseProjectile& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void BaseProjectile::SharedCtor() {
  _cached_size_ = 0;
  primarymagazine_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BaseProjectile::~BaseProjectile() {
  SharedDtor();
}

void BaseProjectile::SharedDtor() {
  if (this != default_instance_) {
    delete primarymagazine_;
  }
}

void BaseProjectile::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BaseProjectile::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BaseProjectile_descriptor_;
}

const BaseProjectile& BaseProjectile::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

BaseProjectile* BaseProjectile::default_instance_ = NULL;

BaseProjectile* BaseProjectile::New() const {
  return new BaseProjectile;
}

void BaseProjectile::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_primarymagazine()) {
      if (primarymagazine_ != NULL) primarymagazine_->::Magazine::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BaseProjectile::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Magazine primaryMagazine = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_primarymagazine()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BaseProjectile::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Magazine primaryMagazine = 1;
  if (has_primarymagazine()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->primarymagazine(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* BaseProjectile::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .Magazine primaryMagazine = 1;
  if (has_primarymagazine()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->primarymagazine(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int BaseProjectile::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Magazine primaryMagazine = 1;
    if (has_primarymagazine()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->primarymagazine());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BaseProjectile::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BaseProjectile* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BaseProjectile*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BaseProjectile::MergeFrom(const BaseProjectile& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_primarymagazine()) {
      mutable_primarymagazine()->::Magazine::MergeFrom(from.primarymagazine());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BaseProjectile::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BaseProjectile::CopyFrom(const BaseProjectile& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BaseProjectile::IsInitialized() const {

  if (has_primarymagazine()) {
    if (!this->primarymagazine().IsInitialized()) return false;
  }
  return true;
}

void BaseProjectile::Swap(BaseProjectile* other) {
  if (other != this) {
    std::swap(primarymagazine_, other->primarymagazine_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BaseProjectile::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BaseProjectile_descriptor_;
  metadata.reflection = BaseProjectile_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BaseNPC::kFlagsFieldNumber;
#endif  // !_MSC_VER

BaseNPC::BaseNPC()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void BaseNPC::InitAsDefaultInstance() {
}

BaseNPC::BaseNPC(const BaseNPC& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void BaseNPC::SharedCtor() {
  _cached_size_ = 0;
  flags_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BaseNPC::~BaseNPC() {
  SharedDtor();
}

void BaseNPC::SharedDtor() {
  if (this != default_instance_) {
  }
}

void BaseNPC::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BaseNPC::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BaseNPC_descriptor_;
}

const BaseNPC& BaseNPC::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

BaseNPC* BaseNPC::default_instance_ = NULL;

BaseNPC* BaseNPC::New() const {
  return new BaseNPC;
}

void BaseNPC::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    flags_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BaseNPC::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 flags = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &flags_)));
          set_has_flags();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BaseNPC::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 flags = 2;
  if (has_flags()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->flags(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* BaseNPC::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 flags = 2;
  if (has_flags()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->flags(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int BaseNPC::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 flags = 2;
    if (has_flags()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->flags());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BaseNPC::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BaseNPC* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BaseNPC*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BaseNPC::MergeFrom(const BaseNPC& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_flags()) {
      set_flags(from.flags());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BaseNPC::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BaseNPC::CopyFrom(const BaseNPC& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BaseNPC::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void BaseNPC::Swap(BaseNPC* other) {
  if (other != this) {
    std::swap(flags_, other->flags_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BaseNPC::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BaseNPC_descriptor_;
  metadata.reflection = BaseNPC_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Loot::kContentsFieldNumber;
#endif  // !_MSC_VER

Loot::Loot()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Loot::InitAsDefaultInstance() {
  contents_ = const_cast< ::ItemContainer*>(&::ItemContainer::default_instance());
}

Loot::Loot(const Loot& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Loot::SharedCtor() {
  _cached_size_ = 0;
  contents_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Loot::~Loot() {
  SharedDtor();
}

void Loot::SharedDtor() {
  if (this != default_instance_) {
    delete contents_;
  }
}

void Loot::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Loot::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Loot_descriptor_;
}

const Loot& Loot::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

Loot* Loot::default_instance_ = NULL;

Loot* Loot::New() const {
  return new Loot;
}

void Loot::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_contents()) {
      if (contents_ != NULL) contents_->::ItemContainer::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Loot::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ItemContainer contents = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_contents()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Loot::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .ItemContainer contents = 1;
  if (has_contents()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->contents(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Loot::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .ItemContainer contents = 1;
  if (has_contents()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->contents(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Loot::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ItemContainer contents = 1;
    if (has_contents()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->contents());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Loot::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Loot* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Loot*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Loot::MergeFrom(const Loot& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_contents()) {
      mutable_contents()->::ItemContainer::MergeFrom(from.contents());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Loot::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Loot::CopyFrom(const Loot& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Loot::IsInitialized() const {

  if (has_contents()) {
    if (!this->contents().IsInitialized()) return false;
  }
  return true;
}

void Loot::Swap(Loot* other) {
  if (other != this) {
    std::swap(contents_, other->contents_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Loot::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Loot_descriptor_;
  metadata.reflection = Loot_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GenericSpawner_SpawnedEnt::kUidFieldNumber;
const int GenericSpawner_SpawnedEnt::kSpawnPointIndexFieldNumber;
const int GenericSpawner_SpawnedEnt::kMobileFieldNumber;
#endif  // !_MSC_VER

GenericSpawner_SpawnedEnt::GenericSpawner_SpawnedEnt()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GenericSpawner_SpawnedEnt::InitAsDefaultInstance() {
}

GenericSpawner_SpawnedEnt::GenericSpawner_SpawnedEnt(const GenericSpawner_SpawnedEnt& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GenericSpawner_SpawnedEnt::SharedCtor() {
  _cached_size_ = 0;
  uid_ = 0u;
  spawnpointindex_ = 0u;
  mobile_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GenericSpawner_SpawnedEnt::~GenericSpawner_SpawnedEnt() {
  SharedDtor();
}

void GenericSpawner_SpawnedEnt::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GenericSpawner_SpawnedEnt::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GenericSpawner_SpawnedEnt::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GenericSpawner_SpawnedEnt_descriptor_;
}

const GenericSpawner_SpawnedEnt& GenericSpawner_SpawnedEnt::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

GenericSpawner_SpawnedEnt* GenericSpawner_SpawnedEnt::default_instance_ = NULL;

GenericSpawner_SpawnedEnt* GenericSpawner_SpawnedEnt::New() const {
  return new GenericSpawner_SpawnedEnt;
}

void GenericSpawner_SpawnedEnt::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    uid_ = 0u;
    spawnpointindex_ = 0u;
    mobile_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GenericSpawner_SpawnedEnt::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 uid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uid_)));
          set_has_uid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_spawnPointIndex;
        break;
      }

      // required uint32 spawnPointIndex = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_spawnPointIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &spawnpointindex_)));
          set_has_spawnpointindex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_mobile;
        break;
      }

      // required bool mobile = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mobile:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &mobile_)));
          set_has_mobile();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GenericSpawner_SpawnedEnt::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 uid = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->uid(), output);
  }

  // required uint32 spawnPointIndex = 2;
  if (has_spawnpointindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->spawnpointindex(), output);
  }

  // required bool mobile = 3;
  if (has_mobile()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->mobile(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GenericSpawner_SpawnedEnt::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 uid = 1;
  if (has_uid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->uid(), target);
  }

  // required uint32 spawnPointIndex = 2;
  if (has_spawnpointindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->spawnpointindex(), target);
  }

  // required bool mobile = 3;
  if (has_mobile()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->mobile(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GenericSpawner_SpawnedEnt::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 uid = 1;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uid());
    }

    // required uint32 spawnPointIndex = 2;
    if (has_spawnpointindex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->spawnpointindex());
    }

    // required bool mobile = 3;
    if (has_mobile()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GenericSpawner_SpawnedEnt::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GenericSpawner_SpawnedEnt* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GenericSpawner_SpawnedEnt*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GenericSpawner_SpawnedEnt::MergeFrom(const GenericSpawner_SpawnedEnt& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      set_uid(from.uid());
    }
    if (from.has_spawnpointindex()) {
      set_spawnpointindex(from.spawnpointindex());
    }
    if (from.has_mobile()) {
      set_mobile(from.mobile());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GenericSpawner_SpawnedEnt::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GenericSpawner_SpawnedEnt::CopyFrom(const GenericSpawner_SpawnedEnt& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GenericSpawner_SpawnedEnt::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void GenericSpawner_SpawnedEnt::Swap(GenericSpawner_SpawnedEnt* other) {
  if (other != this) {
    std::swap(uid_, other->uid_);
    std::swap(spawnpointindex_, other->spawnpointindex_);
    std::swap(mobile_, other->mobile_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GenericSpawner_SpawnedEnt::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GenericSpawner_SpawnedEnt_descriptor_;
  metadata.reflection = GenericSpawner_SpawnedEnt_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int GenericSpawner::kEntsFieldNumber;
#endif  // !_MSC_VER

GenericSpawner::GenericSpawner()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GenericSpawner::InitAsDefaultInstance() {
}

GenericSpawner::GenericSpawner(const GenericSpawner& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GenericSpawner::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GenericSpawner::~GenericSpawner() {
  SharedDtor();
}

void GenericSpawner::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GenericSpawner::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GenericSpawner::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GenericSpawner_descriptor_;
}

const GenericSpawner& GenericSpawner::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

GenericSpawner* GenericSpawner::default_instance_ = NULL;

GenericSpawner* GenericSpawner::New() const {
  return new GenericSpawner;
}

void GenericSpawner::Clear() {
  ents_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GenericSpawner::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .GenericSpawner.SpawnedEnt ents = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ents:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_ents()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_ents;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GenericSpawner::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .GenericSpawner.SpawnedEnt ents = 1;
  for (int i = 0; i < this->ents_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->ents(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GenericSpawner::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .GenericSpawner.SpawnedEnt ents = 1;
  for (int i = 0; i < this->ents_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->ents(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GenericSpawner::ByteSize() const {
  int total_size = 0;

  // repeated .GenericSpawner.SpawnedEnt ents = 1;
  total_size += 1 * this->ents_size();
  for (int i = 0; i < this->ents_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->ents(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GenericSpawner::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GenericSpawner* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GenericSpawner*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GenericSpawner::MergeFrom(const GenericSpawner& from) {
  GOOGLE_CHECK_NE(&from, this);
  ents_.MergeFrom(from.ents_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GenericSpawner::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GenericSpawner::CopyFrom(const GenericSpawner& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GenericSpawner::IsInitialized() const {

  for (int i = 0; i < ents_size(); i++) {
    if (!this->ents(i).IsInitialized()) return false;
  }
  return true;
}

void GenericSpawner::Swap(GenericSpawner* other) {
  if (other != this) {
    ents_.Swap(&other->ents_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GenericSpawner::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GenericSpawner_descriptor_;
  metadata.reflection = GenericSpawner_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SleepingBag_Private::kDeployerIDFieldNumber;
const int SleepingBag_Private::kDeployerNameFieldNumber;
#endif  // !_MSC_VER

SleepingBag_Private::SleepingBag_Private()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SleepingBag_Private::InitAsDefaultInstance() {
}

SleepingBag_Private::SleepingBag_Private(const SleepingBag_Private& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SleepingBag_Private::SharedCtor() {
  _cached_size_ = 0;
  deployerid_ = GOOGLE_ULONGLONG(0);
  deployername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SleepingBag_Private::~SleepingBag_Private() {
  SharedDtor();
}

void SleepingBag_Private::SharedDtor() {
  if (deployername_ != &::google::protobuf::internal::kEmptyString) {
    delete deployername_;
  }
  if (this != default_instance_) {
  }
}

void SleepingBag_Private::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SleepingBag_Private::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SleepingBag_Private_descriptor_;
}

const SleepingBag_Private& SleepingBag_Private::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

SleepingBag_Private* SleepingBag_Private::default_instance_ = NULL;

SleepingBag_Private* SleepingBag_Private::New() const {
  return new SleepingBag_Private;
}

void SleepingBag_Private::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    deployerid_ = GOOGLE_ULONGLONG(0);
    if (has_deployername()) {
      if (deployername_ != &::google::protobuf::internal::kEmptyString) {
        deployername_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SleepingBag_Private::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 deployerID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &deployerid_)));
          set_has_deployerid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_deployerName;
        break;
      }

      // optional string deployerName = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_deployerName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_deployername()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->deployername().data(), this->deployername().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SleepingBag_Private::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 deployerID = 1;
  if (has_deployerid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->deployerid(), output);
  }

  // optional string deployerName = 2;
  if (has_deployername()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->deployername().data(), this->deployername().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->deployername(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SleepingBag_Private::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 deployerID = 1;
  if (has_deployerid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->deployerid(), target);
  }

  // optional string deployerName = 2;
  if (has_deployername()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->deployername().data(), this->deployername().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->deployername(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SleepingBag_Private::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 deployerID = 1;
    if (has_deployerid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->deployerid());
    }

    // optional string deployerName = 2;
    if (has_deployername()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->deployername());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SleepingBag_Private::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SleepingBag_Private* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SleepingBag_Private*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SleepingBag_Private::MergeFrom(const SleepingBag_Private& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_deployerid()) {
      set_deployerid(from.deployerid());
    }
    if (from.has_deployername()) {
      set_deployername(from.deployername());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SleepingBag_Private::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SleepingBag_Private::CopyFrom(const SleepingBag_Private& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SleepingBag_Private::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SleepingBag_Private::Swap(SleepingBag_Private* other) {
  if (other != this) {
    std::swap(deployerid_, other->deployerid_);
    std::swap(deployername_, other->deployername_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SleepingBag_Private::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SleepingBag_Private_descriptor_;
  metadata.reflection = SleepingBag_Private_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int SleepingBag::kNameFieldNumber;
const int SleepingBag::kPrivateDataFieldNumber;
const int SleepingBag::kDeployerIDFieldNumber;
#endif  // !_MSC_VER

SleepingBag::SleepingBag()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SleepingBag::InitAsDefaultInstance() {
  privatedata_ = const_cast< ::SleepingBag_Private*>(&::SleepingBag_Private::default_instance());
}

SleepingBag::SleepingBag(const SleepingBag& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SleepingBag::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  privatedata_ = NULL;
  deployerid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SleepingBag::~SleepingBag() {
  SharedDtor();
}

void SleepingBag::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
    delete privatedata_;
  }
}

void SleepingBag::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SleepingBag::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SleepingBag_descriptor_;
}

const SleepingBag& SleepingBag::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

SleepingBag* SleepingBag::default_instance_ = NULL;

SleepingBag* SleepingBag::New() const {
  return new SleepingBag;
}

void SleepingBag::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_privatedata()) {
      if (privatedata_ != NULL) privatedata_->::SleepingBag_Private::Clear();
    }
    deployerid_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SleepingBag::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_privateData;
        break;
      }

      // optional .SleepingBag.Private privateData = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_privateData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_privatedata()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_deployerID;
        break;
      }

      // required uint64 deployerID = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_deployerID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &deployerid_)));
          set_has_deployerid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SleepingBag::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // optional .SleepingBag.Private privateData = 2;
  if (has_privatedata()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->privatedata(), output);
  }

  // required uint64 deployerID = 3;
  if (has_deployerid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->deployerid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SleepingBag::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional .SleepingBag.Private privateData = 2;
  if (has_privatedata()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->privatedata(), target);
  }

  // required uint64 deployerID = 3;
  if (has_deployerid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->deployerid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SleepingBag::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional .SleepingBag.Private privateData = 2;
    if (has_privatedata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->privatedata());
    }

    // required uint64 deployerID = 3;
    if (has_deployerid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->deployerid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SleepingBag::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SleepingBag* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SleepingBag*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SleepingBag::MergeFrom(const SleepingBag& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_privatedata()) {
      mutable_privatedata()->::SleepingBag_Private::MergeFrom(from.privatedata());
    }
    if (from.has_deployerid()) {
      set_deployerid(from.deployerid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SleepingBag::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SleepingBag::CopyFrom(const SleepingBag& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SleepingBag::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000004) != 0x00000004) return false;

  if (has_privatedata()) {
    if (!this->privatedata().IsInitialized()) return false;
  }
  return true;
}

void SleepingBag::Swap(SleepingBag* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(privatedata_, other->privatedata_);
    std::swap(deployerid_, other->deployerid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SleepingBag::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SleepingBag_descriptor_;
  metadata.reflection = SleepingBag_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LootableCorpse_Private::kContainerFieldNumber;
#endif  // !_MSC_VER

LootableCorpse_Private::LootableCorpse_Private()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LootableCorpse_Private::InitAsDefaultInstance() {
}

LootableCorpse_Private::LootableCorpse_Private(const LootableCorpse_Private& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LootableCorpse_Private::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LootableCorpse_Private::~LootableCorpse_Private() {
  SharedDtor();
}

void LootableCorpse_Private::SharedDtor() {
  if (this != default_instance_) {
  }
}

void LootableCorpse_Private::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LootableCorpse_Private::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LootableCorpse_Private_descriptor_;
}

const LootableCorpse_Private& LootableCorpse_Private::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

LootableCorpse_Private* LootableCorpse_Private::default_instance_ = NULL;

LootableCorpse_Private* LootableCorpse_Private::New() const {
  return new LootableCorpse_Private;
}

void LootableCorpse_Private::Clear() {
  container_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LootableCorpse_Private::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ItemContainer container = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_container:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_container()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_container;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LootableCorpse_Private::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .ItemContainer container = 1;
  for (int i = 0; i < this->container_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->container(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LootableCorpse_Private::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .ItemContainer container = 1;
  for (int i = 0; i < this->container_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->container(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LootableCorpse_Private::ByteSize() const {
  int total_size = 0;

  // repeated .ItemContainer container = 1;
  total_size += 1 * this->container_size();
  for (int i = 0; i < this->container_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->container(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LootableCorpse_Private::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LootableCorpse_Private* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LootableCorpse_Private*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LootableCorpse_Private::MergeFrom(const LootableCorpse_Private& from) {
  GOOGLE_CHECK_NE(&from, this);
  container_.MergeFrom(from.container_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LootableCorpse_Private::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LootableCorpse_Private::CopyFrom(const LootableCorpse_Private& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LootableCorpse_Private::IsInitialized() const {

  for (int i = 0; i < container_size(); i++) {
    if (!this->container(i).IsInitialized()) return false;
  }
  return true;
}

void LootableCorpse_Private::Swap(LootableCorpse_Private* other) {
  if (other != this) {
    container_.Swap(&other->container_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LootableCorpse_Private::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LootableCorpse_Private_descriptor_;
  metadata.reflection = LootableCorpse_Private_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int LootableCorpse::kPrivateDataFieldNumber;
const int LootableCorpse::kPlayerIDFieldNumber;
const int LootableCorpse::kPlayerNameFieldNumber;
#endif  // !_MSC_VER

LootableCorpse::LootableCorpse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LootableCorpse::InitAsDefaultInstance() {
  privatedata_ = const_cast< ::LootableCorpse_Private*>(&::LootableCorpse_Private::default_instance());
}

LootableCorpse::LootableCorpse(const LootableCorpse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LootableCorpse::SharedCtor() {
  _cached_size_ = 0;
  privatedata_ = NULL;
  playerid_ = GOOGLE_ULONGLONG(0);
  playername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LootableCorpse::~LootableCorpse() {
  SharedDtor();
}

void LootableCorpse::SharedDtor() {
  if (playername_ != &::google::protobuf::internal::kEmptyString) {
    delete playername_;
  }
  if (this != default_instance_) {
    delete privatedata_;
  }
}

void LootableCorpse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LootableCorpse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LootableCorpse_descriptor_;
}

const LootableCorpse& LootableCorpse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

LootableCorpse* LootableCorpse::default_instance_ = NULL;

LootableCorpse* LootableCorpse::New() const {
  return new LootableCorpse;
}

void LootableCorpse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_privatedata()) {
      if (privatedata_ != NULL) privatedata_->::LootableCorpse_Private::Clear();
    }
    playerid_ = GOOGLE_ULONGLONG(0);
    if (has_playername()) {
      if (playername_ != &::google::protobuf::internal::kEmptyString) {
        playername_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LootableCorpse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .LootableCorpse.Private privateData = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_privatedata()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_playerID;
        break;
      }

      // required uint64 playerID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_playerID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &playerid_)));
          set_has_playerid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_playerName;
        break;
      }

      // optional string playerName = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_playerName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_playername()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->playername().data(), this->playername().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LootableCorpse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .LootableCorpse.Private privateData = 1;
  if (has_privatedata()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->privatedata(), output);
  }

  // required uint64 playerID = 2;
  if (has_playerid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->playerid(), output);
  }

  // optional string playerName = 3;
  if (has_playername()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->playername().data(), this->playername().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->playername(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LootableCorpse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .LootableCorpse.Private privateData = 1;
  if (has_privatedata()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->privatedata(), target);
  }

  // required uint64 playerID = 2;
  if (has_playerid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->playerid(), target);
  }

  // optional string playerName = 3;
  if (has_playername()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->playername().data(), this->playername().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->playername(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LootableCorpse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .LootableCorpse.Private privateData = 1;
    if (has_privatedata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->privatedata());
    }

    // required uint64 playerID = 2;
    if (has_playerid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->playerid());
    }

    // optional string playerName = 3;
    if (has_playername()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->playername());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LootableCorpse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LootableCorpse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LootableCorpse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LootableCorpse::MergeFrom(const LootableCorpse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_privatedata()) {
      mutable_privatedata()->::LootableCorpse_Private::MergeFrom(from.privatedata());
    }
    if (from.has_playerid()) {
      set_playerid(from.playerid());
    }
    if (from.has_playername()) {
      set_playername(from.playername());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LootableCorpse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LootableCorpse::CopyFrom(const LootableCorpse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LootableCorpse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  if (has_privatedata()) {
    if (!this->privatedata().IsInitialized()) return false;
  }
  return true;
}

void LootableCorpse::Swap(LootableCorpse* other) {
  if (other != this) {
    std::swap(privatedata_, other->privatedata_);
    std::swap(playerid_, other->playerid_);
    std::swap(playername_, other->playername_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LootableCorpse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LootableCorpse_descriptor_;
  metadata.reflection = LootableCorpse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Sign::kImageidFieldNumber;
#endif  // !_MSC_VER

Sign::Sign()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Sign::InitAsDefaultInstance() {
}

Sign::Sign(const Sign& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Sign::SharedCtor() {
  _cached_size_ = 0;
  imageid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Sign::~Sign() {
  SharedDtor();
}

void Sign::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Sign::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Sign::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Sign_descriptor_;
}

const Sign& Sign::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

Sign* Sign::default_instance_ = NULL;

Sign* Sign::New() const {
  return new Sign;
}

void Sign::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    imageid_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Sign::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 imageid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &imageid_)));
          set_has_imageid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Sign::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 imageid = 3;
  if (has_imageid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->imageid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Sign::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 imageid = 3;
  if (has_imageid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->imageid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Sign::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 imageid = 3;
    if (has_imageid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->imageid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Sign::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Sign* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Sign*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Sign::MergeFrom(const Sign& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_imageid()) {
      set_imageid(from.imageid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Sign::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Sign::CopyFrom(const Sign& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Sign::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Sign::Swap(Sign* other) {
  if (other != this) {
    std::swap(imageid_, other->imageid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Sign::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Sign_descriptor_;
  metadata.reflection = Sign_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BaseCombat::kStateFieldNumber;
const int BaseCombat::kHealthFieldNumber;
#endif  // !_MSC_VER

BaseCombat::BaseCombat()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void BaseCombat::InitAsDefaultInstance() {
}

BaseCombat::BaseCombat(const BaseCombat& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void BaseCombat::SharedCtor() {
  _cached_size_ = 0;
  state_ = GOOGLE_ULONGLONG(0);
  health_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BaseCombat::~BaseCombat() {
  SharedDtor();
}

void BaseCombat::SharedDtor() {
  if (this != default_instance_) {
  }
}

void BaseCombat::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BaseCombat::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BaseCombat_descriptor_;
}

const BaseCombat& BaseCombat::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

BaseCombat* BaseCombat::default_instance_ = NULL;

BaseCombat* BaseCombat::New() const {
  return new BaseCombat;
}

void BaseCombat::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    state_ = GOOGLE_ULONGLONG(0);
    health_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BaseCombat::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 state = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &state_)));
          set_has_state();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_health;
        break;
      }

      // required float health = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_health:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &health_)));
          set_has_health();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BaseCombat::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 state = 1;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->state(), output);
  }

  // required float health = 2;
  if (has_health()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->health(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* BaseCombat::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 state = 1;
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->state(), target);
  }

  // required float health = 2;
  if (has_health()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->health(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int BaseCombat::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 state = 1;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->state());
    }

    // required float health = 2;
    if (has_health()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BaseCombat::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BaseCombat* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BaseCombat*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BaseCombat::MergeFrom(const BaseCombat& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_health()) {
      set_health(from.health());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BaseCombat::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BaseCombat::CopyFrom(const BaseCombat& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BaseCombat::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void BaseCombat::Swap(BaseCombat* other) {
  if (other != this) {
    std::swap(state_, other->state_);
    std::swap(health_, other->health_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BaseCombat::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BaseCombat_descriptor_;
  metadata.reflection = BaseCombat_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MapEntity::kFogImagesFieldNumber;
const int MapEntity::kPaintImagesFieldNumber;
#endif  // !_MSC_VER

MapEntity::MapEntity()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MapEntity::InitAsDefaultInstance() {
}

MapEntity::MapEntity(const MapEntity& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MapEntity::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MapEntity::~MapEntity() {
  SharedDtor();
}

void MapEntity::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MapEntity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MapEntity::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MapEntity_descriptor_;
}

const MapEntity& MapEntity::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

MapEntity* MapEntity::default_instance_ = NULL;

MapEntity* MapEntity::New() const {
  return new MapEntity;
}

void MapEntity::Clear() {
  fogimages_.Clear();
  paintimages_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MapEntity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 fogImages = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fogImages:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_fogimages())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_fogimages())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_fogImages;
        if (input->ExpectTag(16)) goto parse_paintImages;
        break;
      }

      // repeated uint32 paintImages = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_paintImages:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_paintimages())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_paintimages())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_paintImages;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MapEntity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated uint32 fogImages = 1;
  for (int i = 0; i < this->fogimages_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->fogimages(i), output);
  }

  // repeated uint32 paintImages = 2;
  for (int i = 0; i < this->paintimages_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->paintimages(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MapEntity::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated uint32 fogImages = 1;
  for (int i = 0; i < this->fogimages_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(1, this->fogimages(i), target);
  }

  // repeated uint32 paintImages = 2;
  for (int i = 0; i < this->paintimages_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(2, this->paintimages(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MapEntity::ByteSize() const {
  int total_size = 0;

  // repeated uint32 fogImages = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->fogimages_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->fogimages(i));
    }
    total_size += 1 * this->fogimages_size() + data_size;
  }

  // repeated uint32 paintImages = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->paintimages_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->paintimages(i));
    }
    total_size += 1 * this->paintimages_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapEntity::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MapEntity* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MapEntity*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MapEntity::MergeFrom(const MapEntity& from) {
  GOOGLE_CHECK_NE(&from, this);
  fogimages_.MergeFrom(from.fogimages_);
  paintimages_.MergeFrom(from.paintimages_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MapEntity::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapEntity::CopyFrom(const MapEntity& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapEntity::IsInitialized() const {

  return true;
}

void MapEntity::Swap(MapEntity* other) {
  if (other != this) {
    fogimages_.Swap(&other->fogimages_);
    paintimages_.Swap(&other->paintimages_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MapEntity::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MapEntity_descriptor_;
  metadata.reflection = MapEntity_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ResearchTable::kResearchTimeLeftFieldNumber;
#endif  // !_MSC_VER

ResearchTable::ResearchTable()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ResearchTable::InitAsDefaultInstance() {
}

ResearchTable::ResearchTable(const ResearchTable& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ResearchTable::SharedCtor() {
  _cached_size_ = 0;
  researchtimeleft_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResearchTable::~ResearchTable() {
  SharedDtor();
}

void ResearchTable::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ResearchTable::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResearchTable::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResearchTable_descriptor_;
}

const ResearchTable& ResearchTable::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

ResearchTable* ResearchTable::default_instance_ = NULL;

ResearchTable* ResearchTable::New() const {
  return new ResearchTable;
}

void ResearchTable::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    researchtimeleft_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ResearchTable::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float researchTimeLeft = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &researchtimeleft_)));
          set_has_researchtimeleft();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResearchTable::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float researchTimeLeft = 1;
  if (has_researchtimeleft()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->researchtimeleft(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ResearchTable::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float researchTimeLeft = 1;
  if (has_researchtimeleft()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->researchtimeleft(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ResearchTable::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float researchTimeLeft = 1;
    if (has_researchtimeleft()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResearchTable::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ResearchTable* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ResearchTable*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResearchTable::MergeFrom(const ResearchTable& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_researchtimeleft()) {
      set_researchtimeleft(from.researchtimeleft());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ResearchTable::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResearchTable::CopyFrom(const ResearchTable& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResearchTable::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ResearchTable::Swap(ResearchTable* other) {
  if (other != this) {
    std::swap(researchtimeleft_, other->researchtimeleft_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ResearchTable::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResearchTable_descriptor_;
  metadata.reflection = ResearchTable_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DudExplosive::kFuseTimeLeftFieldNumber;
#endif  // !_MSC_VER

DudExplosive::DudExplosive()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DudExplosive::InitAsDefaultInstance() {
}

DudExplosive::DudExplosive(const DudExplosive& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DudExplosive::SharedCtor() {
  _cached_size_ = 0;
  fusetimeleft_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DudExplosive::~DudExplosive() {
  SharedDtor();
}

void DudExplosive::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DudExplosive::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DudExplosive::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DudExplosive_descriptor_;
}

const DudExplosive& DudExplosive::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

DudExplosive* DudExplosive::default_instance_ = NULL;

DudExplosive* DudExplosive::New() const {
  return new DudExplosive;
}

void DudExplosive::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    fusetimeleft_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DudExplosive::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float fuseTimeLeft = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &fusetimeleft_)));
          set_has_fusetimeleft();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DudExplosive::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float fuseTimeLeft = 1;
  if (has_fusetimeleft()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->fusetimeleft(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DudExplosive::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float fuseTimeLeft = 1;
  if (has_fusetimeleft()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->fusetimeleft(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DudExplosive::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float fuseTimeLeft = 1;
    if (has_fusetimeleft()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DudExplosive::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DudExplosive* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DudExplosive*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DudExplosive::MergeFrom(const DudExplosive& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_fusetimeleft()) {
      set_fusetimeleft(from.fusetimeleft());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DudExplosive::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DudExplosive::CopyFrom(const DudExplosive& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DudExplosive::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void DudExplosive::Swap(DudExplosive* other) {
  if (other != this) {
    std::swap(fusetimeleft_, other->fusetimeleft_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DudExplosive::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DudExplosive_descriptor_;
  metadata.reflection = DudExplosive_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ResourceExtractor::kFuelContentsFieldNumber;
const int ResourceExtractor::kOutputContentsFieldNumber;
#endif  // !_MSC_VER

ResourceExtractor::ResourceExtractor()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ResourceExtractor::InitAsDefaultInstance() {
  fuelcontents_ = const_cast< ::ItemContainer*>(&::ItemContainer::default_instance());
  outputcontents_ = const_cast< ::ItemContainer*>(&::ItemContainer::default_instance());
}

ResourceExtractor::ResourceExtractor(const ResourceExtractor& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ResourceExtractor::SharedCtor() {
  _cached_size_ = 0;
  fuelcontents_ = NULL;
  outputcontents_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResourceExtractor::~ResourceExtractor() {
  SharedDtor();
}

void ResourceExtractor::SharedDtor() {
  if (this != default_instance_) {
    delete fuelcontents_;
    delete outputcontents_;
  }
}

void ResourceExtractor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResourceExtractor::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResourceExtractor_descriptor_;
}

const ResourceExtractor& ResourceExtractor::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

ResourceExtractor* ResourceExtractor::default_instance_ = NULL;

ResourceExtractor* ResourceExtractor::New() const {
  return new ResourceExtractor;
}

void ResourceExtractor::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_fuelcontents()) {
      if (fuelcontents_ != NULL) fuelcontents_->::ItemContainer::Clear();
    }
    if (has_outputcontents()) {
      if (outputcontents_ != NULL) outputcontents_->::ItemContainer::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ResourceExtractor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ItemContainer fuelContents = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_fuelcontents()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_outputContents;
        break;
      }

      // optional .ItemContainer outputContents = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_outputContents:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_outputcontents()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResourceExtractor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .ItemContainer fuelContents = 1;
  if (has_fuelcontents()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->fuelcontents(), output);
  }

  // optional .ItemContainer outputContents = 2;
  if (has_outputcontents()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->outputcontents(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ResourceExtractor::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .ItemContainer fuelContents = 1;
  if (has_fuelcontents()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->fuelcontents(), target);
  }

  // optional .ItemContainer outputContents = 2;
  if (has_outputcontents()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->outputcontents(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ResourceExtractor::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ItemContainer fuelContents = 1;
    if (has_fuelcontents()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->fuelcontents());
    }

    // optional .ItemContainer outputContents = 2;
    if (has_outputcontents()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->outputcontents());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResourceExtractor::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ResourceExtractor* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ResourceExtractor*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResourceExtractor::MergeFrom(const ResourceExtractor& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_fuelcontents()) {
      mutable_fuelcontents()->::ItemContainer::MergeFrom(from.fuelcontents());
    }
    if (from.has_outputcontents()) {
      mutable_outputcontents()->::ItemContainer::MergeFrom(from.outputcontents());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ResourceExtractor::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResourceExtractor::CopyFrom(const ResourceExtractor& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResourceExtractor::IsInitialized() const {

  if (has_fuelcontents()) {
    if (!this->fuelcontents().IsInitialized()) return false;
  }
  if (has_outputcontents()) {
    if (!this->outputcontents().IsInitialized()) return false;
  }
  return true;
}

void ResourceExtractor::Swap(ResourceExtractor* other) {
  if (other != this) {
    std::swap(fuelcontents_, other->fuelcontents_);
    std::swap(outputcontents_, other->outputcontents_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ResourceExtractor::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResourceExtractor_descriptor_;
  metadata.reflection = ResourceExtractor_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MiningQuarry::kExtractorFieldNumber;
#endif  // !_MSC_VER

MiningQuarry::MiningQuarry()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MiningQuarry::InitAsDefaultInstance() {
  extractor_ = const_cast< ::ResourceExtractor*>(&::ResourceExtractor::default_instance());
}

MiningQuarry::MiningQuarry(const MiningQuarry& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MiningQuarry::SharedCtor() {
  _cached_size_ = 0;
  extractor_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MiningQuarry::~MiningQuarry() {
  SharedDtor();
}

void MiningQuarry::SharedDtor() {
  if (this != default_instance_) {
    delete extractor_;
  }
}

void MiningQuarry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MiningQuarry::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MiningQuarry_descriptor_;
}

const MiningQuarry& MiningQuarry::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

MiningQuarry* MiningQuarry::default_instance_ = NULL;

MiningQuarry* MiningQuarry::New() const {
  return new MiningQuarry;
}

void MiningQuarry::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_extractor()) {
      if (extractor_ != NULL) extractor_->::ResourceExtractor::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MiningQuarry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ResourceExtractor extractor = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_extractor()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MiningQuarry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .ResourceExtractor extractor = 1;
  if (has_extractor()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->extractor(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MiningQuarry::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .ResourceExtractor extractor = 1;
  if (has_extractor()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->extractor(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MiningQuarry::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ResourceExtractor extractor = 1;
    if (has_extractor()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->extractor());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MiningQuarry::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MiningQuarry* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MiningQuarry*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MiningQuarry::MergeFrom(const MiningQuarry& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_extractor()) {
      mutable_extractor()->::ResourceExtractor::MergeFrom(from.extractor());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MiningQuarry::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MiningQuarry::CopyFrom(const MiningQuarry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MiningQuarry::IsInitialized() const {

  if (has_extractor()) {
    if (!this->extractor().IsInitialized()) return false;
  }
  return true;
}

void MiningQuarry::Swap(MiningQuarry* other) {
  if (other != this) {
    std::swap(extractor_, other->extractor_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MiningQuarry::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MiningQuarry_descriptor_;
  metadata.reflection = MiningQuarry_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PlantEntity::kStateFieldNumber;
const int PlantEntity::kAgeFieldNumber;
const int PlantEntity::kGeneticsFieldNumber;
const int PlantEntity::kWaterFieldNumber;
const int PlantEntity::kHealthyFieldNumber;
#endif  // !_MSC_VER

PlantEntity::PlantEntity()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PlantEntity::InitAsDefaultInstance() {
}

PlantEntity::PlantEntity(const PlantEntity& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PlantEntity::SharedCtor() {
  _cached_size_ = 0;
  state_ = GOOGLE_ULONGLONG(0);
  age_ = 0;
  genetics_ = GOOGLE_ULONGLONG(0);
  water_ = GOOGLE_ULONGLONG(0);
  healthy_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlantEntity::~PlantEntity() {
  SharedDtor();
}

void PlantEntity::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PlantEntity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PlantEntity::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PlantEntity_descriptor_;
}

const PlantEntity& PlantEntity::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

PlantEntity* PlantEntity::default_instance_ = NULL;

PlantEntity* PlantEntity::New() const {
  return new PlantEntity;
}

void PlantEntity::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    state_ = GOOGLE_ULONGLONG(0);
    age_ = 0;
    genetics_ = GOOGLE_ULONGLONG(0);
    water_ = GOOGLE_ULONGLONG(0);
    healthy_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PlantEntity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 state = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &state_)));
          set_has_state();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_age;
        break;
      }

      // required float age = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_age:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &age_)));
          set_has_age();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_genetics;
        break;
      }

      // required uint64 genetics = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_genetics:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &genetics_)));
          set_has_genetics();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_water;
        break;
      }

      // required uint64 water = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_water:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &water_)));
          set_has_water();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_healthy;
        break;
      }

      // required float healthy = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_healthy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &healthy_)));
          set_has_healthy();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PlantEntity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 state = 1;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->state(), output);
  }

  // required float age = 2;
  if (has_age()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->age(), output);
  }

  // required uint64 genetics = 3;
  if (has_genetics()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->genetics(), output);
  }

  // required uint64 water = 4;
  if (has_water()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->water(), output);
  }

  // required float healthy = 5;
  if (has_healthy()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->healthy(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PlantEntity::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 state = 1;
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->state(), target);
  }

  // required float age = 2;
  if (has_age()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->age(), target);
  }

  // required uint64 genetics = 3;
  if (has_genetics()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->genetics(), target);
  }

  // required uint64 water = 4;
  if (has_water()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->water(), target);
  }

  // required float healthy = 5;
  if (has_healthy()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->healthy(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PlantEntity::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 state = 1;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->state());
    }

    // required float age = 2;
    if (has_age()) {
      total_size += 1 + 4;
    }

    // required uint64 genetics = 3;
    if (has_genetics()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->genetics());
    }

    // required uint64 water = 4;
    if (has_water()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->water());
    }

    // required float healthy = 5;
    if (has_healthy()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlantEntity::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PlantEntity* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PlantEntity*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PlantEntity::MergeFrom(const PlantEntity& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_age()) {
      set_age(from.age());
    }
    if (from.has_genetics()) {
      set_genetics(from.genetics());
    }
    if (from.has_water()) {
      set_water(from.water());
    }
    if (from.has_healthy()) {
      set_healthy(from.healthy());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PlantEntity::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PlantEntity::CopyFrom(const PlantEntity& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlantEntity::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void PlantEntity::Swap(PlantEntity* other) {
  if (other != this) {
    std::swap(state_, other->state_);
    std::swap(age_, other->age_);
    std::swap(genetics_, other->genetics_);
    std::swap(water_, other->water_);
    std::swap(healthy_, other->healthy_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PlantEntity::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PlantEntity_descriptor_;
  metadata.reflection = PlantEntity_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Helicopter::kTiltRotFieldNumber;
const int Helicopter::kLeftGunFieldNumber;
const int Helicopter::kRightGunFieldNumber;
const int Helicopter::kSpotlightVecFieldNumber;
const int Helicopter::kWeakspothealthsFieldNumber;
#endif  // !_MSC_VER

Helicopter::Helicopter()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Helicopter::InitAsDefaultInstance() {
  tiltrot_ = const_cast< ::Vector3Serialized*>(&::Vector3Serialized::default_instance());
  leftgun_ = const_cast< ::Vector3Serialized*>(&::Vector3Serialized::default_instance());
  rightgun_ = const_cast< ::Vector3Serialized*>(&::Vector3Serialized::default_instance());
  spotlightvec_ = const_cast< ::Vector3Serialized*>(&::Vector3Serialized::default_instance());
}

Helicopter::Helicopter(const Helicopter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Helicopter::SharedCtor() {
  _cached_size_ = 0;
  tiltrot_ = NULL;
  leftgun_ = NULL;
  rightgun_ = NULL;
  spotlightvec_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Helicopter::~Helicopter() {
  SharedDtor();
}

void Helicopter::SharedDtor() {
  if (this != default_instance_) {
    delete tiltrot_;
    delete leftgun_;
    delete rightgun_;
    delete spotlightvec_;
  }
}

void Helicopter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Helicopter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Helicopter_descriptor_;
}

const Helicopter& Helicopter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

Helicopter* Helicopter::default_instance_ = NULL;

Helicopter* Helicopter::New() const {
  return new Helicopter;
}

void Helicopter::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_tiltrot()) {
      if (tiltrot_ != NULL) tiltrot_->::Vector3Serialized::Clear();
    }
    if (has_leftgun()) {
      if (leftgun_ != NULL) leftgun_->::Vector3Serialized::Clear();
    }
    if (has_rightgun()) {
      if (rightgun_ != NULL) rightgun_->::Vector3Serialized::Clear();
    }
    if (has_spotlightvec()) {
      if (spotlightvec_ != NULL) spotlightvec_->::Vector3Serialized::Clear();
    }
  }
  weakspothealths_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Helicopter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Vector3Serialized tiltRot = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tiltrot()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_leftGun;
        break;
      }

      // required .Vector3Serialized leftGun = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_leftGun:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_leftgun()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_rightGun;
        break;
      }

      // required .Vector3Serialized rightGun = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_rightGun:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_rightgun()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_spotlightVec;
        break;
      }

      // required .Vector3Serialized spotlightVec = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_spotlightVec:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_spotlightvec()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_weakspothealths;
        break;
      }

      // repeated float weakspothealths = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_weakspothealths:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 45, input, this->mutable_weakspothealths())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_weakspothealths())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_weakspothealths;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Helicopter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .Vector3Serialized tiltRot = 1;
  if (has_tiltrot()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->tiltrot(), output);
  }

  // required .Vector3Serialized leftGun = 2;
  if (has_leftgun()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->leftgun(), output);
  }

  // required .Vector3Serialized rightGun = 3;
  if (has_rightgun()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->rightgun(), output);
  }

  // required .Vector3Serialized spotlightVec = 4;
  if (has_spotlightvec()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->spotlightvec(), output);
  }

  // repeated float weakspothealths = 5;
  for (int i = 0; i < this->weakspothealths_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      5, this->weakspothealths(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Helicopter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .Vector3Serialized tiltRot = 1;
  if (has_tiltrot()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->tiltrot(), target);
  }

  // required .Vector3Serialized leftGun = 2;
  if (has_leftgun()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->leftgun(), target);
  }

  // required .Vector3Serialized rightGun = 3;
  if (has_rightgun()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->rightgun(), target);
  }

  // required .Vector3Serialized spotlightVec = 4;
  if (has_spotlightvec()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->spotlightvec(), target);
  }

  // repeated float weakspothealths = 5;
  for (int i = 0; i < this->weakspothealths_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(5, this->weakspothealths(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Helicopter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Vector3Serialized tiltRot = 1;
    if (has_tiltrot()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->tiltrot());
    }

    // required .Vector3Serialized leftGun = 2;
    if (has_leftgun()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->leftgun());
    }

    // required .Vector3Serialized rightGun = 3;
    if (has_rightgun()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->rightgun());
    }

    // required .Vector3Serialized spotlightVec = 4;
    if (has_spotlightvec()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->spotlightvec());
    }

  }
  // repeated float weakspothealths = 5;
  {
    int data_size = 0;
    data_size = 4 * this->weakspothealths_size();
    total_size += 1 * this->weakspothealths_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Helicopter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Helicopter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Helicopter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Helicopter::MergeFrom(const Helicopter& from) {
  GOOGLE_CHECK_NE(&from, this);
  weakspothealths_.MergeFrom(from.weakspothealths_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_tiltrot()) {
      mutable_tiltrot()->::Vector3Serialized::MergeFrom(from.tiltrot());
    }
    if (from.has_leftgun()) {
      mutable_leftgun()->::Vector3Serialized::MergeFrom(from.leftgun());
    }
    if (from.has_rightgun()) {
      mutable_rightgun()->::Vector3Serialized::MergeFrom(from.rightgun());
    }
    if (from.has_spotlightvec()) {
      mutable_spotlightvec()->::Vector3Serialized::MergeFrom(from.spotlightvec());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Helicopter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Helicopter::CopyFrom(const Helicopter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Helicopter::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_tiltrot()) {
    if (!this->tiltrot().IsInitialized()) return false;
  }
  if (has_leftgun()) {
    if (!this->leftgun().IsInitialized()) return false;
  }
  if (has_rightgun()) {
    if (!this->rightgun().IsInitialized()) return false;
  }
  if (has_spotlightvec()) {
    if (!this->spotlightvec().IsInitialized()) return false;
  }
  return true;
}

void Helicopter::Swap(Helicopter* other) {
  if (other != this) {
    std::swap(tiltrot_, other->tiltrot_);
    std::swap(leftgun_, other->leftgun_);
    std::swap(rightgun_, other->rightgun_);
    std::swap(spotlightvec_, other->spotlightvec_);
    weakspothealths_.Swap(&other->weakspothealths_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Helicopter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Helicopter_descriptor_;
  metadata.reflection = Helicopter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Landmine::kTriggeredIDFieldNumber;
#endif  // !_MSC_VER

Landmine::Landmine()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Landmine::InitAsDefaultInstance() {
}

Landmine::Landmine(const Landmine& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Landmine::SharedCtor() {
  _cached_size_ = 0;
  triggeredid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Landmine::~Landmine() {
  SharedDtor();
}

void Landmine::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Landmine::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Landmine::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Landmine_descriptor_;
}

const Landmine& Landmine::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

Landmine* Landmine::default_instance_ = NULL;

Landmine* Landmine::New() const {
  return new Landmine;
}

void Landmine::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    triggeredid_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Landmine::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 triggeredID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &triggeredid_)));
          set_has_triggeredid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Landmine::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 triggeredID = 1;
  if (has_triggeredid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->triggeredid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Landmine::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 triggeredID = 1;
  if (has_triggeredid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->triggeredid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Landmine::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 triggeredID = 1;
    if (has_triggeredid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->triggeredid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Landmine::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Landmine* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Landmine*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Landmine::MergeFrom(const Landmine& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_triggeredid()) {
      set_triggeredid(from.triggeredid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Landmine::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Landmine::CopyFrom(const Landmine& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Landmine::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Landmine::Swap(Landmine* other) {
  if (other != this) {
    std::swap(triggeredid_, other->triggeredid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Landmine::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Landmine_descriptor_;
  metadata.reflection = Landmine_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AutoTurret::kAimPosFieldNumber;
const int AutoTurret::kAimDirFieldNumber;
const int AutoTurret::kTargetIDFieldNumber;
const int AutoTurret::kUsersFieldNumber;
#endif  // !_MSC_VER

AutoTurret::AutoTurret()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AutoTurret::InitAsDefaultInstance() {
  aimpos_ = const_cast< ::Vector3Serialized*>(&::Vector3Serialized::default_instance());
  aimdir_ = const_cast< ::Vector3Serialized*>(&::Vector3Serialized::default_instance());
}

AutoTurret::AutoTurret(const AutoTurret& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AutoTurret::SharedCtor() {
  _cached_size_ = 0;
  aimpos_ = NULL;
  aimdir_ = NULL;
  targetid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AutoTurret::~AutoTurret() {
  SharedDtor();
}

void AutoTurret::SharedDtor() {
  if (this != default_instance_) {
    delete aimpos_;
    delete aimdir_;
  }
}

void AutoTurret::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AutoTurret::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AutoTurret_descriptor_;
}

const AutoTurret& AutoTurret::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

AutoTurret* AutoTurret::default_instance_ = NULL;

AutoTurret* AutoTurret::New() const {
  return new AutoTurret;
}

void AutoTurret::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_aimpos()) {
      if (aimpos_ != NULL) aimpos_->::Vector3Serialized::Clear();
    }
    if (has_aimdir()) {
      if (aimdir_ != NULL) aimdir_->::Vector3Serialized::Clear();
    }
    targetid_ = 0u;
  }
  users_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AutoTurret::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Vector3Serialized aimPos = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_aimpos()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_aimDir;
        break;
      }

      // required .Vector3Serialized aimDir = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_aimDir:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_aimdir()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_targetID;
        break;
      }

      // required uint32 targetID = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_targetID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &targetid_)));
          set_has_targetid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_users;
        break;
      }

      // repeated .PlayerNameID users = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_users:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_users()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_users;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AutoTurret::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .Vector3Serialized aimPos = 1;
  if (has_aimpos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->aimpos(), output);
  }

  // required .Vector3Serialized aimDir = 2;
  if (has_aimdir()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->aimdir(), output);
  }

  // required uint32 targetID = 3;
  if (has_targetid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->targetid(), output);
  }

  // repeated .PlayerNameID users = 4;
  for (int i = 0; i < this->users_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->users(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AutoTurret::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .Vector3Serialized aimPos = 1;
  if (has_aimpos()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->aimpos(), target);
  }

  // required .Vector3Serialized aimDir = 2;
  if (has_aimdir()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->aimdir(), target);
  }

  // required uint32 targetID = 3;
  if (has_targetid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->targetid(), target);
  }

  // repeated .PlayerNameID users = 4;
  for (int i = 0; i < this->users_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->users(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AutoTurret::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Vector3Serialized aimPos = 1;
    if (has_aimpos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->aimpos());
    }

    // required .Vector3Serialized aimDir = 2;
    if (has_aimdir()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->aimdir());
    }

    // required uint32 targetID = 3;
    if (has_targetid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->targetid());
    }

  }
  // repeated .PlayerNameID users = 4;
  total_size += 1 * this->users_size();
  for (int i = 0; i < this->users_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->users(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AutoTurret::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AutoTurret* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AutoTurret*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AutoTurret::MergeFrom(const AutoTurret& from) {
  GOOGLE_CHECK_NE(&from, this);
  users_.MergeFrom(from.users_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_aimpos()) {
      mutable_aimpos()->::Vector3Serialized::MergeFrom(from.aimpos());
    }
    if (from.has_aimdir()) {
      mutable_aimdir()->::Vector3Serialized::MergeFrom(from.aimdir());
    }
    if (from.has_targetid()) {
      set_targetid(from.targetid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AutoTurret::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AutoTurret::CopyFrom(const AutoTurret& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AutoTurret::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_aimpos()) {
    if (!this->aimpos().IsInitialized()) return false;
  }
  if (has_aimdir()) {
    if (!this->aimdir().IsInitialized()) return false;
  }
  for (int i = 0; i < users_size(); i++) {
    if (!this->users(i).IsInitialized()) return false;
  }
  return true;
}

void AutoTurret::Swap(AutoTurret* other) {
  if (other != this) {
    std::swap(aimpos_, other->aimpos_);
    std::swap(aimdir_, other->aimdir_);
    std::swap(targetid_, other->targetid_);
    users_.Swap(&other->users_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AutoTurret::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AutoTurret_descriptor_;
  metadata.reflection = AutoTurret_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SphereEntity::kRadiusFieldNumber;
#endif  // !_MSC_VER

SphereEntity::SphereEntity()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SphereEntity::InitAsDefaultInstance() {
}

SphereEntity::SphereEntity(const SphereEntity& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SphereEntity::SharedCtor() {
  _cached_size_ = 0;
  radius_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SphereEntity::~SphereEntity() {
  SharedDtor();
}

void SphereEntity::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SphereEntity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SphereEntity::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SphereEntity_descriptor_;
}

const SphereEntity& SphereEntity::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

SphereEntity* SphereEntity::default_instance_ = NULL;

SphereEntity* SphereEntity::New() const {
  return new SphereEntity;
}

void SphereEntity::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    radius_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SphereEntity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float radius = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &radius_)));
          set_has_radius();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SphereEntity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float radius = 1;
  if (has_radius()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->radius(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SphereEntity::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float radius = 1;
  if (has_radius()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->radius(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SphereEntity::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float radius = 1;
    if (has_radius()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SphereEntity::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SphereEntity* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SphereEntity*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SphereEntity::MergeFrom(const SphereEntity& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_radius()) {
      set_radius(from.radius());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SphereEntity::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SphereEntity::CopyFrom(const SphereEntity& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SphereEntity::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SphereEntity::Swap(SphereEntity* other) {
  if (other != this) {
    std::swap(radius_, other->radius_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SphereEntity::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SphereEntity_descriptor_;
  metadata.reflection = SphereEntity_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int StabilityEntity::kStabilityFieldNumber;
const int StabilityEntity::kDistanceFromGroundFieldNumber;
#endif  // !_MSC_VER

StabilityEntity::StabilityEntity()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void StabilityEntity::InitAsDefaultInstance() {
}

StabilityEntity::StabilityEntity(const StabilityEntity& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void StabilityEntity::SharedCtor() {
  _cached_size_ = 0;
  stability_ = 0;
  distancefromground_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StabilityEntity::~StabilityEntity() {
  SharedDtor();
}

void StabilityEntity::SharedDtor() {
  if (this != default_instance_) {
  }
}

void StabilityEntity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StabilityEntity::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StabilityEntity_descriptor_;
}

const StabilityEntity& StabilityEntity::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

StabilityEntity* StabilityEntity::default_instance_ = NULL;

StabilityEntity* StabilityEntity::New() const {
  return new StabilityEntity;
}

void StabilityEntity::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    stability_ = 0;
    distancefromground_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool StabilityEntity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float stability = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &stability_)));
          set_has_stability();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_distanceFromGround;
        break;
      }

      // required uint64 distanceFromGround = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_distanceFromGround:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &distancefromground_)));
          set_has_distancefromground();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StabilityEntity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float stability = 1;
  if (has_stability()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->stability(), output);
  }

  // required uint64 distanceFromGround = 2;
  if (has_distancefromground()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->distancefromground(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* StabilityEntity::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float stability = 1;
  if (has_stability()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->stability(), target);
  }

  // required uint64 distanceFromGround = 2;
  if (has_distancefromground()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->distancefromground(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int StabilityEntity::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float stability = 1;
    if (has_stability()) {
      total_size += 1 + 4;
    }

    // required uint64 distanceFromGround = 2;
    if (has_distancefromground()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->distancefromground());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StabilityEntity::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const StabilityEntity* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const StabilityEntity*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void StabilityEntity::MergeFrom(const StabilityEntity& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_stability()) {
      set_stability(from.stability());
    }
    if (from.has_distancefromground()) {
      set_distancefromground(from.distancefromground());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void StabilityEntity::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StabilityEntity::CopyFrom(const StabilityEntity& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StabilityEntity::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void StabilityEntity::Swap(StabilityEntity* other) {
  if (other != this) {
    std::swap(stability_, other->stability_);
    std::swap(distancefromground_, other->distancefromground_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata StabilityEntity::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StabilityEntity_descriptor_;
  metadata.reflection = StabilityEntity_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int OwnerInfo::kSteamidFieldNumber;
#endif  // !_MSC_VER

OwnerInfo::OwnerInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void OwnerInfo::InitAsDefaultInstance() {
}

OwnerInfo::OwnerInfo(const OwnerInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void OwnerInfo::SharedCtor() {
  _cached_size_ = 0;
  steamid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OwnerInfo::~OwnerInfo() {
  SharedDtor();
}

void OwnerInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void OwnerInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* OwnerInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OwnerInfo_descriptor_;
}

const OwnerInfo& OwnerInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

OwnerInfo* OwnerInfo::default_instance_ = NULL;

OwnerInfo* OwnerInfo::New() const {
  return new OwnerInfo;
}

void OwnerInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    steamid_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool OwnerInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 steamid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &steamid_)));
          set_has_steamid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void OwnerInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 steamid = 1;
  if (has_steamid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->steamid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* OwnerInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 steamid = 1;
  if (has_steamid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->steamid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int OwnerInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 steamid = 1;
    if (has_steamid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->steamid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OwnerInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const OwnerInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const OwnerInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void OwnerInfo::MergeFrom(const OwnerInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_steamid()) {
      set_steamid(from.steamid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void OwnerInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OwnerInfo::CopyFrom(const OwnerInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OwnerInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void OwnerInfo::Swap(OwnerInfo* other) {
  if (other != this) {
    std::swap(steamid_, other->steamid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata OwnerInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = OwnerInfo_descriptor_;
  metadata.reflection = OwnerInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DecayEntity::kDecayTimerFieldNumber;
#endif  // !_MSC_VER

DecayEntity::DecayEntity()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DecayEntity::InitAsDefaultInstance() {
}

DecayEntity::DecayEntity(const DecayEntity& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DecayEntity::SharedCtor() {
  _cached_size_ = 0;
  decaytimer_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DecayEntity::~DecayEntity() {
  SharedDtor();
}

void DecayEntity::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DecayEntity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DecayEntity::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DecayEntity_descriptor_;
}

const DecayEntity& DecayEntity::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

DecayEntity* DecayEntity::default_instance_ = NULL;

DecayEntity* DecayEntity::New() const {
  return new DecayEntity;
}

void DecayEntity::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    decaytimer_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DecayEntity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float decayTimer = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &decaytimer_)));
          set_has_decaytimer();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DecayEntity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float decayTimer = 1;
  if (has_decaytimer()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->decaytimer(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DecayEntity::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float decayTimer = 1;
  if (has_decaytimer()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->decaytimer(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DecayEntity::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float decayTimer = 1;
    if (has_decaytimer()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DecayEntity::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DecayEntity* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DecayEntity*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DecayEntity::MergeFrom(const DecayEntity& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_decaytimer()) {
      set_decaytimer(from.decaytimer());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DecayEntity::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DecayEntity::CopyFrom(const DecayEntity& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DecayEntity::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void DecayEntity::Swap(DecayEntity* other) {
  if (other != this) {
    std::swap(decaytimer_, other->decaytimer_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DecayEntity::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DecayEntity_descriptor_;
  metadata.reflection = DecayEntity_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Spawnable::kPopulationFieldNumber;
#endif  // !_MSC_VER

Spawnable::Spawnable()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Spawnable::InitAsDefaultInstance() {
}

Spawnable::Spawnable(const Spawnable& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Spawnable::SharedCtor() {
  _cached_size_ = 0;
  population_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Spawnable::~Spawnable() {
  SharedDtor();
}

void Spawnable::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Spawnable::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Spawnable::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Spawnable_descriptor_;
}

const Spawnable& Spawnable::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

Spawnable* Spawnable::default_instance_ = NULL;

Spawnable* Spawnable::New() const {
  return new Spawnable;
}

void Spawnable::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    population_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Spawnable::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 population = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &population_)));
          set_has_population();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Spawnable::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 population = 1;
  if (has_population()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->population(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Spawnable::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 population = 1;
  if (has_population()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->population(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Spawnable::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 population = 1;
    if (has_population()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->population());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Spawnable::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Spawnable* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Spawnable*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Spawnable::MergeFrom(const Spawnable& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_population()) {
      set_population(from.population());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Spawnable::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Spawnable::CopyFrom(const Spawnable& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Spawnable::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Spawnable::Swap(Spawnable* other) {
  if (other != this) {
    std::swap(population_, other->population_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Spawnable::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Spawnable_descriptor_;
  metadata.reflection = Spawnable_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ServerGib::kGibNameFieldNumber;
#endif  // !_MSC_VER

ServerGib::ServerGib()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ServerGib::InitAsDefaultInstance() {
}

ServerGib::ServerGib(const ServerGib& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ServerGib::SharedCtor() {
  _cached_size_ = 0;
  gibname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ServerGib::~ServerGib() {
  SharedDtor();
}

void ServerGib::SharedDtor() {
  if (gibname_ != &::google::protobuf::internal::kEmptyString) {
    delete gibname_;
  }
  if (this != default_instance_) {
  }
}

void ServerGib::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ServerGib::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ServerGib_descriptor_;
}

const ServerGib& ServerGib::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

ServerGib* ServerGib::default_instance_ = NULL;

ServerGib* ServerGib::New() const {
  return new ServerGib;
}

void ServerGib::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_gibname()) {
      if (gibname_ != &::google::protobuf::internal::kEmptyString) {
        gibname_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ServerGib::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string gibName = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_gibname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->gibname().data(), this->gibname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ServerGib::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string gibName = 1;
  if (has_gibname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->gibname().data(), this->gibname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->gibname(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ServerGib::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string gibName = 1;
  if (has_gibname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->gibname().data(), this->gibname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->gibname(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ServerGib::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string gibName = 1;
    if (has_gibname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->gibname());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ServerGib::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ServerGib* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ServerGib*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ServerGib::MergeFrom(const ServerGib& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gibname()) {
      set_gibname(from.gibname());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ServerGib::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ServerGib::CopyFrom(const ServerGib& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServerGib::IsInitialized() const {

  return true;
}

void ServerGib::Swap(ServerGib* other) {
  if (other != this) {
    std::swap(gibname_, other->gibname_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ServerGib::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ServerGib_descriptor_;
  metadata.reflection = ServerGib_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int VendingMachine_SellOrder::kItemToSellIDFieldNumber;
const int VendingMachine_SellOrder::kItemToSellAmountFieldNumber;
const int VendingMachine_SellOrder::kCurrencyIDFieldNumber;
const int VendingMachine_SellOrder::kCurrencyAmountPerItemFieldNumber;
const int VendingMachine_SellOrder::kInStockFieldNumber;
#endif  // !_MSC_VER

VendingMachine_SellOrder::VendingMachine_SellOrder()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void VendingMachine_SellOrder::InitAsDefaultInstance() {
}

VendingMachine_SellOrder::VendingMachine_SellOrder(const VendingMachine_SellOrder& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void VendingMachine_SellOrder::SharedCtor() {
  _cached_size_ = 0;
  itemtosellid_ = GOOGLE_ULONGLONG(0);
  itemtosellamount_ = GOOGLE_ULONGLONG(0);
  currencyid_ = GOOGLE_ULONGLONG(0);
  currencyamountperitem_ = GOOGLE_ULONGLONG(0);
  instock_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VendingMachine_SellOrder::~VendingMachine_SellOrder() {
  SharedDtor();
}

void VendingMachine_SellOrder::SharedDtor() {
  if (this != default_instance_) {
  }
}

void VendingMachine_SellOrder::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VendingMachine_SellOrder::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VendingMachine_SellOrder_descriptor_;
}

const VendingMachine_SellOrder& VendingMachine_SellOrder::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

VendingMachine_SellOrder* VendingMachine_SellOrder::default_instance_ = NULL;

VendingMachine_SellOrder* VendingMachine_SellOrder::New() const {
  return new VendingMachine_SellOrder;
}

void VendingMachine_SellOrder::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    itemtosellid_ = GOOGLE_ULONGLONG(0);
    itemtosellamount_ = GOOGLE_ULONGLONG(0);
    currencyid_ = GOOGLE_ULONGLONG(0);
    currencyamountperitem_ = GOOGLE_ULONGLONG(0);
    instock_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VendingMachine_SellOrder::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 itemToSellID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &itemtosellid_)));
          set_has_itemtosellid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_itemToSellAmount;
        break;
      }

      // required uint64 itemToSellAmount = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_itemToSellAmount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &itemtosellamount_)));
          set_has_itemtosellamount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_currencyID;
        break;
      }

      // required uint64 currencyID = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_currencyID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &currencyid_)));
          set_has_currencyid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_currencyAmountPerItem;
        break;
      }

      // required uint64 currencyAmountPerItem = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_currencyAmountPerItem:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &currencyamountperitem_)));
          set_has_currencyamountperitem();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_inStock;
        break;
      }

      // required uint64 inStock = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_inStock:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &instock_)));
          set_has_instock();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void VendingMachine_SellOrder::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 itemToSellID = 1;
  if (has_itemtosellid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->itemtosellid(), output);
  }

  // required uint64 itemToSellAmount = 2;
  if (has_itemtosellamount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->itemtosellamount(), output);
  }

  // required uint64 currencyID = 3;
  if (has_currencyid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->currencyid(), output);
  }

  // required uint64 currencyAmountPerItem = 4;
  if (has_currencyamountperitem()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->currencyamountperitem(), output);
  }

  // required uint64 inStock = 5;
  if (has_instock()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->instock(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* VendingMachine_SellOrder::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 itemToSellID = 1;
  if (has_itemtosellid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->itemtosellid(), target);
  }

  // required uint64 itemToSellAmount = 2;
  if (has_itemtosellamount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->itemtosellamount(), target);
  }

  // required uint64 currencyID = 3;
  if (has_currencyid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->currencyid(), target);
  }

  // required uint64 currencyAmountPerItem = 4;
  if (has_currencyamountperitem()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->currencyamountperitem(), target);
  }

  // required uint64 inStock = 5;
  if (has_instock()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(5, this->instock(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int VendingMachine_SellOrder::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 itemToSellID = 1;
    if (has_itemtosellid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->itemtosellid());
    }

    // required uint64 itemToSellAmount = 2;
    if (has_itemtosellamount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->itemtosellamount());
    }

    // required uint64 currencyID = 3;
    if (has_currencyid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->currencyid());
    }

    // required uint64 currencyAmountPerItem = 4;
    if (has_currencyamountperitem()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->currencyamountperitem());
    }

    // required uint64 inStock = 5;
    if (has_instock()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->instock());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VendingMachine_SellOrder::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VendingMachine_SellOrder* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VendingMachine_SellOrder*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VendingMachine_SellOrder::MergeFrom(const VendingMachine_SellOrder& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_itemtosellid()) {
      set_itemtosellid(from.itemtosellid());
    }
    if (from.has_itemtosellamount()) {
      set_itemtosellamount(from.itemtosellamount());
    }
    if (from.has_currencyid()) {
      set_currencyid(from.currencyid());
    }
    if (from.has_currencyamountperitem()) {
      set_currencyamountperitem(from.currencyamountperitem());
    }
    if (from.has_instock()) {
      set_instock(from.instock());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VendingMachine_SellOrder::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VendingMachine_SellOrder::CopyFrom(const VendingMachine_SellOrder& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VendingMachine_SellOrder::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void VendingMachine_SellOrder::Swap(VendingMachine_SellOrder* other) {
  if (other != this) {
    std::swap(itemtosellid_, other->itemtosellid_);
    std::swap(itemtosellamount_, other->itemtosellamount_);
    std::swap(currencyid_, other->currencyid_);
    std::swap(currencyamountperitem_, other->currencyamountperitem_);
    std::swap(instock_, other->instock_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VendingMachine_SellOrder::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VendingMachine_SellOrder_descriptor_;
  metadata.reflection = VendingMachine_SellOrder_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int VendingMachine_SellOrderContainer::kSellOrdersFieldNumber;
#endif  // !_MSC_VER

VendingMachine_SellOrderContainer::VendingMachine_SellOrderContainer()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void VendingMachine_SellOrderContainer::InitAsDefaultInstance() {
}

VendingMachine_SellOrderContainer::VendingMachine_SellOrderContainer(const VendingMachine_SellOrderContainer& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void VendingMachine_SellOrderContainer::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VendingMachine_SellOrderContainer::~VendingMachine_SellOrderContainer() {
  SharedDtor();
}

void VendingMachine_SellOrderContainer::SharedDtor() {
  if (this != default_instance_) {
  }
}

void VendingMachine_SellOrderContainer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VendingMachine_SellOrderContainer::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VendingMachine_SellOrderContainer_descriptor_;
}

const VendingMachine_SellOrderContainer& VendingMachine_SellOrderContainer::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

VendingMachine_SellOrderContainer* VendingMachine_SellOrderContainer::default_instance_ = NULL;

VendingMachine_SellOrderContainer* VendingMachine_SellOrderContainer::New() const {
  return new VendingMachine_SellOrderContainer;
}

void VendingMachine_SellOrderContainer::Clear() {
  sellorders_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VendingMachine_SellOrderContainer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .VendingMachine.SellOrder sellOrders = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sellOrders:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_sellorders()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_sellOrders;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void VendingMachine_SellOrderContainer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .VendingMachine.SellOrder sellOrders = 1;
  for (int i = 0; i < this->sellorders_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->sellorders(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* VendingMachine_SellOrderContainer::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .VendingMachine.SellOrder sellOrders = 1;
  for (int i = 0; i < this->sellorders_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->sellorders(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int VendingMachine_SellOrderContainer::ByteSize() const {
  int total_size = 0;

  // repeated .VendingMachine.SellOrder sellOrders = 1;
  total_size += 1 * this->sellorders_size();
  for (int i = 0; i < this->sellorders_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->sellorders(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VendingMachine_SellOrderContainer::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VendingMachine_SellOrderContainer* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VendingMachine_SellOrderContainer*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VendingMachine_SellOrderContainer::MergeFrom(const VendingMachine_SellOrderContainer& from) {
  GOOGLE_CHECK_NE(&from, this);
  sellorders_.MergeFrom(from.sellorders_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VendingMachine_SellOrderContainer::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VendingMachine_SellOrderContainer::CopyFrom(const VendingMachine_SellOrderContainer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VendingMachine_SellOrderContainer::IsInitialized() const {

  for (int i = 0; i < sellorders_size(); i++) {
    if (!this->sellorders(i).IsInitialized()) return false;
  }
  return true;
}

void VendingMachine_SellOrderContainer::Swap(VendingMachine_SellOrderContainer* other) {
  if (other != this) {
    sellorders_.Swap(&other->sellorders_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VendingMachine_SellOrderContainer::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VendingMachine_SellOrderContainer_descriptor_;
  metadata.reflection = VendingMachine_SellOrderContainer_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int VendingMachine::kSellOrderContainerFieldNumber;
const int VendingMachine::kShopNameFieldNumber;
#endif  // !_MSC_VER

VendingMachine::VendingMachine()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void VendingMachine::InitAsDefaultInstance() {
  sellordercontainer_ = const_cast< ::VendingMachine_SellOrderContainer*>(&::VendingMachine_SellOrderContainer::default_instance());
}

VendingMachine::VendingMachine(const VendingMachine& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void VendingMachine::SharedCtor() {
  _cached_size_ = 0;
  sellordercontainer_ = NULL;
  shopname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VendingMachine::~VendingMachine() {
  SharedDtor();
}

void VendingMachine::SharedDtor() {
  if (shopname_ != &::google::protobuf::internal::kEmptyString) {
    delete shopname_;
  }
  if (this != default_instance_) {
    delete sellordercontainer_;
  }
}

void VendingMachine::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VendingMachine::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VendingMachine_descriptor_;
}

const VendingMachine& VendingMachine::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

VendingMachine* VendingMachine::default_instance_ = NULL;

VendingMachine* VendingMachine::New() const {
  return new VendingMachine;
}

void VendingMachine::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_sellordercontainer()) {
      if (sellordercontainer_ != NULL) sellordercontainer_->::VendingMachine_SellOrderContainer::Clear();
    }
    if (has_shopname()) {
      if (shopname_ != &::google::protobuf::internal::kEmptyString) {
        shopname_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VendingMachine::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .VendingMachine.SellOrderContainer sellOrderContainer = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sellordercontainer()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_shopName;
        break;
      }

      // optional string shopName = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_shopName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_shopname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->shopname().data(), this->shopname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void VendingMachine::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .VendingMachine.SellOrderContainer sellOrderContainer = 1;
  if (has_sellordercontainer()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->sellordercontainer(), output);
  }

  // optional string shopName = 2;
  if (has_shopname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->shopname().data(), this->shopname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->shopname(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* VendingMachine::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .VendingMachine.SellOrderContainer sellOrderContainer = 1;
  if (has_sellordercontainer()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->sellordercontainer(), target);
  }

  // optional string shopName = 2;
  if (has_shopname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->shopname().data(), this->shopname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->shopname(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int VendingMachine::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .VendingMachine.SellOrderContainer sellOrderContainer = 1;
    if (has_sellordercontainer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sellordercontainer());
    }

    // optional string shopName = 2;
    if (has_shopname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->shopname());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VendingMachine::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VendingMachine* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VendingMachine*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VendingMachine::MergeFrom(const VendingMachine& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sellordercontainer()) {
      mutable_sellordercontainer()->::VendingMachine_SellOrderContainer::MergeFrom(from.sellordercontainer());
    }
    if (from.has_shopname()) {
      set_shopname(from.shopname());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VendingMachine::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VendingMachine::CopyFrom(const VendingMachine& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VendingMachine::IsInitialized() const {

  if (has_sellordercontainer()) {
    if (!this->sellordercontainer().IsInitialized()) return false;
  }
  return true;
}

void VendingMachine::Swap(VendingMachine* other) {
  if (other != this) {
    std::swap(sellordercontainer_, other->sellordercontainer_);
    std::swap(shopname_, other->shopname_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VendingMachine::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VendingMachine_descriptor_;
  metadata.reflection = VendingMachine_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SpinnerWheel::kSpinFieldNumber;
#endif  // !_MSC_VER

SpinnerWheel::SpinnerWheel()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SpinnerWheel::InitAsDefaultInstance() {
  spin_ = const_cast< ::Vector3Serialized*>(&::Vector3Serialized::default_instance());
}

SpinnerWheel::SpinnerWheel(const SpinnerWheel& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SpinnerWheel::SharedCtor() {
  _cached_size_ = 0;
  spin_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SpinnerWheel::~SpinnerWheel() {
  SharedDtor();
}

void SpinnerWheel::SharedDtor() {
  if (this != default_instance_) {
    delete spin_;
  }
}

void SpinnerWheel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SpinnerWheel::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SpinnerWheel_descriptor_;
}

const SpinnerWheel& SpinnerWheel::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

SpinnerWheel* SpinnerWheel::default_instance_ = NULL;

SpinnerWheel* SpinnerWheel::New() const {
  return new SpinnerWheel;
}

void SpinnerWheel::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_spin()) {
      if (spin_ != NULL) spin_->::Vector3Serialized::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SpinnerWheel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Vector3Serialized spin = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_spin()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SpinnerWheel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .Vector3Serialized spin = 1;
  if (has_spin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->spin(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SpinnerWheel::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .Vector3Serialized spin = 1;
  if (has_spin()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->spin(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SpinnerWheel::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Vector3Serialized spin = 1;
    if (has_spin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->spin());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SpinnerWheel::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SpinnerWheel* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SpinnerWheel*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SpinnerWheel::MergeFrom(const SpinnerWheel& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_spin()) {
      mutable_spin()->::Vector3Serialized::MergeFrom(from.spin());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SpinnerWheel::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SpinnerWheel::CopyFrom(const SpinnerWheel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpinnerWheel::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_spin()) {
    if (!this->spin().IsInitialized()) return false;
  }
  return true;
}

void SpinnerWheel::Swap(SpinnerWheel* other) {
  if (other != this) {
    std::swap(spin_, other->spin_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SpinnerWheel::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SpinnerWheel_descriptor_;
  metadata.reflection = SpinnerWheel_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Entity::kBaseNetworkableFieldNumber;
const int Entity::kBaseEntityFieldNumber;
const int Entity::kBasePlayerFieldNumber;
const int Entity::kWorldItemFieldNumber;
const int Entity::kResourceFieldNumber;
const int Entity::kBuildingBlockFieldNumber;
const int Entity::kEnvironmentFieldNumber;
const int Entity::kCorpseFieldNumber;
const int Entity::kParentFieldNumber;
const int Entity::kKeyLockFieldNumber;
const int Entity::kCodeLockFieldNumber;
const int Entity::kEntitySlotsFieldNumber;
const int Entity::kBuildingPrivilegeFieldNumber;
const int Entity::kStorageBoxFieldNumber;
const int Entity::kHeldEntityFieldNumber;
const int Entity::kBaseProjectileFieldNumber;
const int Entity::kBaseNPCFieldNumber;
const int Entity::kLootFieldNumber;
const int Entity::kGenericSpawnerFieldNumber;
const int Entity::kSleepingBagFieldNumber;
const int Entity::kLootableCorpseFieldNumber;
const int Entity::kSignFieldNumber;
const int Entity::kBaseCombatFieldNumber;
const int Entity::kMapEntityFieldNumber;
const int Entity::kResearchTableFieldNumber;
const int Entity::kDudExplosiveFieldNumber;
const int Entity::kMiningQuarryFieldNumber;
const int Entity::kPlantEntityFieldNumber;
const int Entity::kHelicopterFieldNumber;
const int Entity::kLandmineFieldNumber;
const int Entity::kAutoturretFieldNumber;
const int Entity::kSphereEntityFieldNumber;
const int Entity::kStabilityEntityFieldNumber;
const int Entity::kOwnerInfoFieldNumber;
const int Entity::kDecayEntityFieldNumber;
const int Entity::kSpawnableFieldNumber;
const int Entity::kServergibFieldNumber;
const int Entity::kVendingMachineFieldNumber;
const int Entity::kSpinnerWheelFieldNumber;
const int Entity::kCreatedThisFrameFieldNumber;
#endif  // !_MSC_VER

Entity::Entity()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Entity::InitAsDefaultInstance() {
  basenetworkable_ = const_cast< ::BaseNetworkable*>(&::BaseNetworkable::default_instance());
  baseentity_ = const_cast< ::BaseEntity*>(&::BaseEntity::default_instance());
  baseplayer_ = const_cast< ::BasePlayer*>(&::BasePlayer::default_instance());
  worlditem_ = const_cast< ::WorldItem*>(&::WorldItem::default_instance());
  resource_ = const_cast< ::BaseResource*>(&::BaseResource::default_instance());
  buildingblock_ = const_cast< ::BuildingBlock*>(&::BuildingBlock::default_instance());
  environment_ = const_cast< ::Environment*>(&::Environment::default_instance());
  corpse_ = const_cast< ::Corpse*>(&::Corpse::default_instance());
  parent_ = const_cast< ::ParentInfo*>(&::ParentInfo::default_instance());
  keylock_ = const_cast< ::KeyLock*>(&::KeyLock::default_instance());
  codelock_ = const_cast< ::CodeLock*>(&::CodeLock::default_instance());
  entityslots_ = const_cast< ::EntitySlots*>(&::EntitySlots::default_instance());
  buildingprivilege_ = const_cast< ::BuildingPrivilege*>(&::BuildingPrivilege::default_instance());
  storagebox_ = const_cast< ::StorageBox*>(&::StorageBox::default_instance());
  heldentity_ = const_cast< ::HeldEntity*>(&::HeldEntity::default_instance());
  baseprojectile_ = const_cast< ::BaseProjectile*>(&::BaseProjectile::default_instance());
  basenpc_ = const_cast< ::BaseNPC*>(&::BaseNPC::default_instance());
  loot_ = const_cast< ::Loot*>(&::Loot::default_instance());
  genericspawner_ = const_cast< ::GenericSpawner*>(&::GenericSpawner::default_instance());
  sleepingbag_ = const_cast< ::SleepingBag*>(&::SleepingBag::default_instance());
  lootablecorpse_ = const_cast< ::LootableCorpse*>(&::LootableCorpse::default_instance());
  sign_ = const_cast< ::Sign*>(&::Sign::default_instance());
  basecombat_ = const_cast< ::BaseCombat*>(&::BaseCombat::default_instance());
  mapentity_ = const_cast< ::MapEntity*>(&::MapEntity::default_instance());
  researchtable_ = const_cast< ::ResearchTable*>(&::ResearchTable::default_instance());
  dudexplosive_ = const_cast< ::DudExplosive*>(&::DudExplosive::default_instance());
  miningquarry_ = const_cast< ::MiningQuarry*>(&::MiningQuarry::default_instance());
  plantentity_ = const_cast< ::PlantEntity*>(&::PlantEntity::default_instance());
  helicopter_ = const_cast< ::Helicopter*>(&::Helicopter::default_instance());
  landmine_ = const_cast< ::Landmine*>(&::Landmine::default_instance());
  autoturret_ = const_cast< ::AutoTurret*>(&::AutoTurret::default_instance());
  sphereentity_ = const_cast< ::SphereEntity*>(&::SphereEntity::default_instance());
  stabilityentity_ = const_cast< ::StabilityEntity*>(&::StabilityEntity::default_instance());
  ownerinfo_ = const_cast< ::OwnerInfo*>(&::OwnerInfo::default_instance());
  decayentity_ = const_cast< ::DecayEntity*>(&::DecayEntity::default_instance());
  spawnable_ = const_cast< ::Spawnable*>(&::Spawnable::default_instance());
  servergib_ = const_cast< ::ServerGib*>(&::ServerGib::default_instance());
  vendingmachine_ = const_cast< ::VendingMachine*>(&::VendingMachine::default_instance());
  spinnerwheel_ = const_cast< ::SpinnerWheel*>(&::SpinnerWheel::default_instance());
}

Entity::Entity(const Entity& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Entity::SharedCtor() {
  _cached_size_ = 0;
  basenetworkable_ = NULL;
  baseentity_ = NULL;
  baseplayer_ = NULL;
  worlditem_ = NULL;
  resource_ = NULL;
  buildingblock_ = NULL;
  environment_ = NULL;
  corpse_ = NULL;
  parent_ = NULL;
  keylock_ = NULL;
  codelock_ = NULL;
  entityslots_ = NULL;
  buildingprivilege_ = NULL;
  storagebox_ = NULL;
  heldentity_ = NULL;
  baseprojectile_ = NULL;
  basenpc_ = NULL;
  loot_ = NULL;
  genericspawner_ = NULL;
  sleepingbag_ = NULL;
  lootablecorpse_ = NULL;
  sign_ = NULL;
  basecombat_ = NULL;
  mapentity_ = NULL;
  researchtable_ = NULL;
  dudexplosive_ = NULL;
  miningquarry_ = NULL;
  plantentity_ = NULL;
  helicopter_ = NULL;
  landmine_ = NULL;
  autoturret_ = NULL;
  sphereentity_ = NULL;
  stabilityentity_ = NULL;
  ownerinfo_ = NULL;
  decayentity_ = NULL;
  spawnable_ = NULL;
  servergib_ = NULL;
  vendingmachine_ = NULL;
  spinnerwheel_ = NULL;
  createdthisframe_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Entity::~Entity() {
  SharedDtor();
}

void Entity::SharedDtor() {
  if (this != default_instance_) {
    delete basenetworkable_;
    delete baseentity_;
    delete baseplayer_;
    delete worlditem_;
    delete resource_;
    delete buildingblock_;
    delete environment_;
    delete corpse_;
    delete parent_;
    delete keylock_;
    delete codelock_;
    delete entityslots_;
    delete buildingprivilege_;
    delete storagebox_;
    delete heldentity_;
    delete baseprojectile_;
    delete basenpc_;
    delete loot_;
    delete genericspawner_;
    delete sleepingbag_;
    delete lootablecorpse_;
    delete sign_;
    delete basecombat_;
    delete mapentity_;
    delete researchtable_;
    delete dudexplosive_;
    delete miningquarry_;
    delete plantentity_;
    delete helicopter_;
    delete landmine_;
    delete autoturret_;
    delete sphereentity_;
    delete stabilityentity_;
    delete ownerinfo_;
    delete decayentity_;
    delete spawnable_;
    delete servergib_;
    delete vendingmachine_;
    delete spinnerwheel_;
  }
}

void Entity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Entity::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Entity_descriptor_;
}

const Entity& Entity::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

Entity* Entity::default_instance_ = NULL;

Entity* Entity::New() const {
  return new Entity;
}

void Entity::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_basenetworkable()) {
      if (basenetworkable_ != NULL) basenetworkable_->::BaseNetworkable::Clear();
    }
    if (has_baseentity()) {
      if (baseentity_ != NULL) baseentity_->::BaseEntity::Clear();
    }
    if (has_baseplayer()) {
      if (baseplayer_ != NULL) baseplayer_->::BasePlayer::Clear();
    }
    if (has_worlditem()) {
      if (worlditem_ != NULL) worlditem_->::WorldItem::Clear();
    }
    if (has_resource()) {
      if (resource_ != NULL) resource_->::BaseResource::Clear();
    }
    if (has_buildingblock()) {
      if (buildingblock_ != NULL) buildingblock_->::BuildingBlock::Clear();
    }
    if (has_environment()) {
      if (environment_ != NULL) environment_->::Environment::Clear();
    }
    if (has_corpse()) {
      if (corpse_ != NULL) corpse_->::Corpse::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_parent()) {
      if (parent_ != NULL) parent_->::ParentInfo::Clear();
    }
    if (has_keylock()) {
      if (keylock_ != NULL) keylock_->::KeyLock::Clear();
    }
    if (has_codelock()) {
      if (codelock_ != NULL) codelock_->::CodeLock::Clear();
    }
    if (has_entityslots()) {
      if (entityslots_ != NULL) entityslots_->::EntitySlots::Clear();
    }
    if (has_buildingprivilege()) {
      if (buildingprivilege_ != NULL) buildingprivilege_->::BuildingPrivilege::Clear();
    }
    if (has_storagebox()) {
      if (storagebox_ != NULL) storagebox_->::StorageBox::Clear();
    }
    if (has_heldentity()) {
      if (heldentity_ != NULL) heldentity_->::HeldEntity::Clear();
    }
    if (has_baseprojectile()) {
      if (baseprojectile_ != NULL) baseprojectile_->::BaseProjectile::Clear();
    }
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (has_basenpc()) {
      if (basenpc_ != NULL) basenpc_->::BaseNPC::Clear();
    }
    if (has_loot()) {
      if (loot_ != NULL) loot_->::Loot::Clear();
    }
    if (has_genericspawner()) {
      if (genericspawner_ != NULL) genericspawner_->::GenericSpawner::Clear();
    }
    if (has_sleepingbag()) {
      if (sleepingbag_ != NULL) sleepingbag_->::SleepingBag::Clear();
    }
    if (has_lootablecorpse()) {
      if (lootablecorpse_ != NULL) lootablecorpse_->::LootableCorpse::Clear();
    }
    if (has_sign()) {
      if (sign_ != NULL) sign_->::Sign::Clear();
    }
    if (has_basecombat()) {
      if (basecombat_ != NULL) basecombat_->::BaseCombat::Clear();
    }
    if (has_mapentity()) {
      if (mapentity_ != NULL) mapentity_->::MapEntity::Clear();
    }
  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (has_researchtable()) {
      if (researchtable_ != NULL) researchtable_->::ResearchTable::Clear();
    }
    if (has_dudexplosive()) {
      if (dudexplosive_ != NULL) dudexplosive_->::DudExplosive::Clear();
    }
    if (has_miningquarry()) {
      if (miningquarry_ != NULL) miningquarry_->::MiningQuarry::Clear();
    }
    if (has_plantentity()) {
      if (plantentity_ != NULL) plantentity_->::PlantEntity::Clear();
    }
    if (has_helicopter()) {
      if (helicopter_ != NULL) helicopter_->::Helicopter::Clear();
    }
    if (has_landmine()) {
      if (landmine_ != NULL) landmine_->::Landmine::Clear();
    }
    if (has_autoturret()) {
      if (autoturret_ != NULL) autoturret_->::AutoTurret::Clear();
    }
    if (has_sphereentity()) {
      if (sphereentity_ != NULL) sphereentity_->::SphereEntity::Clear();
    }
  }
  if (_has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    if (has_stabilityentity()) {
      if (stabilityentity_ != NULL) stabilityentity_->::StabilityEntity::Clear();
    }
    if (has_ownerinfo()) {
      if (ownerinfo_ != NULL) ownerinfo_->::OwnerInfo::Clear();
    }
    if (has_decayentity()) {
      if (decayentity_ != NULL) decayentity_->::DecayEntity::Clear();
    }
    if (has_spawnable()) {
      if (spawnable_ != NULL) spawnable_->::Spawnable::Clear();
    }
    if (has_servergib()) {
      if (servergib_ != NULL) servergib_->::ServerGib::Clear();
    }
    if (has_vendingmachine()) {
      if (vendingmachine_ != NULL) vendingmachine_->::VendingMachine::Clear();
    }
    if (has_spinnerwheel()) {
      if (spinnerwheel_ != NULL) spinnerwheel_->::SpinnerWheel::Clear();
    }
    createdthisframe_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Entity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .BaseNetworkable baseNetworkable = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_basenetworkable()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_baseEntity;
        break;
      }

      // optional .BaseEntity baseEntity = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_baseEntity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_baseentity()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_basePlayer;
        break;
      }

      // optional .BasePlayer basePlayer = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_basePlayer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_baseplayer()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_worldItem;
        break;
      }

      // optional .WorldItem worldItem = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_worldItem:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_worlditem()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_resource;
        break;
      }

      // optional .BaseResource resource = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_resource:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_resource()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_buildingBlock;
        break;
      }

      // optional .BuildingBlock buildingBlock = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_buildingBlock:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_buildingblock()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_environment;
        break;
      }

      // optional .Environment environment = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_environment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_environment()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_corpse;
        break;
      }

      // optional .Corpse corpse = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_corpse:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_corpse()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_parent;
        break;
      }

      // optional .ParentInfo parent = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_parent:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_parent()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_keyLock;
        break;
      }

      // optional .KeyLock keyLock = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_keyLock:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_keylock()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_codeLock;
        break;
      }

      // optional .CodeLock codeLock = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_codeLock:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_codelock()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_entitySlots;
        break;
      }

      // optional .EntitySlots entitySlots = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_entitySlots:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_entityslots()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(114)) goto parse_buildingPrivilege;
        break;
      }

      // optional .BuildingPrivilege buildingPrivilege = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_buildingPrivilege:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_buildingprivilege()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_storageBox;
        break;
      }

      // optional .StorageBox storageBox = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_storageBox:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_storagebox()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(130)) goto parse_heldEntity;
        break;
      }

      // optional .HeldEntity heldEntity = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_heldEntity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_heldentity()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(138)) goto parse_baseProjectile;
        break;
      }

      // optional .BaseProjectile baseProjectile = 17;
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_baseProjectile:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_baseprojectile()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(146)) goto parse_baseNPC;
        break;
      }

      // optional .BaseNPC baseNPC = 18;
      case 18: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_baseNPC:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_basenpc()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(154)) goto parse_loot;
        break;
      }

      // optional .Loot loot = 19;
      case 19: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_loot:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_loot()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(162)) goto parse_genericSpawner;
        break;
      }

      // optional .GenericSpawner genericSpawner = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_genericSpawner:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_genericspawner()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(170)) goto parse_sleepingBag;
        break;
      }

      // optional .SleepingBag sleepingBag = 21;
      case 21: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sleepingBag:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sleepingbag()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(178)) goto parse_lootableCorpse;
        break;
      }

      // optional .LootableCorpse lootableCorpse = 22;
      case 22: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_lootableCorpse:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_lootablecorpse()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(186)) goto parse_sign;
        break;
      }

      // optional .Sign sign = 23;
      case 23: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sign:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sign()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(194)) goto parse_baseCombat;
        break;
      }

      // optional .BaseCombat baseCombat = 24;
      case 24: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_baseCombat:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_basecombat()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(202)) goto parse_mapEntity;
        break;
      }

      // optional .MapEntity mapEntity = 25;
      case 25: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_mapEntity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mapentity()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(210)) goto parse_researchTable;
        break;
      }

      // optional .ResearchTable researchTable = 26;
      case 26: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_researchTable:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_researchtable()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(218)) goto parse_dudExplosive;
        break;
      }

      // optional .DudExplosive dudExplosive = 27;
      case 27: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_dudExplosive:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dudexplosive()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(226)) goto parse_miningQuarry;
        break;
      }

      // optional .MiningQuarry miningQuarry = 28;
      case 28: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_miningQuarry:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_miningquarry()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(234)) goto parse_plantEntity;
        break;
      }

      // optional .PlantEntity plantEntity = 29;
      case 29: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_plantEntity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_plantentity()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(242)) goto parse_helicopter;
        break;
      }

      // optional .Helicopter helicopter = 30;
      case 30: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_helicopter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_helicopter()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(250)) goto parse_landmine;
        break;
      }

      // optional .Landmine landmine = 31;
      case 31: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_landmine:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_landmine()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(258)) goto parse_autoturret;
        break;
      }

      // optional .AutoTurret autoturret = 32;
      case 32: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_autoturret:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_autoturret()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(266)) goto parse_sphereEntity;
        break;
      }

      // optional .SphereEntity sphereEntity = 33;
      case 33: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sphereEntity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sphereentity()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(274)) goto parse_stabilityEntity;
        break;
      }

      // optional .StabilityEntity stabilityEntity = 34;
      case 34: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_stabilityEntity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_stabilityentity()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(282)) goto parse_ownerInfo;
        break;
      }

      // optional .OwnerInfo ownerInfo = 35;
      case 35: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ownerInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ownerinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(290)) goto parse_decayEntity;
        break;
      }

      // optional .DecayEntity decayEntity = 36;
      case 36: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_decayEntity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_decayentity()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(298)) goto parse_spawnable;
        break;
      }

      // optional .Spawnable spawnable = 37;
      case 37: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_spawnable:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_spawnable()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(306)) goto parse_servergib;
        break;
      }

      // optional .ServerGib servergib = 38;
      case 38: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_servergib:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_servergib()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(314)) goto parse_vendingMachine;
        break;
      }

      // optional .VendingMachine vendingMachine = 39;
      case 39: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_vendingMachine:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_vendingmachine()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(322)) goto parse_spinnerWheel;
        break;
      }

      // optional .SpinnerWheel spinnerWheel = 40;
      case 40: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_spinnerWheel:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_spinnerwheel()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(800)) goto parse_createdThisFrame;
        break;
      }

      // required bool createdThisFrame = 100;
      case 100: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_createdThisFrame:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &createdthisframe_)));
          set_has_createdthisframe();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Entity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .BaseNetworkable baseNetworkable = 1;
  if (has_basenetworkable()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->basenetworkable(), output);
  }

  // optional .BaseEntity baseEntity = 2;
  if (has_baseentity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->baseentity(), output);
  }

  // optional .BasePlayer basePlayer = 3;
  if (has_baseplayer()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->baseplayer(), output);
  }

  // optional .WorldItem worldItem = 4;
  if (has_worlditem()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->worlditem(), output);
  }

  // optional .BaseResource resource = 5;
  if (has_resource()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->resource(), output);
  }

  // optional .BuildingBlock buildingBlock = 6;
  if (has_buildingblock()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->buildingblock(), output);
  }

  // optional .Environment environment = 7;
  if (has_environment()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->environment(), output);
  }

  // optional .Corpse corpse = 8;
  if (has_corpse()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->corpse(), output);
  }

  // optional .ParentInfo parent = 10;
  if (has_parent()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->parent(), output);
  }

  // optional .KeyLock keyLock = 11;
  if (has_keylock()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, this->keylock(), output);
  }

  // optional .CodeLock codeLock = 12;
  if (has_codelock()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, this->codelock(), output);
  }

  // optional .EntitySlots entitySlots = 13;
  if (has_entityslots()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, this->entityslots(), output);
  }

  // optional .BuildingPrivilege buildingPrivilege = 14;
  if (has_buildingprivilege()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      14, this->buildingprivilege(), output);
  }

  // optional .StorageBox storageBox = 15;
  if (has_storagebox()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      15, this->storagebox(), output);
  }

  // optional .HeldEntity heldEntity = 16;
  if (has_heldentity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      16, this->heldentity(), output);
  }

  // optional .BaseProjectile baseProjectile = 17;
  if (has_baseprojectile()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      17, this->baseprojectile(), output);
  }

  // optional .BaseNPC baseNPC = 18;
  if (has_basenpc()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      18, this->basenpc(), output);
  }

  // optional .Loot loot = 19;
  if (has_loot()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      19, this->loot(), output);
  }

  // optional .GenericSpawner genericSpawner = 20;
  if (has_genericspawner()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      20, this->genericspawner(), output);
  }

  // optional .SleepingBag sleepingBag = 21;
  if (has_sleepingbag()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      21, this->sleepingbag(), output);
  }

  // optional .LootableCorpse lootableCorpse = 22;
  if (has_lootablecorpse()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      22, this->lootablecorpse(), output);
  }

  // optional .Sign sign = 23;
  if (has_sign()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      23, this->sign(), output);
  }

  // optional .BaseCombat baseCombat = 24;
  if (has_basecombat()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      24, this->basecombat(), output);
  }

  // optional .MapEntity mapEntity = 25;
  if (has_mapentity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      25, this->mapentity(), output);
  }

  // optional .ResearchTable researchTable = 26;
  if (has_researchtable()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      26, this->researchtable(), output);
  }

  // optional .DudExplosive dudExplosive = 27;
  if (has_dudexplosive()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      27, this->dudexplosive(), output);
  }

  // optional .MiningQuarry miningQuarry = 28;
  if (has_miningquarry()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      28, this->miningquarry(), output);
  }

  // optional .PlantEntity plantEntity = 29;
  if (has_plantentity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      29, this->plantentity(), output);
  }

  // optional .Helicopter helicopter = 30;
  if (has_helicopter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      30, this->helicopter(), output);
  }

  // optional .Landmine landmine = 31;
  if (has_landmine()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      31, this->landmine(), output);
  }

  // optional .AutoTurret autoturret = 32;
  if (has_autoturret()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      32, this->autoturret(), output);
  }

  // optional .SphereEntity sphereEntity = 33;
  if (has_sphereentity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      33, this->sphereentity(), output);
  }

  // optional .StabilityEntity stabilityEntity = 34;
  if (has_stabilityentity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      34, this->stabilityentity(), output);
  }

  // optional .OwnerInfo ownerInfo = 35;
  if (has_ownerinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      35, this->ownerinfo(), output);
  }

  // optional .DecayEntity decayEntity = 36;
  if (has_decayentity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      36, this->decayentity(), output);
  }

  // optional .Spawnable spawnable = 37;
  if (has_spawnable()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      37, this->spawnable(), output);
  }

  // optional .ServerGib servergib = 38;
  if (has_servergib()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      38, this->servergib(), output);
  }

  // optional .VendingMachine vendingMachine = 39;
  if (has_vendingmachine()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      39, this->vendingmachine(), output);
  }

  // optional .SpinnerWheel spinnerWheel = 40;
  if (has_spinnerwheel()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      40, this->spinnerwheel(), output);
  }

  // required bool createdThisFrame = 100;
  if (has_createdthisframe()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(100, this->createdthisframe(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Entity::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .BaseNetworkable baseNetworkable = 1;
  if (has_basenetworkable()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->basenetworkable(), target);
  }

  // optional .BaseEntity baseEntity = 2;
  if (has_baseentity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->baseentity(), target);
  }

  // optional .BasePlayer basePlayer = 3;
  if (has_baseplayer()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->baseplayer(), target);
  }

  // optional .WorldItem worldItem = 4;
  if (has_worlditem()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->worlditem(), target);
  }

  // optional .BaseResource resource = 5;
  if (has_resource()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->resource(), target);
  }

  // optional .BuildingBlock buildingBlock = 6;
  if (has_buildingblock()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->buildingblock(), target);
  }

  // optional .Environment environment = 7;
  if (has_environment()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->environment(), target);
  }

  // optional .Corpse corpse = 8;
  if (has_corpse()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->corpse(), target);
  }

  // optional .ParentInfo parent = 10;
  if (has_parent()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->parent(), target);
  }

  // optional .KeyLock keyLock = 11;
  if (has_keylock()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, this->keylock(), target);
  }

  // optional .CodeLock codeLock = 12;
  if (has_codelock()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        12, this->codelock(), target);
  }

  // optional .EntitySlots entitySlots = 13;
  if (has_entityslots()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        13, this->entityslots(), target);
  }

  // optional .BuildingPrivilege buildingPrivilege = 14;
  if (has_buildingprivilege()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        14, this->buildingprivilege(), target);
  }

  // optional .StorageBox storageBox = 15;
  if (has_storagebox()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        15, this->storagebox(), target);
  }

  // optional .HeldEntity heldEntity = 16;
  if (has_heldentity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        16, this->heldentity(), target);
  }

  // optional .BaseProjectile baseProjectile = 17;
  if (has_baseprojectile()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        17, this->baseprojectile(), target);
  }

  // optional .BaseNPC baseNPC = 18;
  if (has_basenpc()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        18, this->basenpc(), target);
  }

  // optional .Loot loot = 19;
  if (has_loot()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        19, this->loot(), target);
  }

  // optional .GenericSpawner genericSpawner = 20;
  if (has_genericspawner()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        20, this->genericspawner(), target);
  }

  // optional .SleepingBag sleepingBag = 21;
  if (has_sleepingbag()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        21, this->sleepingbag(), target);
  }

  // optional .LootableCorpse lootableCorpse = 22;
  if (has_lootablecorpse()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        22, this->lootablecorpse(), target);
  }

  // optional .Sign sign = 23;
  if (has_sign()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        23, this->sign(), target);
  }

  // optional .BaseCombat baseCombat = 24;
  if (has_basecombat()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        24, this->basecombat(), target);
  }

  // optional .MapEntity mapEntity = 25;
  if (has_mapentity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        25, this->mapentity(), target);
  }

  // optional .ResearchTable researchTable = 26;
  if (has_researchtable()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        26, this->researchtable(), target);
  }

  // optional .DudExplosive dudExplosive = 27;
  if (has_dudexplosive()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        27, this->dudexplosive(), target);
  }

  // optional .MiningQuarry miningQuarry = 28;
  if (has_miningquarry()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        28, this->miningquarry(), target);
  }

  // optional .PlantEntity plantEntity = 29;
  if (has_plantentity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        29, this->plantentity(), target);
  }

  // optional .Helicopter helicopter = 30;
  if (has_helicopter()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        30, this->helicopter(), target);
  }

  // optional .Landmine landmine = 31;
  if (has_landmine()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        31, this->landmine(), target);
  }

  // optional .AutoTurret autoturret = 32;
  if (has_autoturret()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        32, this->autoturret(), target);
  }

  // optional .SphereEntity sphereEntity = 33;
  if (has_sphereentity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        33, this->sphereentity(), target);
  }

  // optional .StabilityEntity stabilityEntity = 34;
  if (has_stabilityentity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        34, this->stabilityentity(), target);
  }

  // optional .OwnerInfo ownerInfo = 35;
  if (has_ownerinfo()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        35, this->ownerinfo(), target);
  }

  // optional .DecayEntity decayEntity = 36;
  if (has_decayentity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        36, this->decayentity(), target);
  }

  // optional .Spawnable spawnable = 37;
  if (has_spawnable()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        37, this->spawnable(), target);
  }

  // optional .ServerGib servergib = 38;
  if (has_servergib()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        38, this->servergib(), target);
  }

  // optional .VendingMachine vendingMachine = 39;
  if (has_vendingmachine()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        39, this->vendingmachine(), target);
  }

  // optional .SpinnerWheel spinnerWheel = 40;
  if (has_spinnerwheel()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        40, this->spinnerwheel(), target);
  }

  // required bool createdThisFrame = 100;
  if (has_createdthisframe()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(100, this->createdthisframe(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Entity::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .BaseNetworkable baseNetworkable = 1;
    if (has_basenetworkable()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->basenetworkable());
    }

    // optional .BaseEntity baseEntity = 2;
    if (has_baseentity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->baseentity());
    }

    // optional .BasePlayer basePlayer = 3;
    if (has_baseplayer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->baseplayer());
    }

    // optional .WorldItem worldItem = 4;
    if (has_worlditem()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->worlditem());
    }

    // optional .BaseResource resource = 5;
    if (has_resource()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->resource());
    }

    // optional .BuildingBlock buildingBlock = 6;
    if (has_buildingblock()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->buildingblock());
    }

    // optional .Environment environment = 7;
    if (has_environment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->environment());
    }

    // optional .Corpse corpse = 8;
    if (has_corpse()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->corpse());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .ParentInfo parent = 10;
    if (has_parent()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->parent());
    }

    // optional .KeyLock keyLock = 11;
    if (has_keylock()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->keylock());
    }

    // optional .CodeLock codeLock = 12;
    if (has_codelock()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->codelock());
    }

    // optional .EntitySlots entitySlots = 13;
    if (has_entityslots()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->entityslots());
    }

    // optional .BuildingPrivilege buildingPrivilege = 14;
    if (has_buildingprivilege()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->buildingprivilege());
    }

    // optional .StorageBox storageBox = 15;
    if (has_storagebox()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->storagebox());
    }

    // optional .HeldEntity heldEntity = 16;
    if (has_heldentity()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->heldentity());
    }

    // optional .BaseProjectile baseProjectile = 17;
    if (has_baseprojectile()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->baseprojectile());
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional .BaseNPC baseNPC = 18;
    if (has_basenpc()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->basenpc());
    }

    // optional .Loot loot = 19;
    if (has_loot()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->loot());
    }

    // optional .GenericSpawner genericSpawner = 20;
    if (has_genericspawner()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->genericspawner());
    }

    // optional .SleepingBag sleepingBag = 21;
    if (has_sleepingbag()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sleepingbag());
    }

    // optional .LootableCorpse lootableCorpse = 22;
    if (has_lootablecorpse()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->lootablecorpse());
    }

    // optional .Sign sign = 23;
    if (has_sign()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sign());
    }

    // optional .BaseCombat baseCombat = 24;
    if (has_basecombat()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->basecombat());
    }

    // optional .MapEntity mapEntity = 25;
    if (has_mapentity()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->mapentity());
    }

  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    // optional .ResearchTable researchTable = 26;
    if (has_researchtable()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->researchtable());
    }

    // optional .DudExplosive dudExplosive = 27;
    if (has_dudexplosive()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->dudexplosive());
    }

    // optional .MiningQuarry miningQuarry = 28;
    if (has_miningquarry()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->miningquarry());
    }

    // optional .PlantEntity plantEntity = 29;
    if (has_plantentity()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->plantentity());
    }

    // optional .Helicopter helicopter = 30;
    if (has_helicopter()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->helicopter());
    }

    // optional .Landmine landmine = 31;
    if (has_landmine()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->landmine());
    }

    // optional .AutoTurret autoturret = 32;
    if (has_autoturret()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->autoturret());
    }

    // optional .SphereEntity sphereEntity = 33;
    if (has_sphereentity()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sphereentity());
    }

  }
  if (_has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    // optional .StabilityEntity stabilityEntity = 34;
    if (has_stabilityentity()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->stabilityentity());
    }

    // optional .OwnerInfo ownerInfo = 35;
    if (has_ownerinfo()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ownerinfo());
    }

    // optional .DecayEntity decayEntity = 36;
    if (has_decayentity()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->decayentity());
    }

    // optional .Spawnable spawnable = 37;
    if (has_spawnable()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->spawnable());
    }

    // optional .ServerGib servergib = 38;
    if (has_servergib()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->servergib());
    }

    // optional .VendingMachine vendingMachine = 39;
    if (has_vendingmachine()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->vendingmachine());
    }

    // optional .SpinnerWheel spinnerWheel = 40;
    if (has_spinnerwheel()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->spinnerwheel());
    }

    // required bool createdThisFrame = 100;
    if (has_createdthisframe()) {
      total_size += 2 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Entity::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Entity* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Entity*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Entity::MergeFrom(const Entity& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_basenetworkable()) {
      mutable_basenetworkable()->::BaseNetworkable::MergeFrom(from.basenetworkable());
    }
    if (from.has_baseentity()) {
      mutable_baseentity()->::BaseEntity::MergeFrom(from.baseentity());
    }
    if (from.has_baseplayer()) {
      mutable_baseplayer()->::BasePlayer::MergeFrom(from.baseplayer());
    }
    if (from.has_worlditem()) {
      mutable_worlditem()->::WorldItem::MergeFrom(from.worlditem());
    }
    if (from.has_resource()) {
      mutable_resource()->::BaseResource::MergeFrom(from.resource());
    }
    if (from.has_buildingblock()) {
      mutable_buildingblock()->::BuildingBlock::MergeFrom(from.buildingblock());
    }
    if (from.has_environment()) {
      mutable_environment()->::Environment::MergeFrom(from.environment());
    }
    if (from.has_corpse()) {
      mutable_corpse()->::Corpse::MergeFrom(from.corpse());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_parent()) {
      mutable_parent()->::ParentInfo::MergeFrom(from.parent());
    }
    if (from.has_keylock()) {
      mutable_keylock()->::KeyLock::MergeFrom(from.keylock());
    }
    if (from.has_codelock()) {
      mutable_codelock()->::CodeLock::MergeFrom(from.codelock());
    }
    if (from.has_entityslots()) {
      mutable_entityslots()->::EntitySlots::MergeFrom(from.entityslots());
    }
    if (from.has_buildingprivilege()) {
      mutable_buildingprivilege()->::BuildingPrivilege::MergeFrom(from.buildingprivilege());
    }
    if (from.has_storagebox()) {
      mutable_storagebox()->::StorageBox::MergeFrom(from.storagebox());
    }
    if (from.has_heldentity()) {
      mutable_heldentity()->::HeldEntity::MergeFrom(from.heldentity());
    }
    if (from.has_baseprojectile()) {
      mutable_baseprojectile()->::BaseProjectile::MergeFrom(from.baseprojectile());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_basenpc()) {
      mutable_basenpc()->::BaseNPC::MergeFrom(from.basenpc());
    }
    if (from.has_loot()) {
      mutable_loot()->::Loot::MergeFrom(from.loot());
    }
    if (from.has_genericspawner()) {
      mutable_genericspawner()->::GenericSpawner::MergeFrom(from.genericspawner());
    }
    if (from.has_sleepingbag()) {
      mutable_sleepingbag()->::SleepingBag::MergeFrom(from.sleepingbag());
    }
    if (from.has_lootablecorpse()) {
      mutable_lootablecorpse()->::LootableCorpse::MergeFrom(from.lootablecorpse());
    }
    if (from.has_sign()) {
      mutable_sign()->::Sign::MergeFrom(from.sign());
    }
    if (from.has_basecombat()) {
      mutable_basecombat()->::BaseCombat::MergeFrom(from.basecombat());
    }
    if (from.has_mapentity()) {
      mutable_mapentity()->::MapEntity::MergeFrom(from.mapentity());
    }
  }
  if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (from.has_researchtable()) {
      mutable_researchtable()->::ResearchTable::MergeFrom(from.researchtable());
    }
    if (from.has_dudexplosive()) {
      mutable_dudexplosive()->::DudExplosive::MergeFrom(from.dudexplosive());
    }
    if (from.has_miningquarry()) {
      mutable_miningquarry()->::MiningQuarry::MergeFrom(from.miningquarry());
    }
    if (from.has_plantentity()) {
      mutable_plantentity()->::PlantEntity::MergeFrom(from.plantentity());
    }
    if (from.has_helicopter()) {
      mutable_helicopter()->::Helicopter::MergeFrom(from.helicopter());
    }
    if (from.has_landmine()) {
      mutable_landmine()->::Landmine::MergeFrom(from.landmine());
    }
    if (from.has_autoturret()) {
      mutable_autoturret()->::AutoTurret::MergeFrom(from.autoturret());
    }
    if (from.has_sphereentity()) {
      mutable_sphereentity()->::SphereEntity::MergeFrom(from.sphereentity());
    }
  }
  if (from._has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    if (from.has_stabilityentity()) {
      mutable_stabilityentity()->::StabilityEntity::MergeFrom(from.stabilityentity());
    }
    if (from.has_ownerinfo()) {
      mutable_ownerinfo()->::OwnerInfo::MergeFrom(from.ownerinfo());
    }
    if (from.has_decayentity()) {
      mutable_decayentity()->::DecayEntity::MergeFrom(from.decayentity());
    }
    if (from.has_spawnable()) {
      mutable_spawnable()->::Spawnable::MergeFrom(from.spawnable());
    }
    if (from.has_servergib()) {
      mutable_servergib()->::ServerGib::MergeFrom(from.servergib());
    }
    if (from.has_vendingmachine()) {
      mutable_vendingmachine()->::VendingMachine::MergeFrom(from.vendingmachine());
    }
    if (from.has_spinnerwheel()) {
      mutable_spinnerwheel()->::SpinnerWheel::MergeFrom(from.spinnerwheel());
    }
    if (from.has_createdthisframe()) {
      set_createdthisframe(from.createdthisframe());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Entity::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Entity::CopyFrom(const Entity& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Entity::IsInitialized() const {
  if ((_has_bits_[1] & 0x00000080) != 0x00000080) return false;

  if (has_basenetworkable()) {
    if (!this->basenetworkable().IsInitialized()) return false;
  }
  if (has_baseentity()) {
    if (!this->baseentity().IsInitialized()) return false;
  }
  if (has_baseplayer()) {
    if (!this->baseplayer().IsInitialized()) return false;
  }
  if (has_worlditem()) {
    if (!this->worlditem().IsInitialized()) return false;
  }
  if (has_resource()) {
    if (!this->resource().IsInitialized()) return false;
  }
  if (has_buildingblock()) {
    if (!this->buildingblock().IsInitialized()) return false;
  }
  if (has_environment()) {
    if (!this->environment().IsInitialized()) return false;
  }
  if (has_corpse()) {
    if (!this->corpse().IsInitialized()) return false;
  }
  if (has_parent()) {
    if (!this->parent().IsInitialized()) return false;
  }
  if (has_keylock()) {
    if (!this->keylock().IsInitialized()) return false;
  }
  if (has_codelock()) {
    if (!this->codelock().IsInitialized()) return false;
  }
  if (has_entityslots()) {
    if (!this->entityslots().IsInitialized()) return false;
  }
  if (has_buildingprivilege()) {
    if (!this->buildingprivilege().IsInitialized()) return false;
  }
  if (has_storagebox()) {
    if (!this->storagebox().IsInitialized()) return false;
  }
  if (has_heldentity()) {
    if (!this->heldentity().IsInitialized()) return false;
  }
  if (has_baseprojectile()) {
    if (!this->baseprojectile().IsInitialized()) return false;
  }
  if (has_basenpc()) {
    if (!this->basenpc().IsInitialized()) return false;
  }
  if (has_loot()) {
    if (!this->loot().IsInitialized()) return false;
  }
  if (has_genericspawner()) {
    if (!this->genericspawner().IsInitialized()) return false;
  }
  if (has_sleepingbag()) {
    if (!this->sleepingbag().IsInitialized()) return false;
  }
  if (has_lootablecorpse()) {
    if (!this->lootablecorpse().IsInitialized()) return false;
  }
  if (has_sign()) {
    if (!this->sign().IsInitialized()) return false;
  }
  if (has_basecombat()) {
    if (!this->basecombat().IsInitialized()) return false;
  }
  if (has_researchtable()) {
    if (!this->researchtable().IsInitialized()) return false;
  }
  if (has_dudexplosive()) {
    if (!this->dudexplosive().IsInitialized()) return false;
  }
  if (has_miningquarry()) {
    if (!this->miningquarry().IsInitialized()) return false;
  }
  if (has_plantentity()) {
    if (!this->plantentity().IsInitialized()) return false;
  }
  if (has_helicopter()) {
    if (!this->helicopter().IsInitialized()) return false;
  }
  if (has_landmine()) {
    if (!this->landmine().IsInitialized()) return false;
  }
  if (has_autoturret()) {
    if (!this->autoturret().IsInitialized()) return false;
  }
  if (has_sphereentity()) {
    if (!this->sphereentity().IsInitialized()) return false;
  }
  if (has_stabilityentity()) {
    if (!this->stabilityentity().IsInitialized()) return false;
  }
  if (has_ownerinfo()) {
    if (!this->ownerinfo().IsInitialized()) return false;
  }
  if (has_decayentity()) {
    if (!this->decayentity().IsInitialized()) return false;
  }
  if (has_spawnable()) {
    if (!this->spawnable().IsInitialized()) return false;
  }
  if (has_vendingmachine()) {
    if (!this->vendingmachine().IsInitialized()) return false;
  }
  if (has_spinnerwheel()) {
    if (!this->spinnerwheel().IsInitialized()) return false;
  }
  return true;
}

void Entity::Swap(Entity* other) {
  if (other != this) {
    std::swap(basenetworkable_, other->basenetworkable_);
    std::swap(baseentity_, other->baseentity_);
    std::swap(baseplayer_, other->baseplayer_);
    std::swap(worlditem_, other->worlditem_);
    std::swap(resource_, other->resource_);
    std::swap(buildingblock_, other->buildingblock_);
    std::swap(environment_, other->environment_);
    std::swap(corpse_, other->corpse_);
    std::swap(parent_, other->parent_);
    std::swap(keylock_, other->keylock_);
    std::swap(codelock_, other->codelock_);
    std::swap(entityslots_, other->entityslots_);
    std::swap(buildingprivilege_, other->buildingprivilege_);
    std::swap(storagebox_, other->storagebox_);
    std::swap(heldentity_, other->heldentity_);
    std::swap(baseprojectile_, other->baseprojectile_);
    std::swap(basenpc_, other->basenpc_);
    std::swap(loot_, other->loot_);
    std::swap(genericspawner_, other->genericspawner_);
    std::swap(sleepingbag_, other->sleepingbag_);
    std::swap(lootablecorpse_, other->lootablecorpse_);
    std::swap(sign_, other->sign_);
    std::swap(basecombat_, other->basecombat_);
    std::swap(mapentity_, other->mapentity_);
    std::swap(researchtable_, other->researchtable_);
    std::swap(dudexplosive_, other->dudexplosive_);
    std::swap(miningquarry_, other->miningquarry_);
    std::swap(plantentity_, other->plantentity_);
    std::swap(helicopter_, other->helicopter_);
    std::swap(landmine_, other->landmine_);
    std::swap(autoturret_, other->autoturret_);
    std::swap(sphereentity_, other->sphereentity_);
    std::swap(stabilityentity_, other->stabilityentity_);
    std::swap(ownerinfo_, other->ownerinfo_);
    std::swap(decayentity_, other->decayentity_);
    std::swap(spawnable_, other->spawnable_);
    std::swap(servergib_, other->servergib_);
    std::swap(vendingmachine_, other->vendingmachine_);
    std::swap(spinnerwheel_, other->spinnerwheel_);
    std::swap(createdthisframe_, other->createdthisframe_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_has_bits_[1], other->_has_bits_[1]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Entity::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Entity_descriptor_;
  metadata.reflection = Entity_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Approval::kLevelFieldNumber;
const int Approval::kHostnameFieldNumber;
const int Approval::kModdedFieldNumber;
const int Approval::kOfficialFieldNumber;
const int Approval::kSteamidFieldNumber;
const int Approval::kIpaddressFieldNumber;
const int Approval::kPortFieldNumber;
const int Approval::kLevelSeedFieldNumber;
const int Approval::kLevelSizeFieldNumber;
const int Approval::kChecksumFieldNumber;
#endif  // !_MSC_VER

Approval::Approval()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Approval::InitAsDefaultInstance() {
}

Approval::Approval(const Approval& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Approval::SharedCtor() {
  _cached_size_ = 0;
  level_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  modded_ = false;
  official_ = false;
  steamid_ = GOOGLE_ULONGLONG(0);
  ipaddress_ = 0u;
  port_ = GOOGLE_ULONGLONG(0);
  levelseed_ = 0u;
  levelsize_ = 0u;
  checksum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Approval::~Approval() {
  SharedDtor();
}

void Approval::SharedDtor() {
  if (level_ != &::google::protobuf::internal::kEmptyString) {
    delete level_;
  }
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (checksum_ != &::google::protobuf::internal::kEmptyString) {
    delete checksum_;
  }
  if (this != default_instance_) {
  }
}

void Approval::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Approval::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Approval_descriptor_;
}

const Approval& Approval::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

Approval* Approval::default_instance_ = NULL;

Approval* Approval::New() const {
  return new Approval;
}

void Approval::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_level()) {
      if (level_ != &::google::protobuf::internal::kEmptyString) {
        level_->clear();
      }
    }
    if (has_hostname()) {
      if (hostname_ != &::google::protobuf::internal::kEmptyString) {
        hostname_->clear();
      }
    }
    modded_ = false;
    official_ = false;
    steamid_ = GOOGLE_ULONGLONG(0);
    ipaddress_ = 0u;
    port_ = GOOGLE_ULONGLONG(0);
    levelseed_ = 0u;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    levelsize_ = 0u;
    if (has_checksum()) {
      if (checksum_ != &::google::protobuf::internal::kEmptyString) {
        checksum_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Approval::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string level = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_level()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->level().data(), this->level().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_hostname;
        break;
      }

      // optional string hostname = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_hostname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hostname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->hostname().data(), this->hostname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_modded;
        break;
      }

      // required bool modded = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_modded:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &modded_)));
          set_has_modded();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_official;
        break;
      }

      // required bool official = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_official:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &official_)));
          set_has_official();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_steamid;
        break;
      }

      // required uint64 steamid = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_steamid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &steamid_)));
          set_has_steamid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_ipaddress;
        break;
      }

      // required uint32 ipaddress = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ipaddress:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ipaddress_)));
          set_has_ipaddress();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_port;
        break;
      }

      // required uint64 port = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_levelSeed;
        break;
      }

      // required uint32 levelSeed = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_levelSeed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &levelseed_)));
          set_has_levelseed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_levelSize;
        break;
      }

      // required uint32 levelSize = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_levelSize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &levelsize_)));
          set_has_levelsize();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_checksum;
        break;
      }

      // optional string checksum = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_checksum:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_checksum()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->checksum().data(), this->checksum().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Approval::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string level = 2;
  if (has_level()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->level().data(), this->level().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->level(), output);
  }

  // optional string hostname = 3;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->hostname(), output);
  }

  // required bool modded = 4;
  if (has_modded()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->modded(), output);
  }

  // required bool official = 5;
  if (has_official()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->official(), output);
  }

  // required uint64 steamid = 6;
  if (has_steamid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->steamid(), output);
  }

  // required uint32 ipaddress = 7;
  if (has_ipaddress()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->ipaddress(), output);
  }

  // required uint64 port = 8;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(8, this->port(), output);
  }

  // required uint32 levelSeed = 9;
  if (has_levelseed()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->levelseed(), output);
  }

  // required uint32 levelSize = 10;
  if (has_levelsize()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->levelsize(), output);
  }

  // optional string checksum = 11;
  if (has_checksum()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->checksum().data(), this->checksum().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      11, this->checksum(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Approval::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string level = 2;
  if (has_level()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->level().data(), this->level().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->level(), target);
  }

  // optional string hostname = 3;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->hostname(), target);
  }

  // required bool modded = 4;
  if (has_modded()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->modded(), target);
  }

  // required bool official = 5;
  if (has_official()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->official(), target);
  }

  // required uint64 steamid = 6;
  if (has_steamid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->steamid(), target);
  }

  // required uint32 ipaddress = 7;
  if (has_ipaddress()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->ipaddress(), target);
  }

  // required uint64 port = 8;
  if (has_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(8, this->port(), target);
  }

  // required uint32 levelSeed = 9;
  if (has_levelseed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->levelseed(), target);
  }

  // required uint32 levelSize = 10;
  if (has_levelsize()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->levelsize(), target);
  }

  // optional string checksum = 11;
  if (has_checksum()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->checksum().data(), this->checksum().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        11, this->checksum(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Approval::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string level = 2;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->level());
    }

    // optional string hostname = 3;
    if (has_hostname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->hostname());
    }

    // required bool modded = 4;
    if (has_modded()) {
      total_size += 1 + 1;
    }

    // required bool official = 5;
    if (has_official()) {
      total_size += 1 + 1;
    }

    // required uint64 steamid = 6;
    if (has_steamid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->steamid());
    }

    // required uint32 ipaddress = 7;
    if (has_ipaddress()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ipaddress());
    }

    // required uint64 port = 8;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->port());
    }

    // required uint32 levelSeed = 9;
    if (has_levelseed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->levelseed());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required uint32 levelSize = 10;
    if (has_levelsize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->levelsize());
    }

    // optional string checksum = 11;
    if (has_checksum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->checksum());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Approval::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Approval* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Approval*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Approval::MergeFrom(const Approval& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_level()) {
      set_level(from.level());
    }
    if (from.has_hostname()) {
      set_hostname(from.hostname());
    }
    if (from.has_modded()) {
      set_modded(from.modded());
    }
    if (from.has_official()) {
      set_official(from.official());
    }
    if (from.has_steamid()) {
      set_steamid(from.steamid());
    }
    if (from.has_ipaddress()) {
      set_ipaddress(from.ipaddress());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
    if (from.has_levelseed()) {
      set_levelseed(from.levelseed());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_levelsize()) {
      set_levelsize(from.levelsize());
    }
    if (from.has_checksum()) {
      set_checksum(from.checksum());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Approval::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Approval::CopyFrom(const Approval& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Approval::IsInitialized() const {
  if ((_has_bits_[0] & 0x000001fd) != 0x000001fd) return false;

  return true;
}

void Approval::Swap(Approval* other) {
  if (other != this) {
    std::swap(level_, other->level_);
    std::swap(hostname_, other->hostname_);
    std::swap(modded_, other->modded_);
    std::swap(official_, other->official_);
    std::swap(steamid_, other->steamid_);
    std::swap(ipaddress_, other->ipaddress_);
    std::swap(port_, other->port_);
    std::swap(levelseed_, other->levelseed_);
    std::swap(levelsize_, other->levelsize_);
    std::swap(checksum_, other->checksum_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Approval::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Approval_descriptor_;
  metadata.reflection = Approval_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Attack::kPointStartFieldNumber;
const int Attack::kPointEndFieldNumber;
const int Attack::kHitIDFieldNumber;
const int Attack::kHitBoneFieldNumber;
const int Attack::kHitNormalLocalFieldNumber;
const int Attack::kHitPositionLocalFieldNumber;
const int Attack::kHitNormalWorldFieldNumber;
const int Attack::kHitPositionWorldFieldNumber;
const int Attack::kHitPartIDFieldNumber;
const int Attack::kHitMaterialIDFieldNumber;
const int Attack::kHitItemFieldNumber;
#endif  // !_MSC_VER

Attack::Attack()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Attack::InitAsDefaultInstance() {
  pointstart_ = const_cast< ::Vector3Serialized*>(&::Vector3Serialized::default_instance());
  pointend_ = const_cast< ::Vector3Serialized*>(&::Vector3Serialized::default_instance());
  hitnormallocal_ = const_cast< ::Vector3Serialized*>(&::Vector3Serialized::default_instance());
  hitpositionlocal_ = const_cast< ::Vector3Serialized*>(&::Vector3Serialized::default_instance());
  hitnormalworld_ = const_cast< ::Vector3Serialized*>(&::Vector3Serialized::default_instance());
  hitpositionworld_ = const_cast< ::Vector3Serialized*>(&::Vector3Serialized::default_instance());
}

Attack::Attack(const Attack& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Attack::SharedCtor() {
  _cached_size_ = 0;
  pointstart_ = NULL;
  pointend_ = NULL;
  hitid_ = 0u;
  hitbone_ = 0u;
  hitnormallocal_ = NULL;
  hitpositionlocal_ = NULL;
  hitnormalworld_ = NULL;
  hitpositionworld_ = NULL;
  hitpartid_ = 0u;
  hitmaterialid_ = 0u;
  hititem_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Attack::~Attack() {
  SharedDtor();
}

void Attack::SharedDtor() {
  if (this != default_instance_) {
    delete pointstart_;
    delete pointend_;
    delete hitnormallocal_;
    delete hitpositionlocal_;
    delete hitnormalworld_;
    delete hitpositionworld_;
  }
}

void Attack::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Attack::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Attack_descriptor_;
}

const Attack& Attack::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

Attack* Attack::default_instance_ = NULL;

Attack* Attack::New() const {
  return new Attack;
}

void Attack::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_pointstart()) {
      if (pointstart_ != NULL) pointstart_->::Vector3Serialized::Clear();
    }
    if (has_pointend()) {
      if (pointend_ != NULL) pointend_->::Vector3Serialized::Clear();
    }
    hitid_ = 0u;
    hitbone_ = 0u;
    if (has_hitnormallocal()) {
      if (hitnormallocal_ != NULL) hitnormallocal_->::Vector3Serialized::Clear();
    }
    if (has_hitpositionlocal()) {
      if (hitpositionlocal_ != NULL) hitpositionlocal_->::Vector3Serialized::Clear();
    }
    if (has_hitnormalworld()) {
      if (hitnormalworld_ != NULL) hitnormalworld_->::Vector3Serialized::Clear();
    }
    if (has_hitpositionworld()) {
      if (hitpositionworld_ != NULL) hitpositionworld_->::Vector3Serialized::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    hitpartid_ = 0u;
    hitmaterialid_ = 0u;
    hititem_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Attack::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Vector3Serialized pointStart = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pointstart()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_pointEnd;
        break;
      }

      // required .Vector3Serialized pointEnd = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pointEnd:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pointend()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_hitID;
        break;
      }

      // required uint32 hitID = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_hitID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &hitid_)));
          set_has_hitid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_hitBone;
        break;
      }

      // required uint32 hitBone = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_hitBone:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &hitbone_)));
          set_has_hitbone();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_hitNormalLocal;
        break;
      }

      // required .Vector3Serialized hitNormalLocal = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_hitNormalLocal:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_hitnormallocal()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_hitPositionLocal;
        break;
      }

      // required .Vector3Serialized hitPositionLocal = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_hitPositionLocal:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_hitpositionlocal()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_hitNormalWorld;
        break;
      }

      // required .Vector3Serialized hitNormalWorld = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_hitNormalWorld:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_hitnormalworld()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_hitPositionWorld;
        break;
      }

      // required .Vector3Serialized hitPositionWorld = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_hitPositionWorld:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_hitpositionworld()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_hitPartID;
        break;
      }

      // required uint32 hitPartID = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_hitPartID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &hitpartid_)));
          set_has_hitpartid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_hitMaterialID;
        break;
      }

      // required uint32 hitMaterialID = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_hitMaterialID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &hitmaterialid_)));
          set_has_hitmaterialid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_hitItem;
        break;
      }

      // required uint32 hitItem = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_hitItem:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &hititem_)));
          set_has_hititem();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Attack::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .Vector3Serialized pointStart = 1;
  if (has_pointstart()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->pointstart(), output);
  }

  // required .Vector3Serialized pointEnd = 2;
  if (has_pointend()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->pointend(), output);
  }

  // required uint32 hitID = 3;
  if (has_hitid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->hitid(), output);
  }

  // required uint32 hitBone = 4;
  if (has_hitbone()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->hitbone(), output);
  }

  // required .Vector3Serialized hitNormalLocal = 5;
  if (has_hitnormallocal()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->hitnormallocal(), output);
  }

  // required .Vector3Serialized hitPositionLocal = 6;
  if (has_hitpositionlocal()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->hitpositionlocal(), output);
  }

  // required .Vector3Serialized hitNormalWorld = 7;
  if (has_hitnormalworld()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->hitnormalworld(), output);
  }

  // required .Vector3Serialized hitPositionWorld = 8;
  if (has_hitpositionworld()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->hitpositionworld(), output);
  }

  // required uint32 hitPartID = 9;
  if (has_hitpartid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->hitpartid(), output);
  }

  // required uint32 hitMaterialID = 10;
  if (has_hitmaterialid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->hitmaterialid(), output);
  }

  // required uint32 hitItem = 11;
  if (has_hititem()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->hititem(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Attack::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .Vector3Serialized pointStart = 1;
  if (has_pointstart()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->pointstart(), target);
  }

  // required .Vector3Serialized pointEnd = 2;
  if (has_pointend()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->pointend(), target);
  }

  // required uint32 hitID = 3;
  if (has_hitid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->hitid(), target);
  }

  // required uint32 hitBone = 4;
  if (has_hitbone()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->hitbone(), target);
  }

  // required .Vector3Serialized hitNormalLocal = 5;
  if (has_hitnormallocal()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->hitnormallocal(), target);
  }

  // required .Vector3Serialized hitPositionLocal = 6;
  if (has_hitpositionlocal()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->hitpositionlocal(), target);
  }

  // required .Vector3Serialized hitNormalWorld = 7;
  if (has_hitnormalworld()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->hitnormalworld(), target);
  }

  // required .Vector3Serialized hitPositionWorld = 8;
  if (has_hitpositionworld()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->hitpositionworld(), target);
  }

  // required uint32 hitPartID = 9;
  if (has_hitpartid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->hitpartid(), target);
  }

  // required uint32 hitMaterialID = 10;
  if (has_hitmaterialid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->hitmaterialid(), target);
  }

  // required uint32 hitItem = 11;
  if (has_hititem()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(11, this->hititem(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Attack::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Vector3Serialized pointStart = 1;
    if (has_pointstart()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->pointstart());
    }

    // required .Vector3Serialized pointEnd = 2;
    if (has_pointend()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->pointend());
    }

    // required uint32 hitID = 3;
    if (has_hitid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->hitid());
    }

    // required uint32 hitBone = 4;
    if (has_hitbone()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->hitbone());
    }

    // required .Vector3Serialized hitNormalLocal = 5;
    if (has_hitnormallocal()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->hitnormallocal());
    }

    // required .Vector3Serialized hitPositionLocal = 6;
    if (has_hitpositionlocal()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->hitpositionlocal());
    }

    // required .Vector3Serialized hitNormalWorld = 7;
    if (has_hitnormalworld()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->hitnormalworld());
    }

    // required .Vector3Serialized hitPositionWorld = 8;
    if (has_hitpositionworld()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->hitpositionworld());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required uint32 hitPartID = 9;
    if (has_hitpartid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->hitpartid());
    }

    // required uint32 hitMaterialID = 10;
    if (has_hitmaterialid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->hitmaterialid());
    }

    // required uint32 hitItem = 11;
    if (has_hititem()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->hititem());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Attack::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Attack* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Attack*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Attack::MergeFrom(const Attack& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pointstart()) {
      mutable_pointstart()->::Vector3Serialized::MergeFrom(from.pointstart());
    }
    if (from.has_pointend()) {
      mutable_pointend()->::Vector3Serialized::MergeFrom(from.pointend());
    }
    if (from.has_hitid()) {
      set_hitid(from.hitid());
    }
    if (from.has_hitbone()) {
      set_hitbone(from.hitbone());
    }
    if (from.has_hitnormallocal()) {
      mutable_hitnormallocal()->::Vector3Serialized::MergeFrom(from.hitnormallocal());
    }
    if (from.has_hitpositionlocal()) {
      mutable_hitpositionlocal()->::Vector3Serialized::MergeFrom(from.hitpositionlocal());
    }
    if (from.has_hitnormalworld()) {
      mutable_hitnormalworld()->::Vector3Serialized::MergeFrom(from.hitnormalworld());
    }
    if (from.has_hitpositionworld()) {
      mutable_hitpositionworld()->::Vector3Serialized::MergeFrom(from.hitpositionworld());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_hitpartid()) {
      set_hitpartid(from.hitpartid());
    }
    if (from.has_hitmaterialid()) {
      set_hitmaterialid(from.hitmaterialid());
    }
    if (from.has_hititem()) {
      set_hititem(from.hititem());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Attack::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Attack::CopyFrom(const Attack& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Attack::IsInitialized() const {
  if ((_has_bits_[0] & 0x000007ff) != 0x000007ff) return false;

  if (has_pointstart()) {
    if (!this->pointstart().IsInitialized()) return false;
  }
  if (has_pointend()) {
    if (!this->pointend().IsInitialized()) return false;
  }
  if (has_hitnormallocal()) {
    if (!this->hitnormallocal().IsInitialized()) return false;
  }
  if (has_hitpositionlocal()) {
    if (!this->hitpositionlocal().IsInitialized()) return false;
  }
  if (has_hitnormalworld()) {
    if (!this->hitnormalworld().IsInitialized()) return false;
  }
  if (has_hitpositionworld()) {
    if (!this->hitpositionworld().IsInitialized()) return false;
  }
  return true;
}

void Attack::Swap(Attack* other) {
  if (other != this) {
    std::swap(pointstart_, other->pointstart_);
    std::swap(pointend_, other->pointend_);
    std::swap(hitid_, other->hitid_);
    std::swap(hitbone_, other->hitbone_);
    std::swap(hitnormallocal_, other->hitnormallocal_);
    std::swap(hitpositionlocal_, other->hitpositionlocal_);
    std::swap(hitnormalworld_, other->hitnormalworld_);
    std::swap(hitpositionworld_, other->hitpositionworld_);
    std::swap(hitpartid_, other->hitpartid_);
    std::swap(hitmaterialid_, other->hitmaterialid_);
    std::swap(hititem_, other->hititem_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Attack::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Attack_descriptor_;
  metadata.reflection = Attack_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClientReady_ClientInfo::kNameFieldNumber;
const int ClientReady_ClientInfo::kValueFieldNumber;
#endif  // !_MSC_VER

ClientReady_ClientInfo::ClientReady_ClientInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClientReady_ClientInfo::InitAsDefaultInstance() {
}

ClientReady_ClientInfo::ClientReady_ClientInfo(const ClientReady_ClientInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClientReady_ClientInfo::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientReady_ClientInfo::~ClientReady_ClientInfo() {
  SharedDtor();
}

void ClientReady_ClientInfo::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (this != default_instance_) {
  }
}

void ClientReady_ClientInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClientReady_ClientInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClientReady_ClientInfo_descriptor_;
}

const ClientReady_ClientInfo& ClientReady_ClientInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

ClientReady_ClientInfo* ClientReady_ClientInfo::default_instance_ = NULL;

ClientReady_ClientInfo* ClientReady_ClientInfo::New() const {
  return new ClientReady_ClientInfo;
}

void ClientReady_ClientInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_value()) {
      if (value_ != &::google::protobuf::internal::kEmptyString) {
        value_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClientReady_ClientInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // required string value = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClientReady_ClientInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // required string value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->value(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClientReady_ClientInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required string value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->value(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClientReady_ClientInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required string value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientReady_ClientInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClientReady_ClientInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClientReady_ClientInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClientReady_ClientInfo::MergeFrom(const ClientReady_ClientInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClientReady_ClientInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClientReady_ClientInfo::CopyFrom(const ClientReady_ClientInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientReady_ClientInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ClientReady_ClientInfo::Swap(ClientReady_ClientInfo* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClientReady_ClientInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClientReady_ClientInfo_descriptor_;
  metadata.reflection = ClientReady_ClientInfo_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int ClientReady::kClientInfoFieldNumber;
#endif  // !_MSC_VER

ClientReady::ClientReady()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClientReady::InitAsDefaultInstance() {
}

ClientReady::ClientReady(const ClientReady& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClientReady::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientReady::~ClientReady() {
  SharedDtor();
}

void ClientReady::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClientReady::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClientReady::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClientReady_descriptor_;
}

const ClientReady& ClientReady::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

ClientReady* ClientReady::default_instance_ = NULL;

ClientReady* ClientReady::New() const {
  return new ClientReady;
}

void ClientReady::Clear() {
  clientinfo_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClientReady::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ClientReady.ClientInfo clientInfo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_clientInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_clientinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_clientInfo;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClientReady::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .ClientReady.ClientInfo clientInfo = 1;
  for (int i = 0; i < this->clientinfo_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->clientinfo(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClientReady::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .ClientReady.ClientInfo clientInfo = 1;
  for (int i = 0; i < this->clientinfo_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->clientinfo(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClientReady::ByteSize() const {
  int total_size = 0;

  // repeated .ClientReady.ClientInfo clientInfo = 1;
  total_size += 1 * this->clientinfo_size();
  for (int i = 0; i < this->clientinfo_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->clientinfo(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientReady::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClientReady* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClientReady*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClientReady::MergeFrom(const ClientReady& from) {
  GOOGLE_CHECK_NE(&from, this);
  clientinfo_.MergeFrom(from.clientinfo_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClientReady::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClientReady::CopyFrom(const ClientReady& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientReady::IsInitialized() const {

  for (int i = 0; i < clientinfo_size(); i++) {
    if (!this->clientinfo(i).IsInitialized()) return false;
  }
  return true;
}

void ClientReady::Swap(ClientReady* other) {
  if (other != this) {
    clientinfo_.Swap(&other->clientinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClientReady::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClientReady_descriptor_;
  metadata.reflection = ClientReady_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CreateBuilding::kEntityFieldNumber;
const int CreateBuilding::kSocketFieldNumber;
const int CreateBuilding::kOnterrainFieldNumber;
const int CreateBuilding::kPositionFieldNumber;
const int CreateBuilding::kNormalFieldNumber;
const int CreateBuilding::kRayFieldNumber;
const int CreateBuilding::kBlockIDFieldNumber;
const int CreateBuilding::kRotationFieldNumber;
#endif  // !_MSC_VER

CreateBuilding::CreateBuilding()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CreateBuilding::InitAsDefaultInstance() {
  position_ = const_cast< ::Vector3Serialized*>(&::Vector3Serialized::default_instance());
  normal_ = const_cast< ::Vector3Serialized*>(&::Vector3Serialized::default_instance());
  ray_ = const_cast< ::RaySerialized*>(&::RaySerialized::default_instance());
  rotation_ = const_cast< ::Vector3Serialized*>(&::Vector3Serialized::default_instance());
}

CreateBuilding::CreateBuilding(const CreateBuilding& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CreateBuilding::SharedCtor() {
  _cached_size_ = 0;
  entity_ = 0u;
  socket_ = 0u;
  onterrain_ = false;
  position_ = NULL;
  normal_ = NULL;
  ray_ = NULL;
  blockid_ = 0u;
  rotation_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CreateBuilding::~CreateBuilding() {
  SharedDtor();
}

void CreateBuilding::SharedDtor() {
  if (this != default_instance_) {
    delete position_;
    delete normal_;
    delete ray_;
    delete rotation_;
  }
}

void CreateBuilding::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CreateBuilding::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CreateBuilding_descriptor_;
}

const CreateBuilding& CreateBuilding::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

CreateBuilding* CreateBuilding::default_instance_ = NULL;

CreateBuilding* CreateBuilding::New() const {
  return new CreateBuilding;
}

void CreateBuilding::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    entity_ = 0u;
    socket_ = 0u;
    onterrain_ = false;
    if (has_position()) {
      if (position_ != NULL) position_->::Vector3Serialized::Clear();
    }
    if (has_normal()) {
      if (normal_ != NULL) normal_->::Vector3Serialized::Clear();
    }
    if (has_ray()) {
      if (ray_ != NULL) ray_->::RaySerialized::Clear();
    }
    blockid_ = 0u;
    if (has_rotation()) {
      if (rotation_ != NULL) rotation_->::Vector3Serialized::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CreateBuilding::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 entity = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &entity_)));
          set_has_entity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_socket;
        break;
      }

      // required uint32 socket = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_socket:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &socket_)));
          set_has_socket();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_onterrain;
        break;
      }

      // required bool onterrain = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_onterrain:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &onterrain_)));
          set_has_onterrain();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_position;
        break;
      }

      // required .Vector3Serialized position = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_position:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_position()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_normal;
        break;
      }

      // required .Vector3Serialized normal = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_normal:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_normal()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_ray;
        break;
      }

      // required .RaySerialized ray = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ray:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ray()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_blockID;
        break;
      }

      // required uint32 blockID = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_blockID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &blockid_)));
          set_has_blockid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_rotation;
        break;
      }

      // required .Vector3Serialized rotation = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_rotation:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_rotation()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CreateBuilding::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 entity = 1;
  if (has_entity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->entity(), output);
  }

  // required uint32 socket = 2;
  if (has_socket()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->socket(), output);
  }

  // required bool onterrain = 3;
  if (has_onterrain()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->onterrain(), output);
  }

  // required .Vector3Serialized position = 4;
  if (has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->position(), output);
  }

  // required .Vector3Serialized normal = 5;
  if (has_normal()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->normal(), output);
  }

  // required .RaySerialized ray = 6;
  if (has_ray()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->ray(), output);
  }

  // required uint32 blockID = 7;
  if (has_blockid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->blockid(), output);
  }

  // required .Vector3Serialized rotation = 8;
  if (has_rotation()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->rotation(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CreateBuilding::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 entity = 1;
  if (has_entity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->entity(), target);
  }

  // required uint32 socket = 2;
  if (has_socket()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->socket(), target);
  }

  // required bool onterrain = 3;
  if (has_onterrain()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->onterrain(), target);
  }

  // required .Vector3Serialized position = 4;
  if (has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->position(), target);
  }

  // required .Vector3Serialized normal = 5;
  if (has_normal()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->normal(), target);
  }

  // required .RaySerialized ray = 6;
  if (has_ray()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->ray(), target);
  }

  // required uint32 blockID = 7;
  if (has_blockid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->blockid(), target);
  }

  // required .Vector3Serialized rotation = 8;
  if (has_rotation()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->rotation(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CreateBuilding::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 entity = 1;
    if (has_entity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->entity());
    }

    // required uint32 socket = 2;
    if (has_socket()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->socket());
    }

    // required bool onterrain = 3;
    if (has_onterrain()) {
      total_size += 1 + 1;
    }

    // required .Vector3Serialized position = 4;
    if (has_position()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->position());
    }

    // required .Vector3Serialized normal = 5;
    if (has_normal()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->normal());
    }

    // required .RaySerialized ray = 6;
    if (has_ray()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ray());
    }

    // required uint32 blockID = 7;
    if (has_blockid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->blockid());
    }

    // required .Vector3Serialized rotation = 8;
    if (has_rotation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->rotation());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CreateBuilding::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CreateBuilding* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CreateBuilding*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CreateBuilding::MergeFrom(const CreateBuilding& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_entity()) {
      set_entity(from.entity());
    }
    if (from.has_socket()) {
      set_socket(from.socket());
    }
    if (from.has_onterrain()) {
      set_onterrain(from.onterrain());
    }
    if (from.has_position()) {
      mutable_position()->::Vector3Serialized::MergeFrom(from.position());
    }
    if (from.has_normal()) {
      mutable_normal()->::Vector3Serialized::MergeFrom(from.normal());
    }
    if (from.has_ray()) {
      mutable_ray()->::RaySerialized::MergeFrom(from.ray());
    }
    if (from.has_blockid()) {
      set_blockid(from.blockid());
    }
    if (from.has_rotation()) {
      mutable_rotation()->::Vector3Serialized::MergeFrom(from.rotation());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CreateBuilding::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CreateBuilding::CopyFrom(const CreateBuilding& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateBuilding::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000ff) != 0x000000ff) return false;

  if (has_position()) {
    if (!this->position().IsInitialized()) return false;
  }
  if (has_normal()) {
    if (!this->normal().IsInitialized()) return false;
  }
  if (has_ray()) {
    if (!this->ray().IsInitialized()) return false;
  }
  if (has_rotation()) {
    if (!this->rotation().IsInitialized()) return false;
  }
  return true;
}

void CreateBuilding::Swap(CreateBuilding* other) {
  if (other != this) {
    std::swap(entity_, other->entity_);
    std::swap(socket_, other->socket_);
    std::swap(onterrain_, other->onterrain_);
    std::swap(position_, other->position_);
    std::swap(normal_, other->normal_);
    std::swap(ray_, other->ray_);
    std::swap(blockid_, other->blockid_);
    std::swap(rotation_, other->rotation_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CreateBuilding::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CreateBuilding_descriptor_;
  metadata.reflection = CreateBuilding_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EntityList::kEntityFieldNumber;
#endif  // !_MSC_VER

EntityList::EntityList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void EntityList::InitAsDefaultInstance() {
}

EntityList::EntityList(const EntityList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void EntityList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EntityList::~EntityList() {
  SharedDtor();
}

void EntityList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void EntityList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EntityList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EntityList_descriptor_;
}

const EntityList& EntityList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

EntityList* EntityList::default_instance_ = NULL;

EntityList* EntityList::New() const {
  return new EntityList;
}

void EntityList::Clear() {
  entity_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EntityList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Entity entity = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_entity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_entity()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_entity;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EntityList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Entity entity = 1;
  for (int i = 0; i < this->entity_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->entity(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* EntityList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .Entity entity = 1;
  for (int i = 0; i < this->entity_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->entity(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int EntityList::ByteSize() const {
  int total_size = 0;

  // repeated .Entity entity = 1;
  total_size += 1 * this->entity_size();
  for (int i = 0; i < this->entity_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->entity(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EntityList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EntityList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EntityList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EntityList::MergeFrom(const EntityList& from) {
  GOOGLE_CHECK_NE(&from, this);
  entity_.MergeFrom(from.entity_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EntityList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EntityList::CopyFrom(const EntityList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EntityList::IsInitialized() const {

  for (int i = 0; i < entity_size(); i++) {
    if (!this->entity(i).IsInitialized()) return false;
  }
  return true;
}

void EntityList::Swap(EntityList* other) {
  if (other != this) {
    entity_.Swap(&other->entity_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EntityList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EntityList_descriptor_;
  metadata.reflection = EntityList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ModuleMessage::kItemidFieldNumber;
const int ModuleMessage::kModuleidFieldNumber;
const int ModuleMessage::kTypeFieldNumber;
const int ModuleMessage::kDataFieldNumber;
#endif  // !_MSC_VER

ModuleMessage::ModuleMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ModuleMessage::InitAsDefaultInstance() {
}

ModuleMessage::ModuleMessage(const ModuleMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ModuleMessage::SharedCtor() {
  _cached_size_ = 0;
  itemid_ = 0u;
  moduleid_ = GOOGLE_ULONGLONG(0);
  type_ = GOOGLE_ULONGLONG(0);
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ModuleMessage::~ModuleMessage() {
  SharedDtor();
}

void ModuleMessage::SharedDtor() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (this != default_instance_) {
  }
}

void ModuleMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ModuleMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ModuleMessage_descriptor_;
}

const ModuleMessage& ModuleMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

ModuleMessage* ModuleMessage::default_instance_ = NULL;

ModuleMessage* ModuleMessage::New() const {
  return new ModuleMessage;
}

void ModuleMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    itemid_ = 0u;
    moduleid_ = GOOGLE_ULONGLONG(0);
    type_ = GOOGLE_ULONGLONG(0);
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::kEmptyString) {
        data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ModuleMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 itemid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_moduleid;
        break;
      }

      // required uint64 moduleid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_moduleid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &moduleid_)));
          set_has_moduleid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_type;
        break;
      }

      // required uint64 type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_data;
        break;
      }

      // optional bytes data = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ModuleMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 itemid = 1;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->itemid(), output);
  }

  // required uint64 moduleid = 2;
  if (has_moduleid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->moduleid(), output);
  }

  // required uint64 type = 3;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->type(), output);
  }

  // optional bytes data = 4;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->data(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ModuleMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 itemid = 1;
  if (has_itemid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->itemid(), target);
  }

  // required uint64 moduleid = 2;
  if (has_moduleid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->moduleid(), target);
  }

  // required uint64 type = 3;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->type(), target);
  }

  // optional bytes data = 4;
  if (has_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->data(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ModuleMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 itemid = 1;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->itemid());
    }

    // required uint64 moduleid = 2;
    if (has_moduleid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->moduleid());
    }

    // required uint64 type = 3;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->type());
    }

    // optional bytes data = 4;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ModuleMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ModuleMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ModuleMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ModuleMessage::MergeFrom(const ModuleMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
    if (from.has_moduleid()) {
      set_moduleid(from.moduleid());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ModuleMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ModuleMessage::CopyFrom(const ModuleMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModuleMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void ModuleMessage::Swap(ModuleMessage* other) {
  if (other != this) {
    std::swap(itemid_, other->itemid_);
    std::swap(moduleid_, other->moduleid_);
    std::swap(type_, other->type_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ModuleMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ModuleMessage_descriptor_;
  metadata.reflection = ModuleMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PlayerAttack::kAttackFieldNumber;
const int PlayerAttack::kProjectileIDFieldNumber;
#endif  // !_MSC_VER

PlayerAttack::PlayerAttack()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PlayerAttack::InitAsDefaultInstance() {
  attack_ = const_cast< ::Attack*>(&::Attack::default_instance());
}

PlayerAttack::PlayerAttack(const PlayerAttack& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PlayerAttack::SharedCtor() {
  _cached_size_ = 0;
  attack_ = NULL;
  projectileid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlayerAttack::~PlayerAttack() {
  SharedDtor();
}

void PlayerAttack::SharedDtor() {
  if (this != default_instance_) {
    delete attack_;
  }
}

void PlayerAttack::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PlayerAttack::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PlayerAttack_descriptor_;
}

const PlayerAttack& PlayerAttack::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

PlayerAttack* PlayerAttack::default_instance_ = NULL;

PlayerAttack* PlayerAttack::New() const {
  return new PlayerAttack;
}

void PlayerAttack::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_attack()) {
      if (attack_ != NULL) attack_->::Attack::Clear();
    }
    projectileid_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PlayerAttack::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Attack attack = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_attack()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_projectileID;
        break;
      }

      // required uint64 projectileID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_projectileID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &projectileid_)));
          set_has_projectileid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PlayerAttack::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .Attack attack = 1;
  if (has_attack()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->attack(), output);
  }

  // required uint64 projectileID = 2;
  if (has_projectileid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->projectileid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PlayerAttack::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .Attack attack = 1;
  if (has_attack()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->attack(), target);
  }

  // required uint64 projectileID = 2;
  if (has_projectileid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->projectileid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PlayerAttack::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Attack attack = 1;
    if (has_attack()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->attack());
    }

    // required uint64 projectileID = 2;
    if (has_projectileid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->projectileid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlayerAttack::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PlayerAttack* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PlayerAttack*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PlayerAttack::MergeFrom(const PlayerAttack& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_attack()) {
      mutable_attack()->::Attack::MergeFrom(from.attack());
    }
    if (from.has_projectileid()) {
      set_projectileid(from.projectileid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PlayerAttack::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PlayerAttack::CopyFrom(const PlayerAttack& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerAttack::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_attack()) {
    if (!this->attack().IsInitialized()) return false;
  }
  return true;
}

void PlayerAttack::Swap(PlayerAttack* other) {
  if (other != this) {
    std::swap(attack_, other->attack_);
    std::swap(projectileid_, other->projectileid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PlayerAttack::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PlayerAttack_descriptor_;
  metadata.reflection = PlayerAttack_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PlayerProjectileAttack::kPlayerAttackFieldNumber;
const int PlayerProjectileAttack::kHitVelocityFieldNumber;
const int PlayerProjectileAttack::kHitDistanceFieldNumber;
#endif  // !_MSC_VER

PlayerProjectileAttack::PlayerProjectileAttack()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PlayerProjectileAttack::InitAsDefaultInstance() {
  playerattack_ = const_cast< ::PlayerAttack*>(&::PlayerAttack::default_instance());
  hitvelocity_ = const_cast< ::Vector3Serialized*>(&::Vector3Serialized::default_instance());
}

PlayerProjectileAttack::PlayerProjectileAttack(const PlayerProjectileAttack& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PlayerProjectileAttack::SharedCtor() {
  _cached_size_ = 0;
  playerattack_ = NULL;
  hitvelocity_ = NULL;
  hitdistance_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlayerProjectileAttack::~PlayerProjectileAttack() {
  SharedDtor();
}

void PlayerProjectileAttack::SharedDtor() {
  if (this != default_instance_) {
    delete playerattack_;
    delete hitvelocity_;
  }
}

void PlayerProjectileAttack::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PlayerProjectileAttack::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PlayerProjectileAttack_descriptor_;
}

const PlayerProjectileAttack& PlayerProjectileAttack::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

PlayerProjectileAttack* PlayerProjectileAttack::default_instance_ = NULL;

PlayerProjectileAttack* PlayerProjectileAttack::New() const {
  return new PlayerProjectileAttack;
}

void PlayerProjectileAttack::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_playerattack()) {
      if (playerattack_ != NULL) playerattack_->::PlayerAttack::Clear();
    }
    if (has_hitvelocity()) {
      if (hitvelocity_ != NULL) hitvelocity_->::Vector3Serialized::Clear();
    }
    hitdistance_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PlayerProjectileAttack::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .PlayerAttack playerAttack = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_playerattack()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_hitVelocity;
        break;
      }

      // required .Vector3Serialized hitVelocity = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_hitVelocity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_hitvelocity()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_hitDistance;
        break;
      }

      // required float hitDistance = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_hitDistance:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &hitdistance_)));
          set_has_hitdistance();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PlayerProjectileAttack::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .PlayerAttack playerAttack = 1;
  if (has_playerattack()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->playerattack(), output);
  }

  // required .Vector3Serialized hitVelocity = 2;
  if (has_hitvelocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->hitvelocity(), output);
  }

  // required float hitDistance = 3;
  if (has_hitdistance()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->hitdistance(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PlayerProjectileAttack::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .PlayerAttack playerAttack = 1;
  if (has_playerattack()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->playerattack(), target);
  }

  // required .Vector3Serialized hitVelocity = 2;
  if (has_hitvelocity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->hitvelocity(), target);
  }

  // required float hitDistance = 3;
  if (has_hitdistance()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->hitdistance(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PlayerProjectileAttack::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .PlayerAttack playerAttack = 1;
    if (has_playerattack()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->playerattack());
    }

    // required .Vector3Serialized hitVelocity = 2;
    if (has_hitvelocity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->hitvelocity());
    }

    // required float hitDistance = 3;
    if (has_hitdistance()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlayerProjectileAttack::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PlayerProjectileAttack* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PlayerProjectileAttack*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PlayerProjectileAttack::MergeFrom(const PlayerProjectileAttack& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_playerattack()) {
      mutable_playerattack()->::PlayerAttack::MergeFrom(from.playerattack());
    }
    if (from.has_hitvelocity()) {
      mutable_hitvelocity()->::Vector3Serialized::MergeFrom(from.hitvelocity());
    }
    if (from.has_hitdistance()) {
      set_hitdistance(from.hitdistance());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PlayerProjectileAttack::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PlayerProjectileAttack::CopyFrom(const PlayerProjectileAttack& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerProjectileAttack::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_playerattack()) {
    if (!this->playerattack().IsInitialized()) return false;
  }
  if (has_hitvelocity()) {
    if (!this->hitvelocity().IsInitialized()) return false;
  }
  return true;
}

void PlayerProjectileAttack::Swap(PlayerProjectileAttack* other) {
  if (other != this) {
    std::swap(playerattack_, other->playerattack_);
    std::swap(hitvelocity_, other->hitvelocity_);
    std::swap(hitdistance_, other->hitdistance_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PlayerProjectileAttack::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PlayerProjectileAttack_descriptor_;
  metadata.reflection = PlayerProjectileAttack_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PlayerProjectileRicochet::kProjectileIDFieldNumber;
const int PlayerProjectileRicochet::kHitPositionFieldNumber;
const int PlayerProjectileRicochet::kInVelocityFieldNumber;
const int PlayerProjectileRicochet::kOutVelocityFieldNumber;
#endif  // !_MSC_VER

PlayerProjectileRicochet::PlayerProjectileRicochet()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PlayerProjectileRicochet::InitAsDefaultInstance() {
  hitposition_ = const_cast< ::Vector3Serialized*>(&::Vector3Serialized::default_instance());
  invelocity_ = const_cast< ::Vector3Serialized*>(&::Vector3Serialized::default_instance());
  outvelocity_ = const_cast< ::Vector3Serialized*>(&::Vector3Serialized::default_instance());
}

PlayerProjectileRicochet::PlayerProjectileRicochet(const PlayerProjectileRicochet& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PlayerProjectileRicochet::SharedCtor() {
  _cached_size_ = 0;
  projectileid_ = GOOGLE_ULONGLONG(0);
  hitposition_ = NULL;
  invelocity_ = NULL;
  outvelocity_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlayerProjectileRicochet::~PlayerProjectileRicochet() {
  SharedDtor();
}

void PlayerProjectileRicochet::SharedDtor() {
  if (this != default_instance_) {
    delete hitposition_;
    delete invelocity_;
    delete outvelocity_;
  }
}

void PlayerProjectileRicochet::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PlayerProjectileRicochet::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PlayerProjectileRicochet_descriptor_;
}

const PlayerProjectileRicochet& PlayerProjectileRicochet::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

PlayerProjectileRicochet* PlayerProjectileRicochet::default_instance_ = NULL;

PlayerProjectileRicochet* PlayerProjectileRicochet::New() const {
  return new PlayerProjectileRicochet;
}

void PlayerProjectileRicochet::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    projectileid_ = GOOGLE_ULONGLONG(0);
    if (has_hitposition()) {
      if (hitposition_ != NULL) hitposition_->::Vector3Serialized::Clear();
    }
    if (has_invelocity()) {
      if (invelocity_ != NULL) invelocity_->::Vector3Serialized::Clear();
    }
    if (has_outvelocity()) {
      if (outvelocity_ != NULL) outvelocity_->::Vector3Serialized::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PlayerProjectileRicochet::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 projectileID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &projectileid_)));
          set_has_projectileid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_hitPosition;
        break;
      }

      // required .Vector3Serialized hitPosition = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_hitPosition:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_hitposition()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_inVelocity;
        break;
      }

      // required .Vector3Serialized inVelocity = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_inVelocity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_invelocity()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_outVelocity;
        break;
      }

      // required .Vector3Serialized outVelocity = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_outVelocity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_outvelocity()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PlayerProjectileRicochet::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 projectileID = 1;
  if (has_projectileid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->projectileid(), output);
  }

  // required .Vector3Serialized hitPosition = 2;
  if (has_hitposition()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->hitposition(), output);
  }

  // required .Vector3Serialized inVelocity = 3;
  if (has_invelocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->invelocity(), output);
  }

  // required .Vector3Serialized outVelocity = 4;
  if (has_outvelocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->outvelocity(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PlayerProjectileRicochet::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 projectileID = 1;
  if (has_projectileid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->projectileid(), target);
  }

  // required .Vector3Serialized hitPosition = 2;
  if (has_hitposition()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->hitposition(), target);
  }

  // required .Vector3Serialized inVelocity = 3;
  if (has_invelocity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->invelocity(), target);
  }

  // required .Vector3Serialized outVelocity = 4;
  if (has_outvelocity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->outvelocity(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PlayerProjectileRicochet::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 projectileID = 1;
    if (has_projectileid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->projectileid());
    }

    // required .Vector3Serialized hitPosition = 2;
    if (has_hitposition()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->hitposition());
    }

    // required .Vector3Serialized inVelocity = 3;
    if (has_invelocity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->invelocity());
    }

    // required .Vector3Serialized outVelocity = 4;
    if (has_outvelocity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->outvelocity());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlayerProjectileRicochet::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PlayerProjectileRicochet* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PlayerProjectileRicochet*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PlayerProjectileRicochet::MergeFrom(const PlayerProjectileRicochet& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_projectileid()) {
      set_projectileid(from.projectileid());
    }
    if (from.has_hitposition()) {
      mutable_hitposition()->::Vector3Serialized::MergeFrom(from.hitposition());
    }
    if (from.has_invelocity()) {
      mutable_invelocity()->::Vector3Serialized::MergeFrom(from.invelocity());
    }
    if (from.has_outvelocity()) {
      mutable_outvelocity()->::Vector3Serialized::MergeFrom(from.outvelocity());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PlayerProjectileRicochet::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PlayerProjectileRicochet::CopyFrom(const PlayerProjectileRicochet& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerProjectileRicochet::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_hitposition()) {
    if (!this->hitposition().IsInitialized()) return false;
  }
  if (has_invelocity()) {
    if (!this->invelocity().IsInitialized()) return false;
  }
  if (has_outvelocity()) {
    if (!this->outvelocity().IsInitialized()) return false;
  }
  return true;
}

void PlayerProjectileRicochet::Swap(PlayerProjectileRicochet* other) {
  if (other != this) {
    std::swap(projectileid_, other->projectileid_);
    std::swap(hitposition_, other->hitposition_);
    std::swap(invelocity_, other->invelocity_);
    std::swap(outvelocity_, other->outvelocity_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PlayerProjectileRicochet::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PlayerProjectileRicochet_descriptor_;
  metadata.reflection = PlayerProjectileRicochet_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PlayerProjectileUpdate::kProjectileIDFieldNumber;
const int PlayerProjectileUpdate::kCurPositionFieldNumber;
#endif  // !_MSC_VER

PlayerProjectileUpdate::PlayerProjectileUpdate()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PlayerProjectileUpdate::InitAsDefaultInstance() {
  curposition_ = const_cast< ::Vector3Serialized*>(&::Vector3Serialized::default_instance());
}

PlayerProjectileUpdate::PlayerProjectileUpdate(const PlayerProjectileUpdate& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PlayerProjectileUpdate::SharedCtor() {
  _cached_size_ = 0;
  projectileid_ = GOOGLE_ULONGLONG(0);
  curposition_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlayerProjectileUpdate::~PlayerProjectileUpdate() {
  SharedDtor();
}

void PlayerProjectileUpdate::SharedDtor() {
  if (this != default_instance_) {
    delete curposition_;
  }
}

void PlayerProjectileUpdate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PlayerProjectileUpdate::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PlayerProjectileUpdate_descriptor_;
}

const PlayerProjectileUpdate& PlayerProjectileUpdate::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

PlayerProjectileUpdate* PlayerProjectileUpdate::default_instance_ = NULL;

PlayerProjectileUpdate* PlayerProjectileUpdate::New() const {
  return new PlayerProjectileUpdate;
}

void PlayerProjectileUpdate::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    projectileid_ = GOOGLE_ULONGLONG(0);
    if (has_curposition()) {
      if (curposition_ != NULL) curposition_->::Vector3Serialized::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PlayerProjectileUpdate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 projectileID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &projectileid_)));
          set_has_projectileid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_curPosition;
        break;
      }

      // required .Vector3Serialized curPosition = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_curPosition:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_curposition()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PlayerProjectileUpdate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 projectileID = 1;
  if (has_projectileid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->projectileid(), output);
  }

  // required .Vector3Serialized curPosition = 2;
  if (has_curposition()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->curposition(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PlayerProjectileUpdate::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 projectileID = 1;
  if (has_projectileid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->projectileid(), target);
  }

  // required .Vector3Serialized curPosition = 2;
  if (has_curposition()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->curposition(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PlayerProjectileUpdate::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 projectileID = 1;
    if (has_projectileid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->projectileid());
    }

    // required .Vector3Serialized curPosition = 2;
    if (has_curposition()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->curposition());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlayerProjectileUpdate::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PlayerProjectileUpdate* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PlayerProjectileUpdate*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PlayerProjectileUpdate::MergeFrom(const PlayerProjectileUpdate& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_projectileid()) {
      set_projectileid(from.projectileid());
    }
    if (from.has_curposition()) {
      mutable_curposition()->::Vector3Serialized::MergeFrom(from.curposition());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PlayerProjectileUpdate::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PlayerProjectileUpdate::CopyFrom(const PlayerProjectileUpdate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerProjectileUpdate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_curposition()) {
    if (!this->curposition().IsInitialized()) return false;
  }
  return true;
}

void PlayerProjectileUpdate::Swap(PlayerProjectileUpdate* other) {
  if (other != this) {
    std::swap(projectileid_, other->projectileid_);
    std::swap(curposition_, other->curposition_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PlayerProjectileUpdate::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PlayerProjectileUpdate_descriptor_;
  metadata.reflection = PlayerProjectileUpdate_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PlayerUpdateLoot::kItemIDFieldNumber;
const int PlayerUpdateLoot::kEntityIDFieldNumber;
const int PlayerUpdateLoot::kContainersFieldNumber;
#endif  // !_MSC_VER

PlayerUpdateLoot::PlayerUpdateLoot()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PlayerUpdateLoot::InitAsDefaultInstance() {
}

PlayerUpdateLoot::PlayerUpdateLoot(const PlayerUpdateLoot& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PlayerUpdateLoot::SharedCtor() {
  _cached_size_ = 0;
  itemid_ = 0u;
  entityid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlayerUpdateLoot::~PlayerUpdateLoot() {
  SharedDtor();
}

void PlayerUpdateLoot::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PlayerUpdateLoot::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PlayerUpdateLoot::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PlayerUpdateLoot_descriptor_;
}

const PlayerUpdateLoot& PlayerUpdateLoot::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

PlayerUpdateLoot* PlayerUpdateLoot::default_instance_ = NULL;

PlayerUpdateLoot* PlayerUpdateLoot::New() const {
  return new PlayerUpdateLoot;
}

void PlayerUpdateLoot::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    itemid_ = 0u;
    entityid_ = 0u;
  }
  containers_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PlayerUpdateLoot::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 itemID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_entityID;
        break;
      }

      // required uint32 entityID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_entityID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &entityid_)));
          set_has_entityid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_containers;
        break;
      }

      // repeated .ItemContainer containers = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_containers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_containers()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_containers;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PlayerUpdateLoot::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 itemID = 1;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->itemid(), output);
  }

  // required uint32 entityID = 2;
  if (has_entityid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->entityid(), output);
  }

  // repeated .ItemContainer containers = 3;
  for (int i = 0; i < this->containers_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->containers(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PlayerUpdateLoot::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 itemID = 1;
  if (has_itemid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->itemid(), target);
  }

  // required uint32 entityID = 2;
  if (has_entityid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->entityid(), target);
  }

  // repeated .ItemContainer containers = 3;
  for (int i = 0; i < this->containers_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->containers(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PlayerUpdateLoot::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 itemID = 1;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->itemid());
    }

    // required uint32 entityID = 2;
    if (has_entityid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->entityid());
    }

  }
  // repeated .ItemContainer containers = 3;
  total_size += 1 * this->containers_size();
  for (int i = 0; i < this->containers_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->containers(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlayerUpdateLoot::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PlayerUpdateLoot* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PlayerUpdateLoot*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PlayerUpdateLoot::MergeFrom(const PlayerUpdateLoot& from) {
  GOOGLE_CHECK_NE(&from, this);
  containers_.MergeFrom(from.containers_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
    if (from.has_entityid()) {
      set_entityid(from.entityid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PlayerUpdateLoot::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PlayerUpdateLoot::CopyFrom(const PlayerUpdateLoot& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerUpdateLoot::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  for (int i = 0; i < containers_size(); i++) {
    if (!this->containers(i).IsInitialized()) return false;
  }
  return true;
}

void PlayerUpdateLoot::Swap(PlayerUpdateLoot* other) {
  if (other != this) {
    std::swap(itemid_, other->itemid_);
    std::swap(entityid_, other->entityid_);
    containers_.Swap(&other->containers_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PlayerUpdateLoot::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PlayerUpdateLoot_descriptor_;
  metadata.reflection = PlayerUpdateLoot_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ProjectileShoot_Projectile::kProjectileIDFieldNumber;
const int ProjectileShoot_Projectile::kStartPosFieldNumber;
const int ProjectileShoot_Projectile::kStartVelFieldNumber;
const int ProjectileShoot_Projectile::kSeedFieldNumber;
#endif  // !_MSC_VER

ProjectileShoot_Projectile::ProjectileShoot_Projectile()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ProjectileShoot_Projectile::InitAsDefaultInstance() {
  startpos_ = const_cast< ::Vector3Serialized*>(&::Vector3Serialized::default_instance());
  startvel_ = const_cast< ::Vector3Serialized*>(&::Vector3Serialized::default_instance());
}

ProjectileShoot_Projectile::ProjectileShoot_Projectile(const ProjectileShoot_Projectile& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ProjectileShoot_Projectile::SharedCtor() {
  _cached_size_ = 0;
  projectileid_ = GOOGLE_ULONGLONG(0);
  startpos_ = NULL;
  startvel_ = NULL;
  seed_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ProjectileShoot_Projectile::~ProjectileShoot_Projectile() {
  SharedDtor();
}

void ProjectileShoot_Projectile::SharedDtor() {
  if (this != default_instance_) {
    delete startpos_;
    delete startvel_;
  }
}

void ProjectileShoot_Projectile::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ProjectileShoot_Projectile::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ProjectileShoot_Projectile_descriptor_;
}

const ProjectileShoot_Projectile& ProjectileShoot_Projectile::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

ProjectileShoot_Projectile* ProjectileShoot_Projectile::default_instance_ = NULL;

ProjectileShoot_Projectile* ProjectileShoot_Projectile::New() const {
  return new ProjectileShoot_Projectile;
}

void ProjectileShoot_Projectile::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    projectileid_ = GOOGLE_ULONGLONG(0);
    if (has_startpos()) {
      if (startpos_ != NULL) startpos_->::Vector3Serialized::Clear();
    }
    if (has_startvel()) {
      if (startvel_ != NULL) startvel_->::Vector3Serialized::Clear();
    }
    seed_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ProjectileShoot_Projectile::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 projectileID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &projectileid_)));
          set_has_projectileid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_startPos;
        break;
      }

      // required .Vector3Serialized startPos = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_startPos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_startpos()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_startVel;
        break;
      }

      // required .Vector3Serialized startVel = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_startVel:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_startvel()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_seed;
        break;
      }

      // required uint64 seed = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_seed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &seed_)));
          set_has_seed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ProjectileShoot_Projectile::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 projectileID = 1;
  if (has_projectileid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->projectileid(), output);
  }

  // required .Vector3Serialized startPos = 2;
  if (has_startpos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->startpos(), output);
  }

  // required .Vector3Serialized startVel = 3;
  if (has_startvel()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->startvel(), output);
  }

  // required uint64 seed = 4;
  if (has_seed()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->seed(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ProjectileShoot_Projectile::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 projectileID = 1;
  if (has_projectileid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->projectileid(), target);
  }

  // required .Vector3Serialized startPos = 2;
  if (has_startpos()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->startpos(), target);
  }

  // required .Vector3Serialized startVel = 3;
  if (has_startvel()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->startvel(), target);
  }

  // required uint64 seed = 4;
  if (has_seed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->seed(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ProjectileShoot_Projectile::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 projectileID = 1;
    if (has_projectileid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->projectileid());
    }

    // required .Vector3Serialized startPos = 2;
    if (has_startpos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->startpos());
    }

    // required .Vector3Serialized startVel = 3;
    if (has_startvel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->startvel());
    }

    // required uint64 seed = 4;
    if (has_seed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->seed());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ProjectileShoot_Projectile::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ProjectileShoot_Projectile* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ProjectileShoot_Projectile*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ProjectileShoot_Projectile::MergeFrom(const ProjectileShoot_Projectile& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_projectileid()) {
      set_projectileid(from.projectileid());
    }
    if (from.has_startpos()) {
      mutable_startpos()->::Vector3Serialized::MergeFrom(from.startpos());
    }
    if (from.has_startvel()) {
      mutable_startvel()->::Vector3Serialized::MergeFrom(from.startvel());
    }
    if (from.has_seed()) {
      set_seed(from.seed());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ProjectileShoot_Projectile::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ProjectileShoot_Projectile::CopyFrom(const ProjectileShoot_Projectile& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProjectileShoot_Projectile::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_startpos()) {
    if (!this->startpos().IsInitialized()) return false;
  }
  if (has_startvel()) {
    if (!this->startvel().IsInitialized()) return false;
  }
  return true;
}

void ProjectileShoot_Projectile::Swap(ProjectileShoot_Projectile* other) {
  if (other != this) {
    std::swap(projectileid_, other->projectileid_);
    std::swap(startpos_, other->startpos_);
    std::swap(startvel_, other->startvel_);
    std::swap(seed_, other->seed_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ProjectileShoot_Projectile::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ProjectileShoot_Projectile_descriptor_;
  metadata.reflection = ProjectileShoot_Projectile_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int ProjectileShoot::kAmmoTypeFieldNumber;
const int ProjectileShoot::kProjectilesFieldNumber;
#endif  // !_MSC_VER

ProjectileShoot::ProjectileShoot()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ProjectileShoot::InitAsDefaultInstance() {
}

ProjectileShoot::ProjectileShoot(const ProjectileShoot& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ProjectileShoot::SharedCtor() {
  _cached_size_ = 0;
  ammotype_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ProjectileShoot::~ProjectileShoot() {
  SharedDtor();
}

void ProjectileShoot::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ProjectileShoot::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ProjectileShoot::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ProjectileShoot_descriptor_;
}

const ProjectileShoot& ProjectileShoot::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

ProjectileShoot* ProjectileShoot::default_instance_ = NULL;

ProjectileShoot* ProjectileShoot::New() const {
  return new ProjectileShoot;
}

void ProjectileShoot::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ammotype_ = GOOGLE_ULONGLONG(0);
  }
  projectiles_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ProjectileShoot::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 ammoType = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ammotype_)));
          set_has_ammotype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_projectiles;
        break;
      }

      // repeated .ProjectileShoot.Projectile projectiles = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_projectiles:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_projectiles()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_projectiles;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ProjectileShoot::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 ammoType = 1;
  if (has_ammotype()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->ammotype(), output);
  }

  // repeated .ProjectileShoot.Projectile projectiles = 2;
  for (int i = 0; i < this->projectiles_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->projectiles(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ProjectileShoot::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 ammoType = 1;
  if (has_ammotype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->ammotype(), target);
  }

  // repeated .ProjectileShoot.Projectile projectiles = 2;
  for (int i = 0; i < this->projectiles_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->projectiles(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ProjectileShoot::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 ammoType = 1;
    if (has_ammotype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->ammotype());
    }

  }
  // repeated .ProjectileShoot.Projectile projectiles = 2;
  total_size += 1 * this->projectiles_size();
  for (int i = 0; i < this->projectiles_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->projectiles(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ProjectileShoot::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ProjectileShoot* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ProjectileShoot*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ProjectileShoot::MergeFrom(const ProjectileShoot& from) {
  GOOGLE_CHECK_NE(&from, this);
  projectiles_.MergeFrom(from.projectiles_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ammotype()) {
      set_ammotype(from.ammotype());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ProjectileShoot::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ProjectileShoot::CopyFrom(const ProjectileShoot& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProjectileShoot::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < projectiles_size(); i++) {
    if (!this->projectiles(i).IsInitialized()) return false;
  }
  return true;
}

void ProjectileShoot::Swap(ProjectileShoot* other) {
  if (other != this) {
    std::swap(ammotype_, other->ammotype_);
    projectiles_.Swap(&other->projectiles_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ProjectileShoot::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ProjectileShoot_descriptor_;
  metadata.reflection = ProjectileShoot_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* RespawnInformation_SpawnOptions_RespawnType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RespawnInformation_SpawnOptions_RespawnType_descriptor_;
}
bool RespawnInformation_SpawnOptions_RespawnType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const RespawnInformation_SpawnOptions_RespawnType RespawnInformation_SpawnOptions::SleepingBag;
const RespawnInformation_SpawnOptions_RespawnType RespawnInformation_SpawnOptions::Bed;
const RespawnInformation_SpawnOptions_RespawnType RespawnInformation_SpawnOptions::RespawnType_MIN;
const RespawnInformation_SpawnOptions_RespawnType RespawnInformation_SpawnOptions::RespawnType_MAX;
const int RespawnInformation_SpawnOptions::RespawnType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int RespawnInformation_SpawnOptions::kTypeFieldNumber;
const int RespawnInformation_SpawnOptions::kIdFieldNumber;
const int RespawnInformation_SpawnOptions::kNameFieldNumber;
const int RespawnInformation_SpawnOptions::kUnlockSecondsFieldNumber;
#endif  // !_MSC_VER

RespawnInformation_SpawnOptions::RespawnInformation_SpawnOptions()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RespawnInformation_SpawnOptions::InitAsDefaultInstance() {
}

RespawnInformation_SpawnOptions::RespawnInformation_SpawnOptions(const RespawnInformation_SpawnOptions& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RespawnInformation_SpawnOptions::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  id_ = 0u;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  unlockseconds_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RespawnInformation_SpawnOptions::~RespawnInformation_SpawnOptions() {
  SharedDtor();
}

void RespawnInformation_SpawnOptions::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void RespawnInformation_SpawnOptions::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RespawnInformation_SpawnOptions::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RespawnInformation_SpawnOptions_descriptor_;
}

const RespawnInformation_SpawnOptions& RespawnInformation_SpawnOptions::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

RespawnInformation_SpawnOptions* RespawnInformation_SpawnOptions::default_instance_ = NULL;

RespawnInformation_SpawnOptions* RespawnInformation_SpawnOptions::New() const {
  return new RespawnInformation_SpawnOptions;
}

void RespawnInformation_SpawnOptions::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    id_ = 0u;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    unlockseconds_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RespawnInformation_SpawnOptions::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .RespawnInformation.SpawnOptions.RespawnType type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::RespawnInformation_SpawnOptions_RespawnType_IsValid(value)) {
            set_type(static_cast< ::RespawnInformation_SpawnOptions_RespawnType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_id;
        break;
      }

      // required uint32 id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_name;
        break;
      }

      // required string name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_unlockSeconds;
        break;
      }

      // required float unlockSeconds = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_unlockSeconds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &unlockseconds_)));
          set_has_unlockseconds();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RespawnInformation_SpawnOptions::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .RespawnInformation.SpawnOptions.RespawnType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // required uint32 id = 2;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->id(), output);
  }

  // required string name = 3;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->name(), output);
  }

  // required float unlockSeconds = 4;
  if (has_unlockseconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->unlockseconds(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RespawnInformation_SpawnOptions::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .RespawnInformation.SpawnOptions.RespawnType type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // required uint32 id = 2;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->id(), target);
  }

  // required string name = 3;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->name(), target);
  }

  // required float unlockSeconds = 4;
  if (has_unlockseconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->unlockseconds(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RespawnInformation_SpawnOptions::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .RespawnInformation.SpawnOptions.RespawnType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // required uint32 id = 2;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required string name = 3;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required float unlockSeconds = 4;
    if (has_unlockseconds()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RespawnInformation_SpawnOptions::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RespawnInformation_SpawnOptions* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RespawnInformation_SpawnOptions*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RespawnInformation_SpawnOptions::MergeFrom(const RespawnInformation_SpawnOptions& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_unlockseconds()) {
      set_unlockseconds(from.unlockseconds());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RespawnInformation_SpawnOptions::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RespawnInformation_SpawnOptions::CopyFrom(const RespawnInformation_SpawnOptions& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RespawnInformation_SpawnOptions::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void RespawnInformation_SpawnOptions::Swap(RespawnInformation_SpawnOptions* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(id_, other->id_);
    std::swap(name_, other->name_);
    std::swap(unlockseconds_, other->unlockseconds_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RespawnInformation_SpawnOptions::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RespawnInformation_SpawnOptions_descriptor_;
  metadata.reflection = RespawnInformation_SpawnOptions_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int RespawnInformation::kSpawnOptionsFieldNumber;
const int RespawnInformation::kPreviousLifeFieldNumber;
const int RespawnInformation::kFadeInFieldNumber;
#endif  // !_MSC_VER

RespawnInformation::RespawnInformation()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RespawnInformation::InitAsDefaultInstance() {
  previouslife_ = const_cast< ::PlayerLifeStory*>(&::PlayerLifeStory::default_instance());
}

RespawnInformation::RespawnInformation(const RespawnInformation& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RespawnInformation::SharedCtor() {
  _cached_size_ = 0;
  previouslife_ = NULL;
  fadein_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RespawnInformation::~RespawnInformation() {
  SharedDtor();
}

void RespawnInformation::SharedDtor() {
  if (this != default_instance_) {
    delete previouslife_;
  }
}

void RespawnInformation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RespawnInformation::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RespawnInformation_descriptor_;
}

const RespawnInformation& RespawnInformation::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

RespawnInformation* RespawnInformation::default_instance_ = NULL;

RespawnInformation* RespawnInformation::New() const {
  return new RespawnInformation;
}

void RespawnInformation::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (has_previouslife()) {
      if (previouslife_ != NULL) previouslife_->::PlayerLifeStory::Clear();
    }
    fadein_ = false;
  }
  spawnoptions_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RespawnInformation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .RespawnInformation.SpawnOptions spawnOptions = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_spawnOptions:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_spawnoptions()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_spawnOptions;
        if (input->ExpectTag(18)) goto parse_previousLife;
        break;
      }

      // optional .PlayerLifeStory previousLife = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_previousLife:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_previouslife()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_fadeIn;
        break;
      }

      // required bool fadeIn = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fadeIn:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &fadein_)));
          set_has_fadein();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RespawnInformation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .RespawnInformation.SpawnOptions spawnOptions = 1;
  for (int i = 0; i < this->spawnoptions_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->spawnoptions(i), output);
  }

  // optional .PlayerLifeStory previousLife = 2;
  if (has_previouslife()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->previouslife(), output);
  }

  // required bool fadeIn = 3;
  if (has_fadein()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->fadein(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RespawnInformation::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .RespawnInformation.SpawnOptions spawnOptions = 1;
  for (int i = 0; i < this->spawnoptions_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->spawnoptions(i), target);
  }

  // optional .PlayerLifeStory previousLife = 2;
  if (has_previouslife()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->previouslife(), target);
  }

  // required bool fadeIn = 3;
  if (has_fadein()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->fadein(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RespawnInformation::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional .PlayerLifeStory previousLife = 2;
    if (has_previouslife()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->previouslife());
    }

    // required bool fadeIn = 3;
    if (has_fadein()) {
      total_size += 1 + 1;
    }

  }
  // repeated .RespawnInformation.SpawnOptions spawnOptions = 1;
  total_size += 1 * this->spawnoptions_size();
  for (int i = 0; i < this->spawnoptions_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->spawnoptions(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RespawnInformation::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RespawnInformation* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RespawnInformation*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RespawnInformation::MergeFrom(const RespawnInformation& from) {
  GOOGLE_CHECK_NE(&from, this);
  spawnoptions_.MergeFrom(from.spawnoptions_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_previouslife()) {
      mutable_previouslife()->::PlayerLifeStory::MergeFrom(from.previouslife());
    }
    if (from.has_fadein()) {
      set_fadein(from.fadein());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RespawnInformation::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RespawnInformation::CopyFrom(const RespawnInformation& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RespawnInformation::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000004) != 0x00000004) return false;

  for (int i = 0; i < spawnoptions_size(); i++) {
    if (!this->spawnoptions(i).IsInitialized()) return false;
  }
  if (has_previouslife()) {
    if (!this->previouslife().IsInitialized()) return false;
  }
  return true;
}

void RespawnInformation::Swap(RespawnInformation* other) {
  if (other != this) {
    spawnoptions_.Swap(&other->spawnoptions_);
    std::swap(previouslife_, other->previouslife_);
    std::swap(fadein_, other->fadein_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RespawnInformation::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RespawnInformation_descriptor_;
  metadata.reflection = RespawnInformation_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TakeDamage::kAmountFieldNumber;
const int TakeDamage::kDirectionFieldNumber;
const int TakeDamage::kTypeFieldNumber;
#endif  // !_MSC_VER

TakeDamage::TakeDamage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TakeDamage::InitAsDefaultInstance() {
  direction_ = const_cast< ::Vector3Serialized*>(&::Vector3Serialized::default_instance());
}

TakeDamage::TakeDamage(const TakeDamage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TakeDamage::SharedCtor() {
  _cached_size_ = 0;
  amount_ = 0;
  direction_ = NULL;
  type_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TakeDamage::~TakeDamage() {
  SharedDtor();
}

void TakeDamage::SharedDtor() {
  if (this != default_instance_) {
    delete direction_;
  }
}

void TakeDamage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TakeDamage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TakeDamage_descriptor_;
}

const TakeDamage& TakeDamage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

TakeDamage* TakeDamage::default_instance_ = NULL;

TakeDamage* TakeDamage::New() const {
  return new TakeDamage;
}

void TakeDamage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    amount_ = 0;
    if (has_direction()) {
      if (direction_ != NULL) direction_->::Vector3Serialized::Clear();
    }
    type_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TakeDamage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float amount = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &amount_)));
          set_has_amount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_direction;
        break;
      }

      // required .Vector3Serialized direction = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_direction:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_direction()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_type;
        break;
      }

      // required uint64 type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TakeDamage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float amount = 1;
  if (has_amount()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->amount(), output);
  }

  // required .Vector3Serialized direction = 2;
  if (has_direction()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->direction(), output);
  }

  // required uint64 type = 3;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TakeDamage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float amount = 1;
  if (has_amount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->amount(), target);
  }

  // required .Vector3Serialized direction = 2;
  if (has_direction()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->direction(), target);
  }

  // required uint64 type = 3;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TakeDamage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float amount = 1;
    if (has_amount()) {
      total_size += 1 + 4;
    }

    // required .Vector3Serialized direction = 2;
    if (has_direction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->direction());
    }

    // required uint64 type = 3;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TakeDamage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TakeDamage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TakeDamage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TakeDamage::MergeFrom(const TakeDamage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_amount()) {
      set_amount(from.amount());
    }
    if (from.has_direction()) {
      mutable_direction()->::Vector3Serialized::MergeFrom(from.direction());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TakeDamage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TakeDamage::CopyFrom(const TakeDamage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TakeDamage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_direction()) {
    if (!this->direction().IsInitialized()) return false;
  }
  return true;
}

void TakeDamage::Swap(TakeDamage* other) {
  if (other != this) {
    std::swap(amount_, other->amount_);
    std::swap(direction_, other->direction_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TakeDamage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TakeDamage_descriptor_;
  metadata.reflection = TakeDamage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UpdateItem::kItemFieldNumber;
#endif  // !_MSC_VER

UpdateItem::UpdateItem()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UpdateItem::InitAsDefaultInstance() {
  item_ = const_cast< ::Item*>(&::Item::default_instance());
}

UpdateItem::UpdateItem(const UpdateItem& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UpdateItem::SharedCtor() {
  _cached_size_ = 0;
  item_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UpdateItem::~UpdateItem() {
  SharedDtor();
}

void UpdateItem::SharedDtor() {
  if (this != default_instance_) {
    delete item_;
  }
}

void UpdateItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UpdateItem::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UpdateItem_descriptor_;
}

const UpdateItem& UpdateItem::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

UpdateItem* UpdateItem::default_instance_ = NULL;

UpdateItem* UpdateItem::New() const {
  return new UpdateItem;
}

void UpdateItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_item()) {
      if (item_ != NULL) item_->::Item::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UpdateItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Item item = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_item()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UpdateItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .Item item = 1;
  if (has_item()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->item(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UpdateItem::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .Item item = 1;
  if (has_item()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->item(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UpdateItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Item item = 1;
    if (has_item()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->item());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpdateItem::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UpdateItem* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UpdateItem*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UpdateItem::MergeFrom(const UpdateItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_item()) {
      mutable_item()->::Item::MergeFrom(from.item());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UpdateItem::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UpdateItem::CopyFrom(const UpdateItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateItem::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_item()) {
    if (!this->item().IsInitialized()) return false;
  }
  return true;
}

void UpdateItem::Swap(UpdateItem* other) {
  if (other != this) {
    std::swap(item_, other->item_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UpdateItem::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UpdateItem_descriptor_;
  metadata.reflection = UpdateItem_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UpdateItemContainer::kTypeFieldNumber;
const int UpdateItemContainer::kContainerFieldNumber;
#endif  // !_MSC_VER

UpdateItemContainer::UpdateItemContainer()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UpdateItemContainer::InitAsDefaultInstance() {
}

UpdateItemContainer::UpdateItemContainer(const UpdateItemContainer& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UpdateItemContainer::SharedCtor() {
  _cached_size_ = 0;
  type_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UpdateItemContainer::~UpdateItemContainer() {
  SharedDtor();
}

void UpdateItemContainer::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UpdateItemContainer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UpdateItemContainer::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UpdateItemContainer_descriptor_;
}

const UpdateItemContainer& UpdateItemContainer::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_main_2eproto();
  return *default_instance_;
}

UpdateItemContainer* UpdateItemContainer::default_instance_ = NULL;

UpdateItemContainer* UpdateItemContainer::New() const {
  return new UpdateItemContainer;
}

void UpdateItemContainer::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = GOOGLE_ULONGLONG(0);
  }
  container_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UpdateItemContainer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_container;
        break;
      }

      // repeated .ItemContainer container = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_container:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_container()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_container;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UpdateItemContainer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->type(), output);
  }

  // repeated .ItemContainer container = 2;
  for (int i = 0; i < this->container_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->container(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UpdateItemContainer::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->type(), target);
  }

  // repeated .ItemContainer container = 2;
  for (int i = 0; i < this->container_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->container(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UpdateItemContainer::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->type());
    }

  }
  // repeated .ItemContainer container = 2;
  total_size += 1 * this->container_size();
  for (int i = 0; i < this->container_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->container(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpdateItemContainer::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UpdateItemContainer* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UpdateItemContainer*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UpdateItemContainer::MergeFrom(const UpdateItemContainer& from) {
  GOOGLE_CHECK_NE(&from, this);
  container_.MergeFrom(from.container_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UpdateItemContainer::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UpdateItemContainer::CopyFrom(const UpdateItemContainer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateItemContainer::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < container_size(); i++) {
    if (!this->container(i).IsInitialized()) return false;
  }
  return true;
}

void UpdateItemContainer::Swap(UpdateItemContainer* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    container_.Swap(&other->container_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UpdateItemContainer::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UpdateItemContainer_descriptor_;
  metadata.reflection = UpdateItemContainer_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
